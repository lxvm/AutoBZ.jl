var documenterSearchIndex = {"docs":
[{"location":"pages/workflow/#Workflow","page":"Workflow","title":"Workflow","text":"","category":"section"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"Users of AutoBZ who would like to use the calculation scripts found in the demos folder of the repository can use the following workflow to run their jobs either locally or on a cluster. First, create a working directory for this project that will also serve as the home of its Julia environment","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"$ mkdir workdir\n$ cd workdir\n$ julia --project=. # start an interactive session in the <workdir> environment","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"In the Julia session, adding AutoBZ to the environment while cloning the repository to the working directory can be done interactively as shown below","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"julia> ] # enters the package manager\n(workdir) pkg> develop --local https://github.com/lxvm/AutoBZ.jl.git # clones repo into ./dev/AutoBZ","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"(For documentation on unregistered packages, see here.) An equivalent shell script to set up the environment with SSH is the following","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"$ mkdir dev\n$ git clone git@github.com:lxvm/AutoBZ.jl.git dev/AutoBZ\n$ julia -e 'import Pkg; Pkg.activate(\".\"); Pkg.develop(path=\"dev/AutoBZ\")'","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"From the working directory, the scripts from the demos folder can be copied back, as well any coefficient files for the calculations that will be run.","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"julia> ; # enters a shell\nshell> cp -t . dev/AutoBZ/demos/svo_hr.dat dev/AutoBZ/demos/svo_r.dat dev/AutoBZ/demos/OC_berry.jl","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"In the lines above, the script OC_berry.jl was copied along with its default data files into the working directory. Note if you have data files with different names, the script needs to be edited to load those files instead. Moreover, the files in the working directory can be freely edited without affecting those in the AutoBZ repository, and likewise the repository can be updated without affecting the files in workdir. Note that any script dependencies other than AutoBZ will need to be added to the environment in workdir (e.g. pkg> add Plots).","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"Finally, to run the script from the Julia session in the workdir, simply include(\"OC_berry.jl\"). If you would like to run a script as a cluster job, include the line below in your bash script submitted to the scheduler.","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"julia --project=. OC_berry.jl","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"When AutoBZ is released as a registered package, it will be enough to add AutoBZ to the Julia environment and copy the scripts from the installation location, although the method described above conveniently saves the repository in the working directory, letting you easily update the git repository or change branches. If working in an interactive session, this method also works with a Revise.jl workflow.","category":"page"},{"location":"pages/man/equispace_integration/#Equispace-integration","page":"Equispace integration","title":"Equispace integration","text":"","category":"section"},{"location":"pages/man/equispace_integration/#Routines","page":"Equispace integration","title":"Routines","text":"","category":"section"},{"location":"pages/man/equispace_integration/","page":"Equispace integration","title":"Equispace integration","text":"equispace_integration\nautomatic_equispace_integration","category":"page"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_integration","page":"Equispace integration","title":"AutoBZ.equispace_integration","text":"equispace_integration(f, l, npt; pre=nothing, equispace_pre_eval=generic_equispace_pre_eval, equispace_int_eval=generic_equispace_int_eval)\n\nEvaluate the integral of f over domain l using an equispace grid of npt points per dimension, optionally using precomputation pre\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.automatic_equispace_integration","page":"Equispace integration","title":"AutoBZ.automatic_equispace_integration","text":"automatic_equispace_integration(f, a, b; kwargs)\nautomatic_equispace_integration(f, l::IntegrationLimits; npt1=0, pre1=0, npt2=0, pre2=0, atol=0.0, rtol=1e-3 maxevals=typemax(Int64))\n\nAutomatically evaluates the integral of f over domain l to within the requested error tolerances atol and rtol. Allows optional precomputed data at two levels of grid refinement npt1, pre1 and npt2, pre2.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#Customization","page":"Equispace integration","title":"Customization","text":"","category":"section"},{"location":"pages/man/equispace_integration/","page":"Equispace integration","title":"Equispace integration","text":"The methods below can be extended/customized to integrand types","category":"page"},{"location":"pages/man/equispace_integration/","page":"Equispace integration","title":"Equispace integration","text":"equispace_npt_update\nequispace_pre_eval\nequispace_int_eval\nevaluate_integrand","category":"page"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_npt_update","page":"Equispace integration","title":"AutoBZ.equispace_npt_update","text":"equispace_npt_update(npt, f, atol, rtol)\n\nReturns a new npt to try and get another digit of accuracy from PTR. This fallback option is a heuristic, since the scaling of the error is generally problem-dependent.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_pre_eval","page":"Equispace integration","title":"AutoBZ.equispace_pre_eval","text":"equispace_pre_eval(f::WannierIntegrand, l::IntegrationLimits, npt)\n\nThis function will evaluate the Fourier series and integration weights needed for equispace integration of f at npt points per dimension. l should contain the relevant symmetries needed for IBZ integration, if desired.\n\n\n\n\n\nequispace_pre_eval(f, l, npt)\n\nPrecomputes the grid points and weights to use for equispace quadrature of f on the domain l while applying the relevant symmetries to l to reduce the number of evaluation points. Should return a vector of tuples with the integration weight in the first position and the precomputation in the second. This output is passed to the argument pre of equispace_int_eval.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_int_eval","page":"Equispace integration","title":"AutoBZ.equispace_int_eval","text":"equispace_int_eval(f, pre, dvol)\n\nSums the values of f on the precomputed grid points with corresponding quadrature weights and also multiplies by the mesh cell volume to obtain the integral on the precomputed domain represented by pre, obtained from equispace_pre_eval. Evaluation of f is done by the function evaluate_integrand in order to create a function boundary between the quadrature and the integrand evaluation.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.evaluate_integrand","page":"Equispace integration","title":"AutoBZ.evaluate_integrand","text":"evaluate_integrand(f, x)\n\nBy default, this calls f(x), however the caller may dispatch on the type of f if they would like to specialize this function together with equispace_pre_eval so that x is a more useful precomputation (e.g. a Fourier series evaluated at a grid point).\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#Self-energies","page":"Self energies","title":"Self energies","text":"","category":"section"},{"location":"pages/app/self_energy/#Interface","page":"Self energies","title":"Interface","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"AutoBZ.Applications.AbstractSelfEnergy\nAutoBZ.Applications.lb\nAutoBZ.Applications.ub","category":"page"},{"location":"pages/app/self_energy/#AutoBZ.Applications.AbstractSelfEnergy","page":"Self energies","title":"AutoBZ.Applications.AbstractSelfEnergy","text":"AbstractSelfEnergy\n\nAn abstract type whose instances implement the following interface:\n\ninstances are callable and return a square matrix as a function of frequency\ninstances have methods lb and ub that return the lower and upper bounds of of the frequency domain for which the instance can be evaluated\n\n\n\n\n\n","category":"type"},{"location":"pages/app/self_energy/#AutoBZ.Applications.lb","page":"Self energies","title":"AutoBZ.Applications.lb","text":"lb(::AbstractSelfEnergy)\n\nReturn the greatest lower bound of the domain of the self energy evaluator\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#AutoBZ.Applications.ub","page":"Self energies","title":"AutoBZ.Applications.ub","text":"ub(::AbstractSelfEnergy)\n\nReturn the least upper bound of the domain of the self energy evaluator\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#Types","page":"Self energies","title":"Types","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"AutoBZ.Applications.EtaEnergy\nAutoBZ.Applications.ScalarEnergy","category":"page"},{"location":"pages/app/self_energy/#AutoBZ.Applications.EtaEnergy","page":"Self energies","title":"AutoBZ.Applications.EtaEnergy","text":"EtaEnergy(η::Real)\n\nConstruct a self-energy evaluator which returns -ieta I for any frequency.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/self_energy/#AutoBZ.Applications.ScalarEnergy","page":"Self energies","title":"AutoBZ.Applications.ScalarEnergy","text":"ScalarEnergy(interpolant, lb, ub)\n\nConstruct a self-energy evaluator which for frequencies above lb and below ub returns the interpolant at that frequency times an identity matrix.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#Integrands","page":"Integrands","title":"Integrands","text":"","category":"section"},{"location":"pages/app/integrands/#Generic","page":"Integrands","title":"Generic","text":"","category":"section"},{"location":"pages/app/integrands/#Types","page":"Integrands","title":"Types","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.WannierIntegrand","category":"page"},{"location":"pages/app/integrands/#AutoBZ.Applications.WannierIntegrand","page":"Integrands","title":"AutoBZ.Applications.WannierIntegrand","text":"WannierIntegrand(f, s::AbstractFourierSeries, p)\n\nA type generically representing an integrand f whose entire dependence on the variables of integration is in a Fourier series s, and which may also accept some input parameters p, which are preferrably contained in a tuple. The caller must be aware that their function, f, will be called at many evaluation points, x, in the following way: f(s(x), p...). Therefore the caller is expected to know the type of s(x) (hint: eltype(s)) and the layout of the parameters in the tuple p.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#Methods","page":"Integrands","title":"Methods","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.pre_eval_contract(::AutoBZ.Applications.WannierIntegrand,::Any,::Any)","category":"page"},{"location":"pages/app/integrands/#Pre-defined","page":"Integrands","title":"Pre-defined","text":"","category":"section"},{"location":"pages/app/integrands/#Types-2","page":"Integrands","title":"Types","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.DOSIntegrand\nAutoBZ.Applications.GammaIntegrand\nAutoBZ.Applications.OCIntegrand\nAutoBZ.Applications.EquispaceOCIntegrand\nAutoBZ.Applications.AutoEquispaceOCIntegrand","category":"page"},{"location":"pages/app/integrands/#AutoBZ.Applications.DOSIntegrand","page":"Integrands","title":"AutoBZ.Applications.DOSIntegrand","text":"DOSIntegrand(H, ω, Σ, μ)\nDOSIntegrand(H, ω, Σ)\nDOSIntegrand(H, M)\n\nA type whose integral gives the density of states.\n\nD(ω) = -pi^-1 int_textBZ dk operatornameTrIm((omega + mu) I - H(k) - Sigma(omega))^-1\n\nThis type works with both adaptive and equispace integration routines.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.GammaIntegrand","page":"Integrands","title":"AutoBZ.Applications.GammaIntegrand","text":"GammaIntegrand(H::FourierSeries, Σ, ω, Ω, μ, [kind=:full])\nGammaIntegrand(HV, Σ, ω, Ω, μ, [kind=:full])\nGammaIntegrand(HV, Mω, MΩ, kind)\n\nA type whose integral over the BZ gives the transport distribution.\n\nGamma_alphabeta(omega Omega) = int_textBZ dk operatornameTrnu_alpha(k) A(komega) nu_beta(k) A(k omega+Omega)\n\nThis type works with both adaptive and equispace integration routines. The keyword kind determines the band velocity component (not yet implemented).\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.OCIntegrand","page":"Integrands","title":"AutoBZ.Applications.OCIntegrand","text":"OCIntegrand(H::FourierSeries, Σ, Ω, β, μ, [kind=:full])\nOCIntegrand(HV, Σ, Ω, β, μ, kind)\n\nA function whose integral over the BZ and the frequency axis gives the optical conductivity. Mathematically, this computes\n\nsigma_alphabeta(Omega) = int_-infty^infty d omega fracf(omega) - f(omega+Omega)Omega Gamma_alphabeta(omega omega+Omega)\n\nwhere f(omega) = (e^betaomega+1)^-1 is the Fermi distriubtion. Use this type only for adaptive integration and order the limits so that the integral over the Brillouin zone is the outer integral and the frequency integral is the inner integral. The keyword kind determines the band velocity component (not yet implemented).\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.EquispaceOCIntegrand","page":"Integrands","title":"AutoBZ.Applications.EquispaceOCIntegrand","text":"EquispaceOCIntegrand(σ::OCIntegrand, l, npt, pre::Vector{Tuple{NTuple{4, SMatrix{3, 3, ComplexF64, 9}},Int}})\nEquispaceOCIntegrand(σ, l, npt)\n\nThis type represents an OCIntegrand, σ integrated adaptively in frequency and with equispace integration over the Brillouin zone with a fixed number of grid points npt. The argument l should be an IntegrationLimits for just the Brillouin zone. This type should be called by an adaptive integration routine whose limits of integration are only the frequency variable.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.AutoEquispaceOCIntegrand","page":"Integrands","title":"AutoBZ.Applications.AutoEquispaceOCIntegrand","text":"AutoEquispaceOCIntegrand(σ, l, atol, rtol, npt1, pre1, npt2, pre2)\nAutoEquispaceOCIntegrand(σ, l, atol, rtol; npt1=0, pre1=Tuple{eltype(σ.HV),Int}[], npt2=0,pre2=Tuple{eltype(σ.HV),Int}[])\n\nThis type represents an OCIntegrand, σ integrated adaptively in frequency and with equispace integration over the Brillouin zone with a number of grid points necessary to meet the maximum of the tolerances given by atol and rtol. The argument l should be an IntegrationLimits for just the Brillouin zone. This type should be called by an adaptive integration routine whose limits of integration are only the frequency variable.\n\nThe keyword arguments, which are just passed to automatic_equispace_integration, are:\n\npre1: a Vector containing tuples of the evaluated Hamiltonian + band   velocities and integration weights\nnpt1: an integer that should be equivalent to length(pre1)\npre2: a Vector containing tuples of the evaluated Hamiltonian + band   velocities and integration weights on a more refined grid than pre1\nnpt2: an integer that should be equivalent to length(pre)\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#Functions","page":"Integrands","title":"Functions","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.dos_integrand\nAutoBZ.Applications.spectral_function\nAutoBZ.Applications.band_velocities\nAutoBZ.Applications.gamma_integrand\nAutoBZ.Applications.oc_integrand\nAutoBZ.Applications.fermi\nAutoBZ.Applications.fermi′\nAutoBZ.Applications.fermi_window\nAutoBZ.Applications.cosh_ratio\nAutoBZ.Applications.EXP_P1_SMALL_X","category":"page"},{"location":"pages/app/integrands/#AutoBZ.Applications.band_velocities","page":"Integrands","title":"AutoBZ.Applications.band_velocities","text":"band_velocities(kind, vs)\n\nTransform the band velocities according to the following values of kind\n\n:full: return the full band velocity\n:intra: return only the diagonal of the band velocity\n:inter: return only the off-diagonal terms of the band velocity\n\nvs should be an iterable collection of matrices\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.Applications.fermi_window","page":"Integrands","title":"AutoBZ.Applications.fermi_window","text":"Evaluates a unitless window function determined by the Fermi distribution\n\n\n\n\n\n","category":"function"},{"location":"pages/equiinterp/#EquiBaryInterp","page":"EquiBaryInterp","title":"EquiBaryInterp","text":"","category":"section"},{"location":"pages/equiinterp/","page":"EquiBaryInterp","title":"EquiBaryInterp","text":"AutoBZ.EquiBaryInterp.LocalEquiBaryInterp\nAutoBZ.EquiBaryInterp.BaryPoly\nAutoBZ.EquiBaryInterp.barycentric_weights","category":"page"},{"location":"pages/equiinterp/#AutoBZ.EquiBaryInterp.LocalEquiBaryInterp","page":"EquiBaryInterp","title":"AutoBZ.EquiBaryInterp.LocalEquiBaryInterp","text":"LocalEquiBaryInterp(x::AbstractVector, y::AbstractVector, [degree=8])\nLocalEquiBaryInterp(x::Vector, y::Vector, w::Vector, h)\n\nConstruct a local barycentric Lagrange interpolant that forms a degree degree local polynomial approximation of the data y on the equispace grid x, which must be identical to a range with step size h. w are the equispace interpolation weights.\n\n\n\n\n\n","category":"type"},{"location":"pages/equiinterp/#AutoBZ.EquiBaryInterp.BaryPoly","page":"EquiBaryInterp","title":"AutoBZ.EquiBaryInterp.BaryPoly","text":"BaryPoly(x, y)\nBaryPoly(x, y, w)\n\nConstructs a barycentric Lagrange polynomial from the data y sampled on x.\n\n\n\n\n\n","category":"type"},{"location":"pages/equiinterp/#AutoBZ.EquiBaryInterp.barycentric_weights","page":"EquiBaryInterp","title":"AutoBZ.EquiBaryInterp.barycentric_weights","text":"barycentric_weights(x::AbstractVector{T}) where {T<:Real}\n\nComputes barycentric weights for the nodes x.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#Adaptive-integration","page":"Adaptive integration","title":"Adaptive integration","text":"","category":"section"},{"location":"pages/man/adaptive_integration/#Routines","page":"Adaptive integration","title":"Routines","text":"","category":"section"},{"location":"pages/man/adaptive_integration/","page":"Adaptive integration","title":"Adaptive integration","text":"tree_integration\niterated_integration\nAutoBZ.alloc_segbufs\nAutoBZ.thunk\nAutoBZ.ThunkIntegrand","category":"page"},{"location":"pages/man/adaptive_integration/#AutoBZ.tree_integration","page":"Adaptive integration","title":"AutoBZ.tree_integration","text":"tree_integration(f, a, b)\ntree_integration(f, ::CubicLimits)\n\nCalls HCubature to perform multi-dimensional integration of f over a cube.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.iterated_integration","page":"Adaptive integration","title":"AutoBZ.iterated_integration","text":"iterated_integration(f, ::IntegrationLimits; order=4, atol=nothing, rtol=nothing, norm=norm, maxevals=typemax(Int), segbufs=nothing)\niterated_integration(f, a, b; kwargs...)\n\nCalls QuadGK to perform iterated 1D integration of f over a domain parametrized by IntegrationLimits. In the case two points a and b are passed, the integration region becomes the hypercube with those extremal vertices.\n\nReturns a tuple (I, E) of the estimated integral and estimated error.\n\nKeyword options include a relative error tolerance rtol (if atol==0, defaults to sqrt(eps) in the precision of the norm of the return type), an absolute error tolerance atol (defaults to 0), a maximum number of function evaluations maxevals for each nested integral (defaults to 10^7), and the order of the integration rule (defaults to 4).\n\nThe algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (2*order+1 points) and the error is estimated using an embedded Gauss rule (order points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved. This 1D procedure is applied recursively to each variable of integration in an order determined by l to obtain the multi-dimensional integral.\n\nUnlike quadgk, this routine does not allow infinite limits of integration nor unions of intervals to avoid singular points of the integrand.\n\nIn normal usage, iterated_integration will allocate segment buffers. You can instead pass a preallocated buffer allocated using alloc_segbufs as the segbuf argument. This buffer can be used across multiple calls to avoid repeated allocation.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.alloc_segbufs","page":"Adaptive integration","title":"AutoBZ.alloc_segbufs","text":"alloc_segbufs(eltype_l, typeof_fx, typeof_nfx, ndims_l)\n\nThis helper function will allocate enough segment buffers as are needed for an iterated_integration call of integrand f and integration limits l. eltype_l should be eltype(l), typeof_fx should be the return type of the integrand f, typeof_nfx should be the type of the norm of a value of f, and ndims_l should be ndims(l).\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.thunk","page":"Adaptive integration","title":"AutoBZ.thunk","text":"thunk(f, x)\n\nDelay the computation of f(x). Needed to normally evaluate an integrand in nested integrals, a setting in which the values of the variables of integration are passed one at a time. Importantly, thunk assumes that the variables of integration are passed from the outermost to the innermost. For example, to evaluate f([1, 2]), call thunk(f, 2)(1).\n\nThis behavior is consistent with CubicLimits, but may come as a surprise if implementing new IntegrationLimits.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.ThunkIntegrand","page":"Adaptive integration","title":"AutoBZ.ThunkIntegrand","text":"ThunkIntegrand(f, x)\n\nStore f and x to evaluate f(x) at a later time. Employed by iterated_integration for generic integrands that haven't been specialized to use iterated_pre_eval.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/adaptive_integration/#Customization","page":"Adaptive integration","title":"Customization","text":"","category":"section"},{"location":"pages/man/adaptive_integration/","page":"Adaptive integration","title":"Adaptive integration","text":"The methods below can be extended/customized to integrand types","category":"page"},{"location":"pages/man/adaptive_integration/","page":"Adaptive integration","title":"Adaptive integration","text":"iterated_tol_update\niterated_pre_eval\nAutoBZ.infer_f","category":"page"},{"location":"pages/man/adaptive_integration/#AutoBZ.iterated_tol_update","page":"Adaptive integration","title":"AutoBZ.iterated_tol_update","text":"iterated_tol_update(f, l, atol, rtol)\n\nChoose a new set of error tolerances for the next inner integral. By default returns (atol, rtol) unchanged.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.iterated_pre_eval","page":"Adaptive integration","title":"AutoBZ.iterated_pre_eval","text":"iterated_pre_eval(f, x, dim)\niterated_pre_eval(f, x)\n\nPerform a precomputation on f using the value of a variable of integration, x. The default is to store x and delay the computation of f(x) until all of the values of the variables of integration are determined at a integration point. Certain types of functions, such as Fourier series, take can use x to precompute a new integrand for the remaining variables of integration that is more computationally efficient. This function must return the integrand for the subsequent integral.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.infer_f","page":"Adaptive integration","title":"AutoBZ.infer_f","text":"infer_f(f, Tx)\n\nEvaluates f(zero(Tx)) and norm(f(zero(Tx))) and returns their types. If the type of the range of f is known apriori, this method is meant to be specialized. Implicitly this assumes that f is type-stable.\n\n\n\n\n\n","category":"function"},{"location":"pages/demo/#Demos","page":"Demos","title":"Demos","text":"","category":"section"},{"location":"pages/demo/#DOS-of-the-integer-lattice-tight-binding-model","page":"Demos","title":"DOS of the integer lattice tight-binding model","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"To demonstrate setting up a DOS calculation with AutoBZ, we consider a tight-binding model on the n-dimensional integer lattice with lattice constant a and hopping strength t0:","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"H = -t sum_i in Z^n sum_j=1^n ketibrai+hatj + keti+hatjbrai","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Solving this model by employing Bloch's theorem yields the following band","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"H(k_1 ldots k_n) = -t(cos(k_1 a) + cdots + cos(k_n a))","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"We shall input this Hamiltonian by constructing the equivalent Fourier series","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using StaticArrays\nusing OffsetArrays\n\nusing AutoBZ\nusing AutoBZ.Applications\n\nn = 3 # arbitrary positive integer\na = fill(1.0, SVector{n})\nax = repeat([-1:1], n)\nC = zeros(SMatrix{1,1,ComplexF64,1}, ntuple(_ -> 3, n))\nfor i in 1:n, j in (-1, 1)\n    C[CartesianIndex(ntuple(k -> k == i ? 2+j : 2, n))] = SMatrix{1,1,ComplexF64,1}(0.5)\nend\nH = FourierSeries(OffsetArray(C, ax...), a)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Then we can define the integration problem to compute DOS, defined by the integral","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"operatornameDOS(omega) = int_textBZ dveck operatornameTrImomega+mu-H(veck)+ieta","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where mu is the chemical potential and eta is a constant scattering rate.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"ω = 1.0*n # frequency\nη = 0.1 # broadening\nμ = 0.0 # chemical potential\nΣ = EtaEnergy(η) # self energy\nD = DOSIntegrand(H, ω, Σ, μ) # integrand\n\n# construct IBZ integration limits\nc = CubicLimits(H.period)\nt = TetrahedralLimits(c)\n\n# set error tolerances\natol = 1e-3\nrtol = 0.0\n\niterated_integration(D, t; callback=contract, atol=atol, rtol=rtol)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"You will find a working example of this model in the DOS_example.jl demo that computes DOS over a range of frequencies for this model.","category":"page"},{"location":"pages/demo/#Custom-integrands","page":"Demos","title":"Custom integrands","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"For integrands that can be evaluated by Wannier interpolation, the following data are necessary to define an integrand:","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"the integrand evaluator\na Fourier series\nadditional parameters for the evaluator","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Consider implementing custom integrands using the generic template type AutoBZ.Applications.WannierIntegrand that is compatible with all of the adaptive and equispace integration routines. For example, we can replicate the preceding tight-binding example by defining a custom integrand","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using LinearAlgebra\ndos(H_k::AbstractMatrix, ω, μ, η) = -tr(imag(inv(complex(ω+μ, η)*I-H_k)))/pi\nD = WannierIntegrand(dos, H, (ω, μ, η))","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"tip: Optimizing equispace integration\nUnlike for adaptive integration, the caller is responsible for passing pre-computed grid values to the equispace integration routines, which is explained in the documentation for Equispace integration and AutoBZ.Applications.pre_eval_contract.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"warning: Mixing adaptive and equispace integrals\nWhile it is possible to perform an integral where some variables are integrated adaptively and others are integrated uniformly, this guide will not explain how to do this. However, an example implementation of this is  AutoBZ.Applications.AutoEquispaceOCIntegrand.","category":"page"},{"location":"pages/demo/#Graphene-example-with-ManyOffsetsFourierSeries","page":"Demos","title":"Graphene example with ManyOffsetsFourierSeries","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Let's study an example motivated by graphene whose Hamiltonian is given by a tight-binding model on the hexagonal lattice with lattice constant a and hopping amplitude t. Applying Bloch's theorem to each triangular sublattice brings the Hamiltonian into block-diagonal form, where each block is of the form","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"-t\nbeginpmatrix\n0  f(k)\n f^*(k)  0\nendpmatrix","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where f(k) = e^ikcdotdelta_1 + e^ikcdotdelta_2 + e^ikcdotdelta_3 and delta_1 = ahatx delta_2 = a(-12hatx+sqrt32haty) delta_3 = a(-12hatx-sqrt32haty). To exactly construct this Fourier series, we will have to rotate basis so that these vectors are precisely integer linear combinations of the new lattice vectors. Note that by defining hata_1 = (delta_1 - delta_3)3a = (hatx + 1sqrt3haty)2 hata_2 = (delta_1 - delta_2)3a = (hatx - 1sqrt3haty)2 we can write delta_1 = a(hata_1 + hata_2) delta_2 = a(hata_1 - 2hata_2) delta_3 = a(-2hata_1 + hata_2). Therefore our coordinate transformation matrix, T from Cartesian coordinates to the triangular lattice, veca_i = 3ahata_i, is","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"T = frac12\nbeginpmatrix\n1  1sqrt3\n 1  -1sqrt3\nendpmatrix\nqquad\nT^-1 =\nbeginpmatrix\n1  1\n sqrt3  -sqrt3\nendpmatrix","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"and note operatornamedet(T) = 12sqrt3. Now the corresponding reciprocal lattice vectors are constructed by the relation hatb_i = epsilon_ij (hatz times hata_j) and rescaling so that hatb_i cdot hata_j = 2pidelta_ij. This yields hatb_1 = 2pi(hatx+sqrt3haty) = 4pi(hata_1 - 2hata_2) hatb_2 = 2pi(hatx-sqrt3haty) = 4pi(2hata_1 - hata_2). We would now interpret k in this basis, and could also use T to map from the Cartesian basis to it. Also observe that if a is the lattice constant of the hexagonal lattice, then sqrt3a is the lattice constant of the triangular lattice, and 2pisqrt3a is the lattice constant of the reciprocal lattice. However, we will have to rescale integrals by factors of operatornamedetT because of our coordinate transformations.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Having chosen this suitable basis for k and x, we can now express the k-dependence of the block Hamiltonian as","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"f(k) = e^ikcdotdelta_1 + e^ikcdotdelta_2 + e^ikcdotdelta_3\n= e^iakcdot(hata_1 + hata_2) + e^iakcdot(hata_1 - 2hata_2) + e^iakcdot(-2hata_1 + hata_2)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"which is amenable to a Fourier series representation.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Suppose that the integral we want to calculate is","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"g(vecq) = int_textBZ dk_x dk_y fraclambda(xi(veck)) - lambda(xi(veck-vecq))xi(veck) - xi(veck-vecq)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where xi(veck) = operatornamedet(H(veck)) and lambda(omega) = partial_T f(omega) is the temperature derivative of the Fermi distribution. Since the integrand requires evaluation of the Hamiltonian at various k-points simultaneously, the AutoBZ.Applications.ManyOffsetsFourierSeries type can be used to do this. Moreover, AutoBZ.Applications has functions to evaluate Fermi functions and their derivatives. Putting everything together leads us to the code example below","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using StaticArrays\nusing OffsetArrays\n\nusing AutoBZ\nusing AutoBZ.Applications\n\na = 1.0\nC = OffsetArray(zeros(SMatrix{2,2,ComplexF64,4}, (5,5)), -2:2, -2:2)\nC[1,1]   = C[1,-2] = C[-2,1] = [0 1; 0 0]\nC[-1,-1] = C[-1,2] = C[2,-1] = [0 0; 1 0]\nH = FourierSeries(C, 2*pi/a)\n\nT = 100.0 # K\nkB = 8.617333262e-5 # eV/K\nq = rand(SVector{2,Float64}) # arbitrary\nf = ManyOffsetsFourierSeries(H, q)\n\nlambda(x, T, kB) = -AutoBZ.Applications.fermi′(inv(kB*T), x)/(kB*T^2)\nintegrand_(f, T, kB) = (lambda(det(f[1]), T, kB) - lambda(det(f[2]), T, kB))/(det(f[1])-det(f[2]))\nintegrand = WannierIntegrand(integrand_, f, (T, kB))\n\nc = CubicLimits(H.period)\n\n# set error tolerances\natol = 1e-3\nrtol = 0.0\n\niterated_integration(integrand, c; callback=contract, atol=atol, rtol=rtol)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"You will find a working example of this code in the graphene.jl demo that calculates this integral for values of vecq in the Brillouin zone.","category":"page"},{"location":"pages/adaptinterp/#AdaptChebInterp","page":"AdaptChebInterp","title":"AdaptChebInterp","text":"","category":"section"},{"location":"pages/adaptinterp/","page":"AdaptChebInterp","title":"AdaptChebInterp","text":"AutoBZ.AdaptChebInterp.adaptchebinterp","category":"page"},{"location":"pages/adaptinterp/#AutoBZ.AdaptChebInterp.adaptchebinterp","page":"AdaptChebInterp","title":"AutoBZ.AdaptChebInterp.adaptchebinterp","text":"adaptchebinterp(f, a, b; order=4, atol=0, rtol=0, norm=norm, maxevals=typemax(Int), initdiv=1)\n\nReturn a piecewise polynomial interpolant of f on the interval ab of degree order that is pointwise accurate to the requested tolerances.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#Jobs","page":"Jobs","title":"Jobs","text":"","category":"section"},{"location":"pages/jobs/","page":"Jobs","title":"Jobs","text":"The module AutoBZ.Jobs has batch functions that setup optical conductivity calculations.","category":"page"},{"location":"pages/jobs/#Scripts","page":"Jobs","title":"Scripts","text":"","category":"section"},{"location":"pages/jobs/","page":"Jobs","title":"Jobs","text":"AutoBZ.Jobs.OCscript\nAutoBZ.Jobs.OCscript_equispace\nAutoBZ.Jobs.OCscript_auto\nAutoBZ.Jobs.OCscript_auto_equispace","category":"page"},{"location":"pages/jobs/#AutoBZ.Jobs.OCscript","page":"Jobs","title":"AutoBZ.Jobs.OCscript","text":"OCscript(HV::BandEnergyBerryVelocities, Σ::AbstractSelfEnergy, β, Ωs, μ, atol, rtol)\n\nReturns a NamedTuple with names OC, err, t, Omega containing the results, errors, and timings for an optical conductivity calculation done at frequencies Ωs with parameters β, μ, atol, rtol. This function constructs an OCIntegrand for each parameter value and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.OCscript_equispace","page":"Jobs","title":"AutoBZ.Jobs.OCscript_equispace","text":"OCscript_equispace(HV::BandEnergyBerryVelocities, Σ::AbstractSelfEnergy, β, Ωs, μ, npt, atol, rtol; pre_eval=pre_eval_contract)\n\nReturns a NamedTuple with names OC, err, t, Omega containing the results, errors, and timings for an optical conductivity calculation done at frequencies Ωs with parameters β, μ, atol, rtol. This function constructs an EquispaceOCIntegrand for each parameter value, and precomputes HV on an equispace k grid with npt points per dimension (which is reused for all parameter values), and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.OCscript_auto","page":"Jobs","title":"AutoBZ.Jobs.OCscript_auto","text":"OCscript_auto(HV::BandEnergyBerryVelocities, Σ::AbstractSelfEnergy, β, Ωs, μ, atol, rtol; ertol=1.0, eatol=0.0)\n\nReturns a NamedTuple with names OC, err, t, Omega containing the results, errors, and timings for an optical conductivity calculation done at frequencies Ωs with parameters β, μ, atol, rtol. This function constructs both an AutoEquispaceOCIntegrand with wide tolerances eatol and ertol which estimates the integral, int, and then uses narrow tolerances set by max(atol,rtol*norm(int)) and rtol to construct an OCIntegrand for each parameter value and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results.\n\nSince this is intended to compute a cheap equispace integral first, it is recommended to over-ride the default k-grid refinement step to something eta-independent with a line like the one below before calling this script\n\nAutoBZ.equispace_npt_update(npt, ::GammaIntegrand, atol, rtol) = npt + 50\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.OCscript_auto_equispace","page":"Jobs","title":"AutoBZ.Jobs.OCscript_auto_equispace","text":"OCscript_auto_equispace(HV::BandEnergyBerryVelocities, Σ::AbstractSelfEnergy, β, Ωs, μ, atol, rtol)\n\nReturns a NamedTuple with names OC, err, t, Omega containing the results, errors, and timings for an optical conductivity calculation done at frequencies Ωs with parameters β, μ, atol, rtol. This function constructs an AutoEquispaceOCIntegrand for each parameter value, reusing k-grids of HV values from previous calculations, and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#Parallelized-scripts","page":"Jobs","title":"Parallelized scripts","text":"","category":"section"},{"location":"pages/jobs/","page":"Jobs","title":"Jobs","text":"AutoBZ.Jobs.OCscript_parallel\nAutoBZ.Jobs.OCscript_equispace_parallel\nAutoBZ.Jobs.OCscript_auto_parallel_\nAutoBZ.Jobs.OCscript_auto_equispace_parallel","category":"page"},{"location":"pages/jobs/#AutoBZ.Jobs.OCscript_parallel","page":"Jobs","title":"AutoBZ.Jobs.OCscript_parallel","text":"OCscript_parallel(filename, HV::BandEnergyBerryVelocities, Σ::AbstractSelfEnergy, β, Ωs, μ, atol, rtol; nthreads=Threads.nthreads())\n\nWrites an h5 archive to filename with groups OC, err, t, Omega containing the results, errors, and timings for an optical conductivity calculation done at frequencies Ωs with parameters β, μ, atol, rtol. This function constructs an OCIntegrand for each parameter value and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results. The calculation is parallelized over Ωs on nthreads threads.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.OCscript_equispace_parallel","page":"Jobs","title":"AutoBZ.Jobs.OCscript_equispace_parallel","text":"OCscript_equispace_parallel(filename, HV::BandEnergyBerryVelocities, Σ::AbstractSelfEnergy, β, Ωs, μ, npt, atol, rtol; pre_eval=pre_eval_contract, nthreads=Threads.nthreads())\n\nWrites an h5 archive to filename with groups OC, err, t, Omega containing the results, errors, and timings for an optical conductivity calculation done at frequencies Ωs with parameters β, μ, atol, rtol. This function constructs an EquispaceOCIntegrand for each parameter value, and precomputes HV on an equispace k grid with npt points per dimension (which is reused for all parameter values), and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results. The calculation is parallelized over Ωs on nthreads threads.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.OCscript_auto_equispace_parallel","page":"Jobs","title":"AutoBZ.Jobs.OCscript_auto_equispace_parallel","text":"OCscript_auto_equispace_parallel(filename, HV::BandEnergyBerryVelocities, Σ::AbstractSelfEnergy, β, Ωs, μ, atol, rtol; nthreads=Threads.nthreads())\n\nWrites an h5 archive to filename with groups OC, err, t, Omega containing the results, errors, and timings for an optical conductivity calculation done at frequencies Ωs with parameters β, μ, atol, rtol. This function constructs an AutoEquispaceOCIntegrand for each parameter value, reusing k-grids of HV values from previous calculations, and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results. The calculation is parallelized over Ωs on nthreads threads.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#I/O","page":"Jobs","title":"I/O","text":"","category":"section"},{"location":"pages/jobs/","page":"Jobs","title":"Jobs","text":"Note: currently Julia's HDF5 module handles arrays of complex values inconsistently with Python's HDF5 module. This could be fixed by simply using PyCall to use Python's h5py library instead.","category":"page"},{"location":"pages/jobs/","page":"Jobs","title":"Jobs","text":"AutoBZ.Jobs.read_h5_to_nt\nAutoBZ.Jobs.write_nt_to_h5\nAutoBZ.Jobs.import_self_energy","category":"page"},{"location":"pages/jobs/#AutoBZ.Jobs.read_h5_to_nt","page":"Jobs","title":"AutoBZ.Jobs.read_h5_to_nt","text":"read_h5_to_nt(filename)\n\nLoads the h5 archive from filename and reads its datasets into a NamedTuple\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.write_nt_to_h5","page":"Jobs","title":"AutoBZ.Jobs.write_nt_to_h5","text":"write_nt_to_h5(nt::NamedTuple, filename)\n\nTakes a NamedTuple and writes its values, which must be arrays, into an h5 archive at filename with dataset names corresponding to the tuple names.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.import_self_energy","page":"Jobs","title":"AutoBZ.Jobs.import_self_energy","text":"import_self_energy(filename)\n\nReads the groups omega and sigma in the h5 archive in filename and tries save it to a NamedTuple with names ω and Σ. The array in sigma should be of size (length(omega), 2), where the two columns are the real and imaginary parts of Σ.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#Internal","page":"Jobs","title":"Internal","text":"","category":"section"},{"location":"pages/jobs/","page":"Jobs","title":"Jobs","text":"AutoBZ.Jobs.BandEnergyBerryVelocities\nAutoBZ.Jobs.get_safe_freq_limits\nAutoBZ.Jobs.batch_smooth_param","category":"page"},{"location":"pages/jobs/#AutoBZ.Jobs.BandEnergyBerryVelocities","page":"Jobs","title":"AutoBZ.Jobs.BandEnergyBerryVelocities","text":"BandEnergyBerryVelocities\n\nUnion type of BandEnergyBerryVelocity, BandEnergyBerryVelocity3D, BandEnergyVelocity, and BandEnergyVelocity3D.\n\n\n\n\n\n","category":"type"},{"location":"pages/jobs/#AutoBZ.Jobs.get_safe_freq_limits","page":"Jobs","title":"AutoBZ.Jobs.get_safe_freq_limits","text":"get_safe_freq_limits(Ωs, β, lb, ub)\n\nGiven a collection of frequencies, Ωs, returns a Vector{CubicLimits{1}} with truncated limits of integration for the frequency integral at each (Ω, β) point that are determined by the fermi_window_limits routine set to the default tolerances for the decay of the Fermi window function. The arguments lb and ub are lower and upper limits on the frequency to which the default result gets truncated if the default result would recommend a wider interval. If there is any truncation, a warning is emitted to the user, but the program will continue with the truncated limits.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.batch_smooth_param","page":"Jobs","title":"AutoBZ.Jobs.batch_smooth_param","text":"batch_smooth_param(xs, nthreads)\n\nIf the cost of a calculation smoothly varies with the parameters xs, then batch xs into nthreads groups where the ith element of group j is xs[j+(i-1)*nthreads]\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"pages/app/interfaces/#Wannier90","page":"Interfaces","title":"Wannier90","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"AutoBZ.Applications.load_hamiltonian\nAutoBZ.Applications.load_hamiltonian_velocities\nAutoBZ.Applications.load_position_operator\nAutoBZ.Applications.parse_hamiltonian\nAutoBZ.Applications.parse_position_operator","category":"page"},{"location":"pages/app/interfaces/#AutoBZ.Applications.load_hamiltonian","page":"Interfaces","title":"AutoBZ.Applications.load_hamiltonian","text":"load_hamiltonian(filename; period=1.0, compact=:N)\n\nLoad an ab-initio Hamiltonian output from Wannier90 into filename as an evaluatable FourierSeries whose periodicity can be set by the keyword argument period which defaults to setting the period along each dimension to 1.0. To define different periods for different dimensions, pass an SVector as the period. To store Hermitian Fourier coefficients in compact form, use the keyword compact to specify:\n\n:N: do not store the coefficients in compact form\n:L: store the lower triangle of the coefficients\n:U: store the upper triangle of the coefficients\n:S: store the lower triangle of the symmetrized coefficients, (c+c')/2\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.Applications.load_hamiltonian_velocities","page":"Interfaces","title":"AutoBZ.Applications.load_hamiltonian_velocities","text":"load_hamiltonian_velocities(f_hamiltonian, [f_pos_op]; period=1.0, compact=:N)\n\nLoad the Hamiltonian and band velocities, which may later be passed to one of the integrand constructors. When called with one filename, that file is parsed as a Wannier 90 Hamiltonian and the resulting Band velocities are just the gradient of the Hamiltonian. The return type is BandEnergyVelocity3D. When called with two filenames, the second is parsed as a position operator from Wannier 90 and adds a contribution to band velocities from the Berry connection. The return type is BandEnergyBerryVelocity3D.The keywords period and compact set the reciprocal unit cell length and whether the coefficients of the Fourier series should be compressed as Hermitian matrices. Typically the coefficients cannot be compressed despite the values of the series being Hermitian.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.Applications.load_position_operator","page":"Interfaces","title":"AutoBZ.Applications.load_position_operator","text":"load_position_operator(filename; period=1.0, compact=nothing)\n\nLoad a position operator Hamiltonian output from Wannier90 into filename as an evaluatable ManyFourierSeries with separate x, y, and z components whose periodicity can be set by the keyword argument period which defaults to setting the period along each dimension to 1.0. To define different periods for different dimensions, pass an SVector as the period. To store Hermitian Fourier coefficients in compact form, use the keyword compact to specify:\n\n:N: do not store the coefficients in compact form\n:L: store the lower triangle of the coefficients\n:U: store the upper triangle of the coefficients\n:S: store the lower triangle of the symmetrized coefficients, (c+c')/2\n\nNote that in some cases the coefficients are not Hermitian even though the values of the series are.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.Applications.parse_hamiltonian","page":"Interfaces","title":"AutoBZ.Applications.parse_hamiltonian","text":"parse_hamiltonian(filename)\n\nParse an ab-initio Hamiltonian output from Wannier90 into filename, extracting the fields (date_time, num_wann, nrpts, degen, irvec, C)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.Applications.parse_position_operator","page":"Interfaces","title":"AutoBZ.Applications.parse_position_operator","text":"parse_position_operator(filename)\n\nParse a position operator output from Wannier90 into filename, extracting the fields (date_time, num_wann, nrpts, irvec, X, Y, Z)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#Python","page":"Interfaces","title":"Python","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Julia code, including AutoBZ.jl, can be called from Python using the package PyJulia","category":"page"},{"location":"pages/app/interfaces/#Setup","page":"Interfaces","title":"Setup","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"TL;DR","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"$ julia -e 'import Pkg; Pkg.add(\"PyCall\")'\n$ python3 -m pip install julia","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"If you want to, you can install PyJulia in a Python venv, but on the Julia side PyCall.jl must be installed in the default environment","category":"page"},{"location":"pages/app/interfaces/#Demo","page":"Interfaces","title":"Demo","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The Python snippet below shows how from the demos folder of the AutoBZ repository you can run one of the demo scripts:","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"from julia.api import Julia\njl = Julia(compiled_modules=False)\n\n# julia environment setup in working directory 'demos'\njl.eval(\"\"\"\nimport Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n\"\"\")\n\n# capture output of script\nout = jl.eval('include(\"DOS_test.jl\")')","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The first two lines are adapted for loading PyJulia on Debian systems.","category":"page"},{"location":"pages/app/fourier/#Fourier-series","page":"Fourier series","title":"Fourier series","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Wannier-interpolated Hamiltonians are represented by Fourier series with a modest number of Fourier coefficients. The goal of this page of documentation is to describe the features, interface, and conventions of Fourier series evaluation as implemented by this library.","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"note: Representing Hamiltonians with Fourier series\nFourier series represent functions with sinusoids whose frequencies are integer multiples of a fundamental. In the band theory of solids, the fundamental frequencies for a Hamiltonian correspond to the real-space lattice vectors that generate a Bravais lattice, and so it is best to represent the momentum variable veck in the basis of the reciprocal lattice. Since it is conventional to construct a reciprocal lattice vecb_j from a Bravais lattice veca_i such that vecb_j cdot veca_i = 2pidelta_ij, the Fourier series in this library are defined with a phase factor scaled by 2pi. Additionally, any coordinate transformations of veck from the Cartesian basis to the reciprocal lattice basis only modify Brillouin zone integrals by a multiplicative factor of the absolute value of the determinant of the basis transformation. To find a non-trivial example of representing a Hamiltonian in the reciprocal lattice basis, see the Graphene example with ManyOffsetsFourierSeries.","category":"page"},{"location":"pages/app/fourier/#Interface","page":"Fourier series","title":"Interface","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.AbstractFourierSeries\nAutoBZ.Applications.period\nAutoBZ.Applications.contract\nAutoBZ.Applications.value","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.AbstractFourierSeries","page":"Fourier series","title":"AutoBZ.Applications.AbstractFourierSeries","text":"AbstractFourierSeries{N}\n\nA supertype for Fourier series that are periodic maps R^N to V where V is any vector space. Typically these can be represented by N-dimensional arrays whose elements belong to the vector space. See the manual section on the AbstractFourierSeries interface.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.period","page":"Fourier series","title":"AutoBZ.Applications.period","text":"period(f::AbstractFourierSeries{N}) where {N}\n\nReturn a NTuple{N} whose m-th element corresponds to the period of f along its m-th input dimension. Typically, these values set the units of length for the problem.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/fourier/#AutoBZ.Applications.contract","page":"Fourier series","title":"AutoBZ.Applications.contract","text":"contract(f::AbstractFourierSeries{N}, x::Number, [dim=N]) where {N}\n\nReturn another Fourier series of dimension N-1 by summing over dimension dim of f with the phase factors evaluated at x. If N=1, this function should return an AbstractFourierSeries{0} that stores the evaluated Fourier series, but has no more input dimensions to contract.\n\nThe default of dim=N is motivated by preserving memory locality in Julia's column-major array format.\n\ncontract(f::AbstractFourierSeries{N}, x::SVector{M}) where {N,M}\n\nContract the outermost indices M of f in order of last(x) to first(x). If M>N, the default behavior is just to try and contract M indices, which will likely lead to an error.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/fourier/#AutoBZ.Applications.value","page":"Fourier series","title":"AutoBZ.Applications.value","text":"value(::AbstractFourierSeries{0})\n\nReturn the evaluated Fourier series whose indices have all been contracted. Typically, this value has the same units as the Fourier series coefficients.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Additonally, concrete subtypes of AbstractFourierSeries must have an element type, which they can do by extending Base.eltype with a method. For example, if a type MyFourierSeries <: AbstractFourierSeries always returns ComplexF64 outputs, then the correct eltype method to define would be:","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Base.eltype(::Type{MyFourierSeries}) = ComplexF64","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"The type returned should correspond to the vector space V of the output space of the Fourier series, i.e. the output of value should be of this type. For good performance, the eltype should be a concrete type and should be inferrable.","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"With the above implemented, several methods which define functors for AbstractFourierSeries allow the user (and integration routines) to evaluate the type like a function with the f(x) syntax.","category":"page"},{"location":"pages/app/fourier/#Types","page":"Fourier series","title":"Types","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"The concrete types listed below all implement the AbstractFourierSeries interface and should cover most use cases.","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.FourierSeries\nAutoBZ.Applications.FourierSeriesDerivative\nAutoBZ.Applications.OffsetFourierSeries\nAutoBZ.Applications.ManyFourierSeries\nAutoBZ.Applications.ManyOffsetsFourierSeries\nAutoBZ.Applications.BandEnergyVelocity\nAutoBZ.Applications.BandEnergyBerryVelocity","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.FourierSeries","page":"Fourier series","title":"AutoBZ.Applications.FourierSeries","text":"FourierSeries(coeffs, period::SVector{N,Float64}) where {N}\n\nConstruct a Fourier series whose coefficients are given by the coefficient array array coeffs whose eltype should support addition and scalar multiplication, and whose periodicity on the ith axis is given by period[i]. This type represents the Fourier series\n\nf(vecx) = sum_vecn in mathcal I C_vecn exp(i2piveck_vecncdotoverrightarrowx)\n\nwhere i = sqrt-1 is the imaginary unit, C is the array coeffs, mathcal I is CartesianIndices(C), vecn is a CartesianIndex and veck_vecn is equal to n_jp_j in the jth position with p_j the jth element of period. Because of the choice to use Cartesian indices to set the phase factors, typically the indices of coeffs should be specified by using an OffsetArray.\n\nFourierSeries(coeffs::AbstractArray{T,N}, period::Real) where {T,N}\n\nIf period is a Real, this constructor will infer the number of input dimensions of the Fourier series from the array dimensionality of the coefficients, and period will become the period of all of the dimensions.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.FourierSeriesDerivative","page":"Fourier series","title":"AutoBZ.Applications.FourierSeriesDerivative","text":"FourierSeriesDerivative(f::FourierSeries{N}, a::SVector{N}) where {N}\n\nRepresent the differential of Fourier series f by a multi-index a of derivatives, e.g. [1,2,...], whose ith entry represents the order of differentiation on the ith input dimension of f. Mathematically, this means\n\nleft( prod_j=1^N partial_x_j^a_j right) f(vecx) = sum_vecn in mathcal I left( prod_j=1^N (i 2pi k_j)^a_j right) C_vecn exp(i2piveck_vecncdotoverrightarrowx)\n\nwhere partial_x_j^a_j represents the a_jth derivative of x_j, i = sqrt-1 is the imaginary unit, C is the array coeffs, mathcal I is CartesianIndices(C), vecn is a CartesianIndex and veck_vecn is equal to n_jp_j in the jth position with p_j the jth element of period. Because of the choice to use Cartesian indices to set the phase factors, typically the indices of coeffs should be specified by using an OffsetArray. Also, note that termwise differentiation of the Fourier series results in additional factors of i2pi which should be anticipated for the use case. Also, note that this type can be used to represent fractional differentiation or integration by suitably choosing the a_js.\n\nThis is a 'lazy' representation of the derivative because instead of differentiating by computing all of the Fourier coefficients of the derivative upon constructing the object, the evaluator waits until it contracts the differentiated dimension to evaluate the new coefficients.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.OffsetFourierSeries","page":"Fourier series","title":"AutoBZ.Applications.OffsetFourierSeries","text":"OffsetFourierSeries(f::AbstractFourierSeries{N}, q::SVector{N,Float64}) where {N}\n\nRepresent a Fourier series whose argument is offset by the vector vecq and evaluates it as f(vecx-vecq).\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.ManyFourierSeries","page":"Fourier series","title":"AutoBZ.Applications.ManyFourierSeries","text":"ManyFourierSeries(fs::AbstractFourierSeries{N}...) where {N}\n\nRepresents a tuple of Fourier series of the same dimension and periodicity and contracts them all simultaneously.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.ManyOffsetsFourierSeries","page":"Fourier series","title":"AutoBZ.Applications.ManyOffsetsFourierSeries","text":"ManyOffsetsFourierSeries(f, qs..., [origin=true])\n\nRepresent a Fourier series evaluated at many different points, and contract them all simultaneously, returning them in the order the qs were passed, i.e. (f(x-qs[1]), f(x-qs[2]), ...) The origin keyword decides whether or not to evaluate f without an offset, and if origin is true, the value of f evaluated without an offset will be returned in the first position of the output.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.BandEnergyVelocity","page":"Fourier series","title":"AutoBZ.Applications.BandEnergyVelocity","text":"BandEnergyVelocity(H::FourierSeries{N}, V::ManyFourierSeries{N}) where N\nBandEnergyVelocity(H::FourierSeries{N}) where N\n\nThe bottom constructor takes a Fourier series representing the Hamiltonian and also evaluates the band velocities so that the return value after all the dimensions are contracted is a tuple containing (H, v₁, v₂, ..., vₙ). The band velocities are defined by dipole operators nu_alpha = frac1hbar partial_k_alpha H where k_alpha is one of three input dimensions of H and hbar=1. Effectively, this type evaluates H and its gradient. Note that differentiation by k changes the units to have an additional dimension of length and a factor of 2pi, so if H has dimensions of energy, nu has dimensions of energy times length. The caller is responsible for transforming the units of the velocity (i.e. hbar) if they want other units, which can usually be done as a post-processing step.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.BandEnergyBerryVelocity","page":"Fourier series","title":"AutoBZ.Applications.BandEnergyBerryVelocity","text":"BandEnergyBerryVelocity(H::BandEnergyVelocity{N}, A::ManyFourierSeries{N}) where N\nBandEnergyBerryVelocity(H::FourierSeries{N}, A::ManyFourierSeries{N,<:NTuple{N}}, [kind=:full]) where N\n\nThis constructor takes a FourierSeries, H, representing the Hamiltonian and also a ManyFourierSeries, A, representing the gradient of the Berry connection, and evaluates modified band velocities so that the return value after all the dimensions are contracted is a tuple containing (H, ṽ₁, ṽ₂, ..., ṽₙ). The modified band velocities are defined by\n\ntildenu_alpha = frac1hbar partial_k_alpha H -\n\fracihbar H(A_alpha + A_alpha^dagger)2\n\nwhere k_alpha is one of three input dimensions of H and hbar=1. Effectively, this type evaluates the Hamiltonian and its gradient modified by a commutator of the Hamiltonian with the gradient of the Berry connection. Note that differentiation by k changes the units to have an additional dimension of length and a factor of 2pi, so if H has dimensions of energy, nu has dimensions of energy times length. The caller is responsible for transforming the units of the velocity (i.e. hbar) if they want other units, which can usually be done as a post-processing step.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#Methods","page":"Fourier series","title":"Methods","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.contract(::AutoBZ.Applications.AbstractFourierSeries)","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.contract-Tuple{AutoBZ.Applications.AbstractFourierSeries}","page":"Fourier series","title":"AutoBZ.Applications.contract","text":"contract(f::FourierSeries{N}, x::Number, [dim=N]) where N\n\nContract index dim of the coefficients of f at the spatial point x. The default dim is the outermost dimension to preserve memory locality.\n\n\n\n\n\ncontract(f::FourierSeriesDerivative{N}, x::Number, [dim=N]) where {N}\n\nContract index dim of the coefficients of f at the spatial point x. The default dim is the outermost dimension to preserve memory locality.\n\n\n\n\n\n","category":"method"},{"location":"pages/app/fourier/#Optimized-3D-evaluators","page":"Fourier series","title":"Optimized 3D evaluators","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"For the use-case of Wannier90 calculations, the following Fourier series evaluators are optimized to improve performance by reducing allocations.","category":"page"},{"location":"pages/app/fourier/#Interface-2","page":"Fourier series","title":"Interface","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.AbstractFourierSeries3D\nAutoBZ.Applications.contract!","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.AbstractFourierSeries3D","page":"Fourier series","title":"AutoBZ.Applications.AbstractFourierSeries3D","text":"AbstractFourierSeries3D <: AbstractFourierSeries{3}\n\nAn abstract subtype of AbstractFourierSeries{3} representing in-place Fourier series evaluators\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.contract!","page":"Fourier series","title":"AutoBZ.Applications.contract!","text":"contract!(f::AbstractFourierSeries3D, x::Number, dim::Int)\n\nAn in-place version of contract.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/fourier/#Types-2","page":"Fourier series","title":"Types","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.FourierSeries3D\nAutoBZ.Applications.BandEnergyVelocity3D\nAutoBZ.Applications.BandEnergyBerryVelocity3D","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.FourierSeries3D","page":"Fourier series","title":"AutoBZ.Applications.FourierSeries3D","text":"FourierSeries3D(coeffs::Array{T,3}, [period=(1.0, 1.0, 1.0)])\n\nThis type is an AbstractFourierSeries{3} designed for in-place evaluation of FourierSeries, and unlike FourierSeries is specialized for 3D Fourier series and does not allocate a new array every time contract is called on it. This type stores the intermediate arrays used in a calculation and assumes that the size of coeffs on each axis is odd because it treats the zeroth harmonic as the center of the array (i.e. (size(coeffs) .÷ 2) .+ 1).\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.BandEnergyVelocity3D","page":"Fourier series","title":"AutoBZ.Applications.BandEnergyVelocity3D","text":"BandEnergyVelocity3D(coeffs, [period=(1.0,1.0,1.0)])\nBandEnergyVelocity3D(H::FourierSeries3D)\n\nThe in-place equivalent of BandEnergyVelocity for 3D series evaluation.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.BandEnergyBerryVelocity3D","page":"Fourier series","title":"AutoBZ.Applications.BandEnergyBerryVelocity3D","text":"BandEnergyBerryVelocity3D(H::FourierSeries3D{TH,0,0,0}, Ax::FourierSeries3D{TA,0,0,0}, Ay::FourierSeries3D{TA,0,0,0}, Az::FourierSeries3D{TA,0,0,0}) where {TH,TA}\n\nThe in-place equivalent of BandEnergyBerryVelocity for 3D series evaluation.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#Methods-2","page":"Fourier series","title":"Methods","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.contract!(::AutoBZ.Applications.AbstractFourierSeries3D)\nAutoBZ.Applications.fourier_kernel!","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.fourier_kernel!","page":"Fourier series","title":"AutoBZ.Applications.fourier_kernel!","text":"fourier_kernel!(r::Array{T,N-1}, C::Array{T,N}, x, ξ, [::Val{a}=Val{0}()]) where {T,N,a}\n\nContract the outermost index of array C and write it to the array r. Assumes the size of the outermost dimension of C is 2m+1 and sums the coefficients\n\nr_i_1dotsi_N-1 = sum_i_N=-m^m C_i_1dotsi_N-1i_N+m+1 (i2pixi i_N)^a exp(i2pixi x i_N)\n\nHence this represents evaluation of a Fourier series with m modes. The parameter a represents the order of derivative of the Fourier series.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#Integration-limits","page":"Integration limits","title":"Integration limits","text":"","category":"section"},{"location":"pages/man/integration_limits/#Interface","page":"Integration limits","title":"Interface","text":"","category":"section"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"IntegrationLimits\nlower\nupper\nbox\nsymmetries\nndims\nnsyms","category":"page"},{"location":"pages/man/integration_limits/#AutoBZ.IntegrationLimits","page":"Integration limits","title":"AutoBZ.IntegrationLimits","text":"IntegrationLimits{d}\n\nRepresents a set of integration limits over d variables. Realizations of this type should implement lower and upper, which return the lower and upper limits of integration along some dimension, rescale which represents the number of symmetries of the BZ which are used by the realization to reduce the BZ (the integrand over the limits gets multiplied by this factor), and a functor that accepts a single numeric argument and returns another realization of that type (in order to do nested integration). Thus the realization is also in control of the order of variables of integration and must coordinate this behavior with their integrand. Instances should also be static structs.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/integration_limits/#AutoBZ.lower","page":"Integration limits","title":"AutoBZ.lower","text":"lower(::IntegrationLimits)\n\nReturn the lower limit of the next variable of integration. If a vector is returned, then the integration routine may attempt to multidimensional integration.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.upper","page":"Integration limits","title":"AutoBZ.upper","text":"upper(::IntegrationLimits)\n\nReturn the upper limit of the next variable of integration. If a vector is returned, then the integration routine may attempt to multidimensional integration.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.box","page":"Integration limits","title":"AutoBZ.box","text":"box(::IntegrationLimits)\n\nReturn an iterator of tuples that for each dimension returns a tuple with the lower and upper limits of the integration domain without symmetries applied.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.symmetries","page":"Integration limits","title":"AutoBZ.symmetries","text":"symmetries(::IntegrationLimits)\n\nReturn an iterator over the symmetry transformations that the parametrization has used to reduce the volume of the integration domain.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#Base.ndims","page":"Integration limits","title":"Base.ndims","text":"ndims(::IntegrationLimits{d})\n\nReturns d. This is a type-based rule.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.nsyms","page":"Integration limits","title":"AutoBZ.nsyms","text":"nsyms(::IntegrationLimits)\n\nReturn the number of symmetries that the parametrization has used to reduce the volume of the integration domain.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"Additionally, all IntegrationLimits must extend Base.eltype to return the type which is the output of lower and upper, which is the type of coordinates in the domain.","category":"page"},{"location":"pages/man/integration_limits/#Types","page":"Integration limits","title":"Types","text":"","category":"section"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"CubicLimits\nCompositeLimits","category":"page"},{"location":"pages/man/integration_limits/#AutoBZ.CubicLimits","page":"Integration limits","title":"AutoBZ.CubicLimits","text":"CubicLimits(a, [b])\n\nStore integration limit information for a hypercube with vertices a and b. If b is not passed as an argument, then the lower limit defaults to zero(a).\n\n\n\n\n\n","category":"type"},{"location":"pages/man/integration_limits/#AutoBZ.CompositeLimits","page":"Integration limits","title":"AutoBZ.CompositeLimits","text":"CompositeLimits(lims::IntegrationLimits...)\nCompositeLimits(::Tuple{Vararg{IntegrationLimits}})\n\nConstruct a collection of limits which yields the first limit followed by the second, and so on.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/integration_limits/#Routines","page":"Integration limits","title":"Routines","text":"","category":"section"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"vol\nsymmetrize\nAutoBZ.discretize_equispace","category":"page"},{"location":"pages/man/integration_limits/#AutoBZ.vol","page":"Integration limits","title":"AutoBZ.vol","text":"vol(::IntegrationLimits)\n\nReturn the volume of the full domain without the symmetries applied\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.symmetrize","page":"Integration limits","title":"AutoBZ.symmetrize","text":"symmetrize(::IntegrationLimits, x)\nsymmetrize(::IntegrationLimits, xs...)\n\nTransform x by the symmetries of the parametrization used to reduce the domain, thus mapping the value of x on the parametrization to the full domain. When the integrand is a scalar, this is equal to nsyms(l)*x. When the integrand is a vector, this is sum(S*x for S in symmetries(l)). When the integrand is a matrix, this is sum(S*x*S' for S in symmetries(l)).\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.discretize_equispace","page":"Integration limits","title":"AutoBZ.discretize_equispace","text":"discretize_equispace(::IntegrationLimits, ::Integer)\n\nReturn an iterator of 2-tuples containing integration nodes and weights that correspond to an equispace integration grid with the symmetry transformations applied to it.\n\n\n\n\n\n","category":"function"},{"location":"#AutoBZ.jl-documentation","page":"Home","title":"AutoBZ.jl documentation","text":"","category":"section"}]
}
