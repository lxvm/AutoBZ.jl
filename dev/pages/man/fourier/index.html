<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fourier series · AutoBZ.jl</title><meta name="title" content="Fourier series · AutoBZ.jl"/><meta property="og:title" content="Fourier series · AutoBZ.jl"/><meta property="twitter:title" content="Fourier series · AutoBZ.jl"/><meta name="description" content="Documentation for AutoBZ.jl."/><meta property="og:description" content="Documentation for AutoBZ.jl."/><meta property="twitter:description" content="Documentation for AutoBZ.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">AutoBZ.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../workflow/">Getting started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../demo/dos/">Density of states</a></li><li><a class="tocitem" href="../../demo/density/">Electron density</a></li><li><a class="tocitem" href="../../demo/oc/">Optical conductivity</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Fourier series</a><ul class="internal"><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li></ul></li><li><a class="tocitem" href="../../app/self_energy/">Self energies</a></li><li><a class="tocitem" href="../../app/integrands/">Integrands</a></li><li><a class="tocitem" href="../../app/interfaces/">Interfaces</a></li><li><a class="tocitem" href="../internal/">Internal</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Fourier series</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fourier series</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lxvm/AutoBZ.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lxvm/AutoBZ.jl/blob/main/docs/src/pages/man/fourier.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Fourier-series"><a class="docs-heading-anchor" href="#Fourier-series">Fourier series</a><a id="Fourier-series-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-series" title="Permalink"></a></h1><p><a href="https://en.wikipedia.org/wiki/Fourier_series">Fourier series</a> represent functions as linear combinations of sinusoids whose frequencies are integer multiples of a fundamental mode. In <a href="https://en.wikipedia.org/wiki/Wannier_function">Wannier interpolation</a>, the periodicity of an operator, <span>$\hat{O}$</span>, in a crystal admits a Fourier series expansion of the <a href="https://en.wikipedia.org/wiki/Bloch%27s_theorem">Bloch operator</a> <span>$\hat{O}(\bm{k}) = e^{-i\bm{k}\cdot\hat{\bm{r}}} \hat{O} e^{i\bm{k}\cdot\hat{\bm{r}}}$</span> as linear combinations of sinusoids at integer multiples of the real-space lattice vectors, forming a <a href="https://en.wikipedia.org/wiki/Bravais_lattice">Bravais lattice</a>. When exponentially localized Wannier functions exist, it suffices to use a modest number of lattice vectors in this expansion. The goal of this page of documentation is to describe the features, interface, and conventions of Fourier series evaluation as implemented by this library.</p><h3 id="Lattice-vectors"><a class="docs-heading-anchor" href="#Lattice-vectors">Lattice vectors</a><a id="Lattice-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-vectors" title="Permalink"></a></h3><p>It is conventional to construct a basis for a reciprocal lattice <span>$\{\bm{b}_j\}$</span> from a basis for a real-space lattice <span>$\{\bm{a}_i\}$</span> such that </p><p class="math-container">\[\bm{b}_j \cdot \bm{a}_i = 2\pi\delta_{ij}\]</p><p>Then we write the momentum space variable in the reciprocal lattice vector basis</p><p class="math-container">\[\bm{k} = \sum_{j=1}^{d} k_j \bm{b}_j\]</p><p>Without loss of generality, the <span>$k_j$</span> can be taken in the domain <span>$[0,1]$</span>. Additionally, any real space lattice vector can be written as an integer linear combination of the <span>$\{\bm{a}_i\}$</span>. We lastly mention that when computing Brillouin zone integrals, we keep track of this change of basis with the Jacobian determinant of the transformation,</p><p class="math-container">\[\int_{\text{BZ}} d \bm{k} = |\det{B}| \int_{[0,1]^3} d^3 k.\]</p><p>Here, <span>$B$</span> is a matrix whose columns are the <span>$\{\bm{b}_j\}$</span>.</p><h3 id="Series-coefficients"><a class="docs-heading-anchor" href="#Series-coefficients">Series coefficients</a><a id="Series-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Series-coefficients" title="Permalink"></a></h3><p>Wannier-interpolated Hamiltonians are small matrices obtained by projecting the ab-initio Hamiltonian onto a subspace of bands with energies near the Fermi level, a process called downfolding. These Hamiltonians can be expressed by a Fourier series as in the sum below</p><p class="math-container">\[H(\bm{k}) = \sum_{\bm{R}} e^{i\bm{k}\cdot\bm{R}} H_{\bm{R}}\]</p><p>where the coefficients <span>$H_{\bm{R}}$</span> are the matrix-valued Fourier coefficients. Truncating the sum over <span>$\bm{R}$</span> at a modest number of modes can be done for Wannier Hamiltonians in the maximally-localized orbital basis, for which <span>$H(\bm{k})$</span> is a smooth and periodic function and thus the truncation error of its Fourier series converges super-algebraically with respect to the number of modes.</p><h3 id="Hamiltonian-recipe"><a class="docs-heading-anchor" href="#Hamiltonian-recipe">Hamiltonian recipe</a><a id="Hamiltonian-recipe-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian-recipe" title="Permalink"></a></h3><p>In model systems, a Bloch Hamiltonian can often be written down analytically. The recipe to write it as a Fourier series has two-steps</p><ol><li>Identify the real and reciprocal Bravais lattices, <span>$\{\bm{a}_i\}$</span> and <span>$\{\bm{b}_j\}$</span>, and rewrite all of the phase dependences of the Hamiltonian as <span>$\bm{k}\cdot\bm{R}$</span> with <span>$\bm{k}$</span> written in the basis of <span>$\{\bm{b}_j\}$</span> and the lattice vector <span>$\bm{R}$</span> written as an integer linear combination of <span>$\{\bm{a}_i\}$</span>.</li><li>Factor the Hamiltonian into a linear combination of normal modes indexed by the distinct <span>$\bm{R}$</span> vectors. If the Hamiltonian is matrix-valued, this can be done one matrix element at a time.</li></ol><p>For a non-trivial example, see the <a href="../../demo/dos/#DOS-interpolation-for-Graphene">DOS interpolation for Graphene</a>.</p><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><p>See <a href="https://github.com/lxvm/FourierSeriesEvaluators.jl">FourierSeriesEvaluators.jl</a> for the <code>AbstractFourierSeries</code> interface, which allows evaluation of the series with a function-like <code>f(x)</code> syntax. The <a href="../../app/interfaces/#Wannier90">Wannier90</a> interface will automatically construct these objects from the necessary output files.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>The concrete types listed below all implement the <code>AbstractFourierSeries</code> interface and should cover most use cases. They are organized by several abstract types to provide indicate physical properties of the Wannier-interpolated operator, such as a coordinate system or a gauge.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractWannierInterp" href="#AutoBZ.AbstractWannierInterp"><code>AutoBZ.AbstractWannierInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractWannierInterp{N,T,iip} &lt;: AbstractFourierSeries{N,T,iip}</code></pre><p>Abstract supertype for all Wannier-interpolated quantities in <code>AutoBZ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractGaugeInterp" href="#AutoBZ.AbstractGaugeInterp"><code>AutoBZ.AbstractGaugeInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGaugeInterp{G,N,T,iip} &lt;: AbstractWannierInterp{N,T,iip}</code></pre><p>An abstract subtype of <code>AbstractFourierSeries</code> representing Fourier series evaluators for Wannier-interpolated quantities with a choice of gauge, <code>G</code>, which is typically <a href="#AutoBZ.Hamiltonian"><code>Hamiltonian</code></a> or <a href="#AutoBZ.Wannier"><code>Wannier</code></a>. A gauge is a choice of basis for the function space of the operator. For details, see <a href="../internal/#AutoBZ.to_gauge"><code>to_gauge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L100-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractHamiltonianInterp" href="#AutoBZ.AbstractHamiltonianInterp"><code>AutoBZ.AbstractHamiltonianInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractHamiltonianInterp{G,N,T,iip} &lt;: AbstractGaugeInterp{G,N,T,iip}</code></pre><p>Abstract type representing Hamiltonians, which are matrix-valued Hermitian Fourier series. They should also have period 1, but produce derivatives with wavenumber 1 (not <span>$2\pi$</span>), in order to be consistent with definitions of the velocity operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L127-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.HamiltonianInterp" href="#AutoBZ.HamiltonianInterp"><code>AutoBZ.HamiltonianInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HamiltonianInterp(f::FourierSeries; gauge=:Wannier)</code></pre><p>A wrapper for <code>FourierSeries</code> with an additional gauge that allows for convenient diagonalization of the result. For details see <a href="../internal/#AutoBZ.to_gauge"><code>to_gauge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/interp.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.SOCHamiltonianInterp" href="#AutoBZ.SOCHamiltonianInterp"><code>AutoBZ.SOCHamiltonianInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SOCHamiltonianInterp(f::Freq2RadSeries, λ; gauge=Wannier())</code></pre><p>A wrapper for a Fourier series in a given gauge that has spin-orbit coupling represented by the matrix <code>λ</code>. In particular, this interpolates <code>[f(k) 0; 0 f(k)] + λ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/soc.jl#L143-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractCoordInterp" href="#AutoBZ.AbstractCoordInterp"><code>AutoBZ.AbstractCoordInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCoordInterp{B,G,N,T,iip} &lt;:AbstractGaugeInterp{G,N,T,iip}</code></pre><p>An abstract subtype of <code>AbstractGaugeInterp</code> also containing information about the coordinate basis <code>B</code>, which is either <a href="#AutoBZ.Lattice"><code>Lattice</code></a> or <a href="#AutoBZ.Cartesian"><code>Cartesian</code></a>. For details see <a href="../internal/#AutoBZ.to_coord"><code>to_coord</code></a> and <a href="../internal/#AutoBZ.CoordDefault"><code>CoordDefault</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L243-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.BerryConnectionInterp" href="#AutoBZ.BerryConnectionInterp"><code>AutoBZ.BerryConnectionInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BerryConnectionInterp{P}(a::ManyFourierSeries, B; coord)</code></pre><p>Interpolate the Berry connection in basis <code>coord</code>. <code>a</code> must evaluate the components of the connection in coordinate basis <code>P</code>, and <code>B</code> is the coordinate transformation from <code>P</code> to <code>coord</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/interp.jl#L67-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractVelocityInterp" href="#AutoBZ.AbstractVelocityInterp"><code>AutoBZ.AbstractVelocityInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVelocityInterp{C,B,G,N,T,iip} &lt;:AbstractCoordInterp{B,G,N,T,iip}</code></pre><p>An abstract subtype of <code>AbstractCoordInterp</code> also containing information the velocity component, <code>C</code>, which is typically <a href="#AutoBZ.Whole"><code>Whole</code></a>, <a href="#AutoBZ.Inter"><code>Inter</code></a>, or <a href="#AutoBZ.Intra"><code>Intra</code></a>. These choices refer to the diagonal (intra) or off-diagonal (inter) matrix elements of the velocity operator in the eigebasis of <code>H(k)</code>. For details see <a href="../internal/#AutoBZ.to_vcomp_gauge"><code>to_vcomp_gauge</code></a>. Since the velocity depends on the Hamiltonian, subtypes should evaluate <code>(H(k), (v_1(k), v_2(k), ...))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L369-L379">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.GradientVelocityInterp" href="#AutoBZ.GradientVelocityInterp"><code>AutoBZ.GradientVelocityInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GradientVelocityInterp(h::AbstractHamiltonianInterp, A; gauge, coord, vcomp)</code></pre><p>Evaluate the Hamiltonian and its gradient, which doesn&#39;t produce gauge-covariant velocities. The Hamiltonian <code>h</code> must be in the Wannier gauge, but this will give the result in the requested <code>gauge</code>. <code>A</code> must be the coordinate transformation from the lattice basis to the desired <code>coord</code> system. <code>vcomp</code> selects the contribution to the velocities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/interp.jl#L107-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.CovariantVelocityInterp" href="#AutoBZ.CovariantVelocityInterp"><code>AutoBZ.CovariantVelocityInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CovariantVelocityInterp(hv::GradientVelocityInterp, a::BerryConnectionInterp)</code></pre><p>Uses the Berry connection to return fully gauge-covariant velocities. Returns a tuple of the Hamiltonian and the three velocity matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/interp.jl#L163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.MassVelocityInterp" href="#AutoBZ.MassVelocityInterp"><code>AutoBZ.MassVelocityInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MassVelocityInterp(h::AbstractHamiltonianInterp, A; gauge, coord, vcomp)</code></pre><p>Compute the Hamiltonian, its gradient and Hessian, which are not gauge-covariant. See <a href="#AutoBZ.GradientVelocityInterp"><code>GradientVelocityInterp</code></a> for explanation of the arguments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/interp.jl#L230-L235">source</a></section></article><h3 id="Gauges"><a class="docs-heading-anchor" href="#Gauges">Gauges</a><a id="Gauges-1"></a><a class="docs-heading-anchor-permalink" href="#Gauges" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractGauge" href="#AutoBZ.AbstractGauge"><code>AutoBZ.AbstractGauge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGauge</code></pre><p>Abstract supertype of gauges (or bases) for orbital/band indices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.Wannier" href="#AutoBZ.Wannier"><code>AutoBZ.Wannier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Wannier &lt;: AbstractGauge</code></pre><p>Singleton type representing the Wannier gauge. In this gauge, the Fourier series representation of the operator is evaluated as-is, usually resulting in a dense matrix at each <span>$\bm{k}$</span> point. When evaluating a Green&#39;s function, choosing this gauge requires inverting a dense matrix, which scales as <span>$\mathcal{O}(N^3)$</span> where <span>$N$</span> is the number of orbitals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L57-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.Hamiltonian" href="#AutoBZ.Hamiltonian"><code>AutoBZ.Hamiltonian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Hamiltonian &lt;: AbstractGauge</code></pre><p>Singleton type representing the Hamiltonian gauge. This gauge is the eigenbasis of <code>H</code>, and all operators will be rotated to this basis. The Hamiltonian will also be returned as an <code>Eigen</code> factorization. In this basis, <code>H</code> is a diagonal matrix, so calculating a Green&#39;s function is an <span>$\mathcal{O}(N)$</span> operation where <span>$N$</span> is the number of bands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L68-L76">source</a></section></article><h3 id="Coordinate-systems"><a class="docs-heading-anchor" href="#Coordinate-systems">Coordinate systems</a><a id="Coordinate-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-systems" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractCoordinate" href="#AutoBZ.AbstractCoordinate"><code>AutoBZ.AbstractCoordinate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCoordinate</code></pre><p>Abstract supertype of bases for coordinate/spatial indices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L167-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.Cartesian" href="#AutoBZ.Cartesian"><code>AutoBZ.Cartesian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cartesian &lt;: AbstractCoordinate</code></pre><p>Singleton type representing Cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.Lattice" href="#AutoBZ.Lattice"><code>AutoBZ.Lattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Lattice &lt;: AbstractCoordinate</code></pre><p>Singleton type representing lattice coordinates. The matrix <span>$B$</span> whose columns are reciprocal lattice vectors converts this basis to the Cartesian basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L174-L179">source</a></section></article><h3 id="Velocity-components"><a class="docs-heading-anchor" href="#Velocity-components">Velocity components</a><a id="Velocity-components-1"></a><a class="docs-heading-anchor-permalink" href="#Velocity-components" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractVelocityComponent" href="#AutoBZ.AbstractVelocityComponent"><code>AutoBZ.AbstractVelocityComponent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVelocityComponent</code></pre><p>Abstract supertype representing velocity components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L280-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.Whole" href="#AutoBZ.Whole"><code>AutoBZ.Whole</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Whole &lt;: AbstractVelocityComponent</code></pre><p>Singleton type representing whole velocities, i.e. the total velocity operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L287-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.Intra" href="#AutoBZ.Intra"><code>AutoBZ.Intra</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Intra &lt;: AbstractVelocityComponent</code></pre><p>Singleton type representing intraband velocities, which are the off-diagonal terms of the velocity operator in the <a href="#AutoBZ.Hamiltonian"><code>Hamiltonian</code></a> gauge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L302-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.Inter" href="#AutoBZ.Inter"><code>AutoBZ.Inter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Inter &lt;: AbstractVelocityComponent</code></pre><p>Singleton type representing interband velocities, which are the diagonal terms of the velocity operator in the <a href="#AutoBZ.Hamiltonian"><code>Hamiltonian</code></a> gauge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/definitions.jl#L294-L299">source</a></section></article><h3 id="Special-matrix-types"><a class="docs-heading-anchor" href="#Special-matrix-types">Special matrix types</a><a id="Special-matrix-types-1"></a><a class="docs-heading-anchor-permalink" href="#Special-matrix-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.SOCMatrix" href="#AutoBZ.SOCMatrix"><code>AutoBZ.SOCMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SOCMatrix(A)</code></pre><p>Wrapper for a matrix A that should be used as a block-diagonal matrix     [A 0      0 A] as when dealing with spin-orbit coupling</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/soc.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.SSymmetricCompact" href="#AutoBZ.SSymmetricCompact"><code>AutoBZ.SSymmetricCompact</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SSymmetricCompact{N, T, L} &lt;: StaticMatrix{N, N, T}</code></pre><p>A <code>StaticArray</code> subtype that represents a Symmetric matrix. Unlike <code>LinearAlgebra.Symmetric</code>, <code>SSymmetricCompact</code> stores only the lower triangle of the matrix (as an <code>SVector</code>). The lower triangle is stored in column-major order. For example, for an <code>SSymmetricCompact{3}</code>, the indices of the stored elements can be visualized as follows:</p><pre><code class="nohighlight hljs">┌ 1 ⋅ ⋅ ┐
| 2 4 ⋅ |
└ 3 5 6 ┘</code></pre><p>Type parameters:</p><ul><li><code>N</code>: matrix dimension;</li><li><code>T</code>: element type for lower triangle;</li><li><code>L</code>: length of the <code>SVector</code> storing the lower triangular elements.</li></ul><p>Note that <code>L</code> is always the <code>N</code>th <a href="https://en.wikipedia.org/wiki/Triangular_number">triangular number</a>.</p><p>An <code>SSymmetricCompact</code> may be constructed either:</p><ul><li>from an <code>AbstractVector</code> containing the lower triangular elements; or</li><li>from a <code>Tuple</code> containing both upper and lower triangular elements in column major order; or</li><li>from another <code>StaticMatrix</code>.</li></ul><p>For the latter two cases, only the lower triangular elements are used; the upper triangular elements are ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/adb2868ed887a125182016bf793e5bbee65c266b/src/SSymmetricCompact.jl#L1-L31">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../demo/oc/">« Optical conductivity</a><a class="docs-footer-nextpage" href="../../app/self_energy/">Self energies »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Tuesday 18 June 2024 19:07">Tuesday 18 June 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
