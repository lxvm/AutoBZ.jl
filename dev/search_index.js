var documenterSearchIndex = {"docs":
[{"location":"pages/app/interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"pages/app/interfaces/#Wannier90","page":"Interfaces","title":"Wannier90","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"AutoBZ.Applications.parse_hamiltonian\nAutoBZ.Applications.load_hamiltonian","category":"page"},{"location":"pages/app/interfaces/#AutoBZ.Applications.parse_hamiltonian","page":"Interfaces","title":"AutoBZ.Applications.parse_hamiltonian","text":"parse_hamiltonian(filename)\n\nParse an ab-initio Hamiltonian output from Wannier90 into filename, extracting the fields (date_time, num_wann, nrpts, degen, irvec, C)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.Applications.load_hamiltonian","page":"Interfaces","title":"AutoBZ.Applications.load_hamiltonian","text":"load_hamiltonian(filename; period=1.0, compact=:N)\n\nLoad an ab-initio Hamiltonian output from Wannier90 into filename as an evaluatable FourierSeries whose periodicity can be set by the keyword argument period which defaults to setting the period along each dimension to 1.0. To define different periods for different dimensions, pass an SVector as the period. To store Hermitian Fourier coefficients in compact form, use the keyword compact to specify:\n\n:N: do not store the coefficients in compact form\n:L: store the lower triangle of the coefficients\n:U: store the upper triangle of the coefficients\n:S: store the lower triangle of the symmetrized coefficients, (c+c')/2\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#Python","page":"Interfaces","title":"Python","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Julia code, including AutoBZ.jl, can be called from Python using the package PyJulia","category":"page"},{"location":"pages/app/interfaces/#Setup","page":"Interfaces","title":"Setup","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"TL;DR","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"$ julia -e 'import Pkg; Pkg.add(\"PyCall\")'\n$ python3 -m pip install julia","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"If you want to, you can install PyJulia in a Python venv, but on the Julia side PyCall.jl must be installed in the default environment","category":"page"},{"location":"pages/app/interfaces/#Demo","page":"Interfaces","title":"Demo","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The Python snippet below shows how from the demos folder of the AutoBZ repository you can run one of the demo scripts:","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"from julia.api import Julia\njl = Julia(compiled_modules=False)\n\n# julia environment setup in working directory 'demos'\njl.eval(\"\"\"\nimport Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n\"\"\")\n\n# capture output of script\nout = jl.eval('include(\"DOS_test.jl\")')","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The first two lines are adapted for loading PyJulia on Debian systems.","category":"page"},{"location":"pages/app/integrands/#Integrands","page":"Integrands","title":"Integrands","text":"","category":"section"},{"location":"pages/app/integrands/#Generic","page":"Integrands","title":"Generic","text":"","category":"section"},{"location":"pages/app/integrands/#Types","page":"Integrands","title":"Types","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.WannierIntegrand","category":"page"},{"location":"pages/app/integrands/#AutoBZ.Applications.WannierIntegrand","page":"Integrands","title":"AutoBZ.Applications.WannierIntegrand","text":"WannierIntegrand(f, s::AbstractFourierSeries, p)\n\nA type generically representing an integrand f whose entire dependence on the variables of integration is in a Fourier series s, and which may also accept some input parameters p, which are preferrably contained in a tuple. The caller must be aware that their function, f, will be called at many evaluation points, x, in the following way: f(s(x), p...). Therefore the caller is expected to know the type of s(x) (hint: eltype(s)) and the layout of the parameters in the tuple p.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#Methods","page":"Integrands","title":"Methods","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.pre_eval_contract(::AutoBZ.Applications.WannierIntegrand,::Any,::Any)","category":"page"},{"location":"pages/app/integrands/#Pre-defined","page":"Integrands","title":"Pre-defined","text":"","category":"section"},{"location":"pages/app/integrands/#Types-2","page":"Integrands","title":"Types","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.DOSIntegrand\nAutoBZ.Applications.GammaIntegrand\nAutoBZ.Applications.OCIntegrand\nAutoBZ.Applications.EquispaceOCIntegrand\nAutoBZ.Applications.AutoEquispaceOCIntegrand","category":"page"},{"location":"pages/app/integrands/#AutoBZ.Applications.DOSIntegrand","page":"Integrands","title":"AutoBZ.Applications.DOSIntegrand","text":"DOSIntegrand(H, ω, Σ, μ)\nDOSIntegrand(H, ω, Σ)\nDOSIntegrand(H, M)\n\nA type whose integral gives the density of states.\n\nD(ω) = -pi^-1 int_textBZ dk operatornameTrIm((omega + mu) I - H(k) - Sigma(omega))^-1\n\nThis type works with both adaptive and equispace integration routines.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.GammaIntegrand","page":"Integrands","title":"AutoBZ.Applications.GammaIntegrand","text":"GammaIntegrand(H::FourierSeries, Σ, ω, Ω, μ, [kind=:full])\nGammaIntegrand(HV, Σ, ω, Ω, μ)\nGammaIntegrand(HV, Mω, MΩ)\n\nA type whose integral over the BZ gives the transport distribution.\n\nGamma_alphabeta(omega Omega) = int_textBZ dk operatornameTrnu_alpha(k) A(komega) nu_beta(k) A(k omega+Omega)\n\nThis type works with both adaptive and equispace integration routines. The keyword kind determines the band velocity component.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.OCIntegrand","page":"Integrands","title":"AutoBZ.Applications.OCIntegrand","text":"OCIntegrand(H::FourierSeries, Σ, Ω, β, μ, [kind=:full])\nOCIntegrand(HV, Σ, Ω, β, μ)\n\nA function whose integral over the BZ and the frequency axis gives the optical conductivity. Mathematically, this computes\n\nsigma_alphabeta(Omega) = int_-infty^infty d omega fracf(omega) - f(omega+Omega)Omega Gamma_alphabeta(omega omega+Omega)\n\nwhere f(omega) = (e^betaomega+1)^-1 is the Fermi distriubtion. Use this type only for adaptive integration and order the limits so that the integral over the Brillouin zone is the outer integral and the frequency integral is the inner integral. The keyword kind determines the band velocity component.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.EquispaceOCIntegrand","page":"Integrands","title":"AutoBZ.Applications.EquispaceOCIntegrand","text":"EquispaceOCIntegrand(σ::OCIntegrand, l, npt, pre::Vector{Tuple{NTuple{4, SMatrix{3, 3, ComplexF64, 9}},Int}})\nEquispaceOCIntegrand(σ, l, npt)\n\nThis type represents an OCIntegrand, σ integrated adaptively in frequency and with equispace integration over the Brillouin zone with a fixed number of grid points npt. The argument l should be an IntegrationLimits for just the Brillouin zone. This type should be called by an adaptive integration routine whose limits of integration are only the frequency variable.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.AutoEquispaceOCIntegrand","page":"Integrands","title":"AutoBZ.Applications.AutoEquispaceOCIntegrand","text":"AutoEquispaceOCIntegrand(σ, l, atol, rtol, npt1, pre1, npt2, pre2)\nAutoEquispaceOCIntegrand(σ, l, atol, rtol; npt1=0, pre1=Tuple{eltype(σ.HV),Int}[], npt2=0,pre2=Tuple{eltype(σ.HV),Int}[])\n\nThis type represents an OCIntegrand, σ integrated adaptively in frequency and with equispace integration over the Brillouin zone with a number of grid points necessary to meet the maximum of the tolerances given by atol and rtol. The argument l should be an IntegrationLimits for just the Brillouin zone. This type should be called by an adaptive integration routine whose limits of integration are only the frequency variable.\n\nThe keyword arguments, which are just passed to automatic_equispace_integration, are:\n\npre1: a Vector containing tuples of the evaluated Hamiltonian + band   velocities and integration weights\nnpt1: an integer that should be equivalent to length(pre1)\npre2: a Vector containing tuples of the evaluated Hamiltonian + band   velocities and integration weights on a more refined grid than pre1\nnpt2: an integer that should be equivalent to length(pre)\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#Functions","page":"Integrands","title":"Functions","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.dos_integrand\nAutoBZ.Applications.gamma_integrand\nAutoBZ.Applications.oc_integrand\nAutoBZ.Applications.fermi\nAutoBZ.Applications.fermi′\nAutoBZ.Applications.fermi_window\nAutoBZ.Applications.cosh_ratio\nAutoBZ.Applications.EXP_P1_SMALL_X","category":"page"},{"location":"pages/app/integrands/#AutoBZ.Applications.fermi_window","page":"Integrands","title":"AutoBZ.Applications.fermi_window","text":"Evaluates a unitless window function determined by the Fermi distribution\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#Equispace-integration","page":"Equispace integration","title":"Equispace integration","text":"","category":"section"},{"location":"pages/man/equispace_integration/#Routines","page":"Equispace integration","title":"Routines","text":"","category":"section"},{"location":"pages/man/equispace_integration/","page":"Equispace integration","title":"Equispace integration","text":"equispace_integration\nautomatic_equispace_integration","category":"page"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_integration","page":"Equispace integration","title":"AutoBZ.equispace_integration","text":"equispace_integration(f, l, npt; pre=nothing, equispace_pre_eval=generic_equispace_pre_eval, equispace_int_eval=generic_equispace_int_eval)\n\nEvaluate the integral of f over domain l using an equispace grid of npt points per dimension, optionally using precomputation pre\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.automatic_equispace_integration","page":"Equispace integration","title":"AutoBZ.automatic_equispace_integration","text":"automatic_equispace_integration(f, a, b; kwargs)\nautomatic_equispace_integration(f, l::IntegrationLimits; npt1=0, pre1=0, npt2=0, pre2=0, atol=0.0, rtol=1e-3 maxevals=typemax(Int64))\n\nAutomatically evaluates the integral of f over domain l to within the requested error tolerances atol and rtol. Allows optional precomputed data at two levels of grid refinement npt1, pre1 and npt2, pre2.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#Customization","page":"Equispace integration","title":"Customization","text":"","category":"section"},{"location":"pages/man/equispace_integration/","page":"Equispace integration","title":"Equispace integration","text":"The methods below can be extended/customized to integrand types","category":"page"},{"location":"pages/man/equispace_integration/","page":"Equispace integration","title":"Equispace integration","text":"equispace_npt_update\nequispace_pre_eval\nequispace_int_eval\nevaluate_integrand","category":"page"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_npt_update","page":"Equispace integration","title":"AutoBZ.equispace_npt_update","text":"equispace_npt_update(npt, f, atol, rtol)\n\nReturns a new npt to try and get another digit of accuracy from PTR. This fallback option is a heuristic, since the scaling of the error is generally problem-dependent.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_pre_eval","page":"Equispace integration","title":"AutoBZ.equispace_pre_eval","text":"equispace_pre_eval(f::WannierIntegrand, l::IntegrationLimits, npt)\n\nThis function will evaluate the Fourier series and integration weights needed for equispace integration of f at npt points per dimension. l should contain the relevant symmetries needed for IBZ integration, if desired.\n\n\n\n\n\nequispace_pre_eval(f, l, npt)\n\nPrecomputes the grid points and weights to use for equispace quadrature of f on the domain l while applying the relevant symmetries to l to reduce the number of evaluation points. Should return a vector of tuples with the integration weight in the first position and the precomputation in the second. This output is passed to the argument pre of equispace_int_eval.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_int_eval","page":"Equispace integration","title":"AutoBZ.equispace_int_eval","text":"equispace_int_eval(f, pre, dvol)\n\nSums the values of f on the precomputed grid points with corresponding quadrature weights and also multiplies by the mesh cell volume to obtain the integral on the precomputed domain represented by pre, obtained from equispace_pre_eval. Evaluation of f is done by the function evaluate_integrand in order to create a function boundary between the quadrature and the integrand evaluation.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.evaluate_integrand","page":"Equispace integration","title":"AutoBZ.evaluate_integrand","text":"evaluate_integrand(f, x)\n\nBy default, this calls f(x), however the caller may dispatch on the type of f if they would like to specialize this function together with equispace_pre_eval so that x is a more useful precomputation (e.g. a Fourier series evaluated at a grid point).\n\n\n\n\n\n","category":"function"},{"location":"pages/app/fourier/#Fourier-series","page":"Fourier series","title":"Fourier series","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Wannier-interpolated Hamiltonians are represented by Fourier series with a modest number of Fourier coefficients. The goal of this page of documentation is to describe the features, interface, and conventions of Fourier series evaluation as implemented by this library.","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"note: Representing Hamiltonians with Fourier series\nFourier series represent functions with sinusoids whose frequencies are integer multiples of a fundamental. In the band theory of solids, the fundamental frequencies for a Hamiltonian correspond to the real-space lattice vectors that generate a Bravais lattice, and so it is best to represent the momentum variable veck in the basis of the reciprocal lattice. Since it is conventional to construct a reciprocal lattice vecb_j from a Bravais lattice veca_i such that vecb_j cdot veca_i = 2pidelta_ij, the Fourier series in this library are defined with a phase factor scaled by 2pi. Additionally, any coordinate transformations of veck from the Cartesian basis to the reciprocal lattice basis only modify Brillouin zone integrals by a multiplicative factor of the absolute value of the determinant of the basis transformation. To find a non-trivial example of representing a Hamiltonian in the reciprocal lattice basis, see the Graphene example with ManyOffsetsFourierSeries.","category":"page"},{"location":"pages/app/fourier/#Interface","page":"Fourier series","title":"Interface","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.AbstractFourierSeries\nAutoBZ.Applications.period\nAutoBZ.Applications.contract\nAutoBZ.Applications.value","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.AbstractFourierSeries","page":"Fourier series","title":"AutoBZ.Applications.AbstractFourierSeries","text":"AbstractFourierSeries{N}\n\nA supertype for Fourier series that are periodic maps R^N to V where V is any vector space. Typically these can be represented by N-dimensional arrays whose elements belong to the vector space. See the manual section on the AbstractFourierSeries interface.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.period","page":"Fourier series","title":"AutoBZ.Applications.period","text":"period(f::AbstractFourierSeries{N}) where {N}\n\nReturn a NTuple{N} whose m-th element corresponds to the period of f along its m-th input dimension. Typically, these values set the units of length for the problem.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/fourier/#AutoBZ.Applications.contract","page":"Fourier series","title":"AutoBZ.Applications.contract","text":"contract(f::AbstractFourierSeries{N}, x::Number, [dim=N]) where {N}\n\nReturn another Fourier series of dimension N-1 by summing over dimension dim of f with the phase factors evaluated at x. If N=1, this function should return an AbstractFourierSeries{0} that stores the evaluated Fourier series, but has no more input dimensions to contract.\n\nThe default of dim=N is motivated by preserving memory locality in Julia's column-major array format.\n\ncontract(f::AbstractFourierSeries{N}, x::SVector{M}) where {N,M}\n\nContract the outermost indices M of f in order of last(x) to first(x). If M>N, the default behavior is just to try and contract M indices, which will likely lead to an error.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/fourier/#AutoBZ.Applications.value","page":"Fourier series","title":"AutoBZ.Applications.value","text":"value(::AbstractFourierSeries{0})\n\nReturn the evaluated Fourier series whose indices have all been contracted. Typically, this value has the same units as the Fourier series coefficients.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Additonally, concrete subtypes of AbstractFourierSeries must have an element type, which they can do by extending Base.eltype with a method. For example, if a type MyFourierSeries <: AbstractFourierSeries always returns ComplexF64 outputs, then the correct eltype method to define would be:","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Base.eltype(::Type{MyFourierSeries}) = ComplexF64","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"The type returned should correspond to the vector space V of the output space of the Fourier series, i.e. the output of value should be of this type. For good performance, the eltype should be a concrete type and should be inferrable.","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"With the above implemented, several methods which define functors for AbstractFourierSeries allow the user (and integration routines) to evaluate the type like a function with the f(x) syntax.","category":"page"},{"location":"pages/app/fourier/#Types","page":"Fourier series","title":"Types","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"The concrete types listed below all implement the AbstractFourierSeries interface and should cover most use cases.","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.FourierSeries\nAutoBZ.Applications.FourierSeriesDerivative\nAutoBZ.Applications.OffsetFourierSeries\nAutoBZ.Applications.ManyFourierSeries\nAutoBZ.Applications.ManyOffsetsFourierSeries\nAutoBZ.Applications.BandEnergyVelocity","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.FourierSeries","page":"Fourier series","title":"AutoBZ.Applications.FourierSeries","text":"FourierSeries(coeffs, period::SVector{N,Float64}) where {N}\n\nConstruct a Fourier series whose coefficients are given by the coefficient array array coeffs whose eltype should support addition and scalar multiplication, and whose periodicity on the ith axis is given by period[i]. This type represents the Fourier series\n\nf(vecx) = sum_vecn in mathcal I C_vecn exp(i2piveck_vecncdotoverrightarrowx)\n\nwhere i = sqrt-1 is the imaginary unit, C is the array coeffs, mathcal I is CartesianIndices(C), vecn is a CartesianIndex and veck_vecn is equal to n_jp_j in the jth position with p_j the jth element of period. Because of the choice to use Cartesian indices to set the phase factors, typically the indices of coeffs should be specified by using an OffsetArray.\n\nFourierSeries(coeffs::AbstractArray{T,N}, period::Real) where {T,N}\n\nIf period is a Real, this constructor will infer the number of input dimensions of the Fourier series from the array dimensionality of the coefficients, and period will become the period of all of the dimensions.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.FourierSeriesDerivative","page":"Fourier series","title":"AutoBZ.Applications.FourierSeriesDerivative","text":"FourierSeriesDerivative(f::FourierSeries{N}, a::SVector{N}) where {N}\n\nRepresent the differential of Fourier series f by a multi-index a of derivatives, e.g. [1,2,...], whose ith entry represents the order of differentiation on the ith input dimension of f. Mathematically, this means\n\nleft( prod_j=1^N partial_x_j^a_j right) f(vecx) = sum_vecn in mathcal I left( prod_j=1^N (i 2pi k_j)^a_j right) C_vecn exp(i2piveck_vecncdotoverrightarrowx)\n\nwhere partial_x_j^a_j represents the a_jth derivative of x_j, i = sqrt-1 is the imaginary unit, C is the array coeffs, mathcal I is CartesianIndices(C), vecn is a CartesianIndex and veck_vecn is equal to n_jp_j in the jth position with p_j the jth element of period. Because of the choice to use Cartesian indices to set the phase factors, typically the indices of coeffs should be specified by using an OffsetArray. Also, note that termwise differentiation of the Fourier series results in additional factors of i2pi which should be anticipated for the use case. Also, note that this type can be used to represent fractional differentiation or integration by suitably choosing the a_js.\n\nThis is a 'lazy' representation of the derivative because instead of differentiating by computing all of the Fourier coefficients of the derivative upon constructing the object, the evaluator waits until it contracts the differentiated dimension to evaluate the new coefficients.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.OffsetFourierSeries","page":"Fourier series","title":"AutoBZ.Applications.OffsetFourierSeries","text":"OffsetFourierSeries(f::AbstractFourierSeries{N}, q::SVector{N,Float64}) where {N}\n\nRepresent a Fourier series whose argument is offset by the vector vecq and evaluates it as f(vecx-vecq).\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.ManyFourierSeries","page":"Fourier series","title":"AutoBZ.Applications.ManyFourierSeries","text":"ManyFourierSeries(fs::AbstractFourierSeries{N}...) where {N}\n\nRepresents a tuple of Fourier series of the same dimension and periodicity and contracts them all simultaneously.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.ManyOffsetsFourierSeries","page":"Fourier series","title":"AutoBZ.Applications.ManyOffsetsFourierSeries","text":"ManyOffsetsFourierSeries(f, qs..., [origin=true])\n\nRepresent a Fourier series evaluated at many different points, and contract them all simultaneously, returning them in the order the qs were passed, i.e. (f(x-qs[1]), f(x-qs[2]), ...) The origin keyword decides whether or not to evaluate f without an offset, and if origin is true, the value of f evaluated without an offset will be returned in the first position of the output.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.BandEnergyVelocity","page":"Fourier series","title":"AutoBZ.Applications.BandEnergyVelocity","text":"BandEnergyVelocity(H::FourierSeries{N}, V::ManyFourierSeries{N}, kind::Symbol) where N\nBandEnergyVelocity(H::FourierSeries{N}, [kind=:full]) where N\n\nThe bottom constructor takes a Fourier series representing the Hamiltonian and also evaluates the band velocities so that the return value after all the dimensions are contracted is a tuple containing (H, v₁, v₂, ..., vₙ). The band velocities are defined by dipole operators nu_alpha = frac1hbar partial_k_alpha H where k_alpha is one of three input dimensions of H and hbar=1. Effectively, this type evaluates H and its gradient. Note that differentiation by k changes the units to have an additional dimension of length and a factor of 2pi, so if H has dimensions of energy, nu has dimensions of energy times length. The caller is responsible for transforming the units of the velocity (i.e. hbar) if they want other units, which can usually be done as a post-processing step. The keyword kind allows the following options:\n\n:full: return the full band velocity\n:intra: return only the diagonal of the band velocity\n:inter: return only the off-diagonal terms of the band velocity\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#Methods","page":"Fourier series","title":"Methods","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.contract(::AutoBZ.Applications.AbstractFourierSeries)\nAutoBZ.Applications.band_velocities","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.contract-Tuple{AutoBZ.Applications.AbstractFourierSeries}","page":"Fourier series","title":"AutoBZ.Applications.contract","text":"contract(f::FourierSeries{N}, x::Number, [dim=N]) where N\n\nContract index dim of the coefficients of f at the spatial point x. The default dim is the outermost dimension to preserve memory locality.\n\n\n\n\n\ncontract(f::FourierSeriesDerivative{N}, x::Number, [dim=N]) where {N}\n\nContract index dim of the coefficients of f at the spatial point x. The default dim is the outermost dimension to preserve memory locality.\n\n\n\n\n\n","category":"method"},{"location":"pages/app/fourier/#AutoBZ.Applications.band_velocities","page":"Fourier series","title":"AutoBZ.Applications.band_velocities","text":"band_velocities(kind, vs)\n\nTransform the band velocities according to the following values of kind\n\n:full: return the full band velocity\n:intra: return only the diagonal of the band velocity\n:inter: return only the off-diagonal terms of the band velocity\n\nvs should be an iterable collection of matrices\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#Adaptive-integration","page":"Adaptive integration","title":"Adaptive integration","text":"","category":"section"},{"location":"pages/man/adaptive_integration/#Routines","page":"Adaptive integration","title":"Routines","text":"","category":"section"},{"location":"pages/man/adaptive_integration/","page":"Adaptive integration","title":"Adaptive integration","text":"tree_integration\niterated_integration\nAutoBZ.alloc_segbufs\nAutoBZ.thunk\nAutoBZ.ThunkIntegrand","category":"page"},{"location":"pages/man/adaptive_integration/#AutoBZ.tree_integration","page":"Adaptive integration","title":"AutoBZ.tree_integration","text":"tree_integration(f, a, b)\ntree_integration(f, ::CubicLimits)\n\nCalls HCubature to perform multi-dimensional integration of f over a cube.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.iterated_integration","page":"Adaptive integration","title":"AutoBZ.iterated_integration","text":"iterated_integration(f, ::IntegrationLimits; order=4, atol=nothing, rtol=nothing, norm=norm, maxevals=typemax(Int), segbufs=nothing)\niterated_integration(f, a, b; kwargs...)\n\nCalls QuadGK to perform iterated 1D integration of f over a domain parametrized by IntegrationLimits. In the case two points a and b are passed, the integration region becomes the hypercube with those extremal vertices.\n\nReturns a tuple (I, E) of the estimated integral and estimated error.\n\nKeyword options include a relative error tolerance rtol (if atol==0, defaults to sqrt(eps) in the precision of the norm of the return type), an absolute error tolerance atol (defaults to 0), a maximum number of function evaluations maxevals for each nested integral (defaults to 10^7), and the order of the integration rule (defaults to 4).\n\nThe algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (2*order+1 points) and the error is estimated using an embedded Gauss rule (order points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved. This 1D procedure is applied recursively to each variable of integration in an order determined by l to obtain the multi-dimensional integral.\n\nUnlike quadgk, this routine does not allow infinite limits of integration nor unions of intervals to avoid singular points of the integrand.\n\nIn normal usage, iterated_integration will allocate segment buffers. You can instead pass a preallocated buffer allocated using alloc_segbufs as the segbuf argument. This buffer can be used across multiple calls to avoid repeated allocation.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.alloc_segbufs","page":"Adaptive integration","title":"AutoBZ.alloc_segbufs","text":"alloc_segbufs(eltype_l, typeof_fx, typeof_nfx, ndims_l)\n\nThis helper function will allocate enough segment buffers as are needed for an iterated_integration call of integrand f and integration limits l. eltype_l should be eltype(l), typeof_fx should be the return type of the integrand f, typeof_nfx should be the type of the norm of a value of f, and ndims_l should be ndims(l).\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.thunk","page":"Adaptive integration","title":"AutoBZ.thunk","text":"thunk(f, x)\n\nDelay the computation of f(x). Needed to normally evaluate an integrand in nested integrals, a setting in which the values of the variables of integration are passed one at a time. Importantly, thunk assumes that the variables of integration are passed from the outermost to the innermost. For example, to evaluate f([1, 2]), call thunk(f, 2)(1).\n\nThis behavior is consistent with CubicLimits, but may come as a surprise if implementing new IntegrationLimits.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.ThunkIntegrand","page":"Adaptive integration","title":"AutoBZ.ThunkIntegrand","text":"ThunkIntegrand(f, x)\n\nStore f and x to evaluate f(x) at a later time. Employed by iterated_integration for generic integrands that haven't been specialized to use iterated_pre_eval.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/adaptive_integration/#Customization","page":"Adaptive integration","title":"Customization","text":"","category":"section"},{"location":"pages/man/adaptive_integration/","page":"Adaptive integration","title":"Adaptive integration","text":"The methods below can be extended/customized to integrand types","category":"page"},{"location":"pages/man/adaptive_integration/","page":"Adaptive integration","title":"Adaptive integration","text":"iterated_tol_update\niterated_pre_eval\nAutoBZ.infer_f","category":"page"},{"location":"pages/man/adaptive_integration/#AutoBZ.iterated_tol_update","page":"Adaptive integration","title":"AutoBZ.iterated_tol_update","text":"iterated_tol_update(f, l, atol, rtol)\n\nChoose a new set of error tolerances for the next inner integral. By default returns (atol, rtol) unchanged.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.iterated_pre_eval","page":"Adaptive integration","title":"AutoBZ.iterated_pre_eval","text":"iterated_pre_eval(f, x)\n\nPerform a precomputation on f using the value of a variable of integration, x. The default is to store x and delay the computation of f(x) until all of the values of the variables of integration are determined at a integration point. Certain types of functions, such as Fourier series, take can use x to precompute a new integrand for the remaining variables of integration that is more computationally efficient.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.infer_f","page":"Adaptive integration","title":"AutoBZ.infer_f","text":"infer_f(f, Tx)\n\nEvaluates f(zero(Tx)) and norm(f(zero(Tx))) and returns their types. If the type of the range of f is known apriori, this method is meant to be specialized. Implicitly this assumes that f is type-stable.\n\n\n\n\n\n","category":"function"},{"location":"pages/demo/#Demos","page":"Demos","title":"Demos","text":"","category":"section"},{"location":"pages/demo/#DOS-of-the-integer-lattice-tight-binding-model","page":"Demos","title":"DOS of the integer lattice tight-binding model","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"To demonstrate setting up a DOS calculation with AutoBZ, we consider a tight-binding model on the n-dimensional integer lattice with lattice constant a and hopping strength t0:","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"H = -t sum_i in Z^n sum_j=1^n ketibrai+hatj + keti+hatjbrai","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Solving this model by employing Bloch's theorem yields the following band","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"H(k_1 ldots k_n) = -t(cos(k_1 a) + cdots + cos(k_n a))","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"We shall input this Hamiltonian by constructing the equivalent Fourier series","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using StaticArrays\nusing OffsetArrays\n\nusing AutoBZ\nusing AutoBZ.Applications\n\nn = 3 # arbitrary positive integer\na = fill(1.0, SVector{n})\nax = repeat([-1:1], n)\nC = zeros(SMatrix{1,1,ComplexF64,1}, ntuple(_ -> 3, n))\nfor i in 1:n, j in (-1, 1)\n    C[CartesianIndex(ntuple(k -> k == i ? 2+j : 2, n))] = SMatrix{1,1,ComplexF64,1}(0.5)\nend\nH = FourierSeries(OffsetArray(C, ax...), a)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Then we can define the integration problem to compute DOS, defined by the integral","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"operatornameDOS(omega) = int_textBZ dveck operatornameTrImomega+mu-H(veck)+ieta","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where mu is the chemical potential and eta is a constant scattering rate.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"ω = 1.0*n # frequency\nη = 0.1 # broadening\nμ = 0.0 # chemical potential\nΣ = EtaEnergy(η) # self energy\nD = DOSIntegrand(H, ω, Σ, μ) # integrand\n\n# construct IBZ integration limits\nc = CubicLimits(H.period)\nt = TetrahedralLimits(c)\n\n# set error tolerances\natol = 1e-3\nrtol = 0.0\n\niterated_integration(D, t; callback=contract, atol=atol, rtol=rtol)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"You will find a working example of this model in the DOS_example.jl demo that computes DOS over a range of frequencies for this model.","category":"page"},{"location":"pages/demo/#Custom-integrands","page":"Demos","title":"Custom integrands","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"For integrands that can be evaluated by Wannier interpolation, the following data are necessary to define an integrand:","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"the integrand evaluator\na Fourier series\nadditional parameters for the evaluator","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Consider implementing custom integrands using the generic template type AutoBZ.Applications.WannierIntegrand that is compatible with all of the adaptive and equispace integration routines. For example, we can replicate the preceding tight-binding example by defining a custom integrand","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using LinearAlgebra\ndos(H_k::AbstractMatrix, ω, μ, η) = -tr(imag(inv(complex(ω+μ, η)*I-H_k)))/pi\nD = WannierIntegrand(dos, H, (ω, μ, η))","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"tip: Optimizing equispace integration\nUnlike for adaptive integration, the caller is responsible for passing pre-computed grid values to the equispace integration routines, which is explained in the documentation for Equispace integration and AutoBZ.Applications.pre_eval_contract.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"warning: Mixing adaptive and equispace integrals\nWhile it is possible to perform an integral where some variables are integrated adaptively and others are integrated uniformly, this guide will not explain how to do this. However, an example implementation of this is  AutoBZ.Applications.AutoEquispaceOCIntegrand.","category":"page"},{"location":"pages/demo/#Graphene-example-with-ManyOffsetsFourierSeries","page":"Demos","title":"Graphene example with ManyOffsetsFourierSeries","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Let's study an example motivated by graphene whose Hamiltonian is given by a tight-binding model on the hexagonal lattice with lattice constant a and hopping amplitude t. Applying Bloch's theorem to each triangular sublattice brings the Hamiltonian into block-diagonal form, where each block is of the form","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"-t\nbeginpmatrix\n0  f(k)\n f^*(k)  0\nendpmatrix","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where f(k) = e^ikcdotdelta_1 + e^ikcdotdelta_2 + e^ikcdotdelta_3 and delta_1 = ahatx delta_2 = a(-12hatx+sqrt32haty) delta_3 = a(-12hatx-sqrt32haty). To exactly construct this Fourier series, we will have to rotate basis so that these vectors are precisely integer linear combinations of the new lattice vectors. Note that by defining hata_1 = (delta_1 - delta_3)3a = (hatx + 1sqrt3haty)2 hata_2 = (delta_1 - delta_2)3a = (hatx - 1sqrt3haty)2 we can write delta_1 = a(hata_1 + hata_2) delta_2 = a(hata_1 - 2hata_2) delta_3 = a(-2hata_1 + hata_2). Therefore our coordinate transformation matrix, T from Cartesian coordinates to the triangular lattice, veca_i = 3ahata_i, is","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"T = frac12\nbeginpmatrix\n1  1sqrt3\n 1  -1sqrt3\nendpmatrix\nqquad\nT^-1 =\nbeginpmatrix\n1  1\n sqrt3  -sqrt3\nendpmatrix","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"and note operatornamedet(T) = 12sqrt3. Now the corresponding reciprocal lattice vectors are constructed by the relation hatb_i = epsilon_ij (hatz times hata_j) and rescaling so that hatb_i cdot hata_j = 2pidelta_ij. This yields hatb_1 = 2pi(hatx+sqrt3haty) = 4pi(hata_1 - 2hata_2) hatb_2 = 2pi(hatx-sqrt3haty) = 4pi(2hata_1 - hata_2). We would now interpret k in this basis, and could also use T to map from the Cartesian basis to it. Also observe that if a is the lattice constant of the hexagonal lattice, then sqrt3a is the lattice constant of the triangular lattice, and 2pisqrt3a is the lattice constant of the reciprocal lattice. However, we will have to rescale integrals by factors of operatornamedetT because of our coordinate transformations.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Having chosen this suitable basis for k and x, we can now express the k-dependence of the block Hamiltonian as","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"f(k) = e^ikcdotdelta_1 + e^ikcdotdelta_2 + e^ikcdotdelta_3\n= e^iakcdot(hata_1 + hata_2) + e^iakcdot(hata_1 - 2hata_2) + e^iakcdot(-2hata_1 + hata_2)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"which is amenable to a Fourier series representation.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Suppose that the integral we want to calculate is","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"g(vecq) = int_textBZ dk_x dk_y fraclambda(xi(veck)) - lambda(xi(veck-vecq))xi(veck) - xi(veck-vecq)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where xi(veck) = operatornamedet(H(veck)) and lambda(omega) = partial_T f(omega) is the temperature derivative of the Fermi distribution. Since the integrand requires evaluation of the Hamiltonian at various k-points simultaneously, the AutoBZ.Applications.ManyOffsetsFourierSeries type can be used to do this. Moreover, AutoBZ.Applications has functions to evaluate Fermi functions and their derivatives. Putting everything together leads us to the code example below","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using StaticArrays\nusing OffsetArrays\n\nusing AutoBZ\nusing AutoBZ.Applications\n\na = 1.0\nC = OffsetArray(zeros(SMatrix{2,2,ComplexF64,4}, (5,5)), -2:2, -2:2)\nC[1,1]   = C[1,-2] = C[-2,1] = [0 1; 0 0]\nC[-1,-1] = C[-1,2] = C[2,-1] = [0 0; 1 0]\nH = FourierSeries(C, 2*pi/a)\n\nT = 100.0 # K\nkB = 8.617333262e-5 # eV/K\nq = rand(SVector{2,Float64}) # arbitrary\nf = ManyOffsetsFourierSeries(H, q)\n\nlambda(x, T, kB) = -AutoBZ.Applications.fermi′(inv(kB*T), x)/(kB*T^2)\nintegrand_(f, T, kB) = (lambda(det(f[1]), T, kB) - lambda(det(f[2]), T, kB))/(det(f[1])-det(f[2]))\nintegrand = WannierIntegrand(integrand_, f, (T, kB))\n\nc = CubicLimits(H.period)\n\n# set error tolerances\natol = 1e-3\nrtol = 0.0\n\niterated_integration(integrand, c; callback=contract, atol=atol, rtol=rtol)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"You will find a working example of this code in the graphene.jl demo that calculates this integral for values of vecq in the Brillouin zone.","category":"page"},{"location":"pages/man/integration_limits/#Integration-limits","page":"Integration limits","title":"Integration limits","text":"","category":"section"},{"location":"pages/man/integration_limits/#Interface","page":"Integration limits","title":"Interface","text":"","category":"section"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"IntegrationLimits\nlower\nupper\nbox\nsymmetries\nndims\nnsyms","category":"page"},{"location":"pages/man/integration_limits/#AutoBZ.IntegrationLimits","page":"Integration limits","title":"AutoBZ.IntegrationLimits","text":"IntegrationLimits{d}\n\nRepresents a set of integration limits over d variables. Realizations of this type should implement lower and upper, which return the lower and upper limits of integration along some dimension, rescale which represents the number of symmetries of the BZ which are used by the realization to reduce the BZ (the integrand over the limits gets multiplied by this factor), and a functor that accepts a single numeric argument and returns another realization of that type (in order to do nested integration). Thus the realization is also in control of the order of variables of integration and must coordinate this behavior with their integrand. Instances should also be static structs.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/integration_limits/#AutoBZ.lower","page":"Integration limits","title":"AutoBZ.lower","text":"lower(::IntegrationLimits)\n\nReturn the lower limit of the next variable of integration. If a vector is returned, then the integration routine may attempt to multidimensional integration.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.upper","page":"Integration limits","title":"AutoBZ.upper","text":"upper(::IntegrationLimits)\n\nReturn the upper limit of the next variable of integration. If a vector is returned, then the integration routine may attempt to multidimensional integration.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.box","page":"Integration limits","title":"AutoBZ.box","text":"box(::IntegrationLimits)\n\nReturn an iterator of tuples that for each dimension returns a tuple with the lower and upper limits of the integration domain without symmetries applied.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.symmetries","page":"Integration limits","title":"AutoBZ.symmetries","text":"symmetries(::IntegrationLimits)\n\nReturn an iterator over the symmetry transformations that the parametrization has used to reduce the volume of the integration domain.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#Base.ndims","page":"Integration limits","title":"Base.ndims","text":"ndims(::IntegrationLimits{d})\n\nReturns d. This is a type-based rule.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.nsyms","page":"Integration limits","title":"AutoBZ.nsyms","text":"nsyms(::IntegrationLimits)\n\nReturn the number of symmetries that the parametrization has used to reduce the volume of the integration domain.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"Additionally, all IntegrationLimits must extend Base.eltype to return the type which is the output of lower and upper, which is the type of coordinates in the domain.","category":"page"},{"location":"pages/man/integration_limits/#Types","page":"Integration limits","title":"Types","text":"","category":"section"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"CubicLimits\nCompositeLimits","category":"page"},{"location":"pages/man/integration_limits/#AutoBZ.CubicLimits","page":"Integration limits","title":"AutoBZ.CubicLimits","text":"CubicLimits(a, [b])\n\nStore integration limit information for a hypercube with vertices a and b. If b is not passed as an argument, then the lower limit defaults to zero(a).\n\n\n\n\n\n","category":"type"},{"location":"pages/man/integration_limits/#AutoBZ.CompositeLimits","page":"Integration limits","title":"AutoBZ.CompositeLimits","text":"CompositeLimits(lims::IntegrationLimits...)\nCompositeLimits(::Tuple{Vararg{IntegrationLimits}})\n\nConstruct a collection of limits which yields the first limit followed by the second, and so on.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/integration_limits/#Routines","page":"Integration limits","title":"Routines","text":"","category":"section"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"vol\nsymmetrize\nAutoBZ.discretize_equispace","category":"page"},{"location":"pages/man/integration_limits/#AutoBZ.vol","page":"Integration limits","title":"AutoBZ.vol","text":"vol(::IntegrationLimits)\n\nReturn the volume of the full domain without the symmetries applied\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.symmetrize","page":"Integration limits","title":"AutoBZ.symmetrize","text":"symmetrize(::IntegrationLimits, x)\nsymmetrize(::IntegrationLimits, xs...)\n\nTransform x by the symmetries of the parametrization used to reduce the domain, thus mapping the value of x on the parametrization to the full domain. When the integrand is a scalar, this is equal to nsyms(l)*x. When the integrand is a vector, this is sum(S*x for S in symmetries(l)). When the integrand is a matrix, this is sum(S*x*S' for S in symmetries(l)).\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.discretize_equispace","page":"Integration limits","title":"AutoBZ.discretize_equispace","text":"discretize_equispace(::IntegrationLimits, ::Integer)\n\nReturn an iterator of 2-tuples containing integration nodes and weights that correspond to an equispace integration grid with the symmetry transformations applied to it.\n\n\n\n\n\n","category":"function"},{"location":"#AutoBZ.jl-documentation","page":"Home","title":"AutoBZ.jl documentation","text":"","category":"section"}]
}
