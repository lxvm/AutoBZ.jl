var documenterSearchIndex = {"docs":
[{"location":"pages/app/interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"pages/app/interfaces/#Wannier90","page":"Interfaces","title":"Wannier90","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"AutoBZ.load_wannier90_data\nAutoBZ.load_interp\nAutoBZ.load_autobz\nAutoBZ.parse_hamiltonian\nAutoBZ.parse_position_operator\nAutoBZ.parse_wout","category":"page"},{"location":"pages/app/interfaces/#AutoBZ.load_wannier90_data","page":"Interfaces","title":"AutoBZ.load_wannier90_data","text":"load_wannier90_data(seedname::String; bz::AbstractBZ=FBZ(), interp::AbstractWannierInterp=HamiltonianInterp, kwargs...)\n\nReturn a tuple (interp, bz) containing the requested Wannier interpolant, interp and the Brillouin zone bz to integrate over. The seedname should point to Wannier90 data to read in. Additional keywords are passed to the interpolant constructor, load_interp, while load_autobz can be referenced for Brillouin zone details. For a list of possible keywords, see subtypes(AbstractBZ) and using TypeTree; tt(AbstractWannierInterp).\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.load_interp","page":"Interfaces","title":"AutoBZ.load_interp","text":"load_hamiltonian(seed; period=1, compact=:N)\n\nLoad an ab-initio Hamiltonian output from Wannier90 into filename as an evaluatable FourierSeries whose periodicity can be set by the keyword argument period which defaults to setting the period along each dimension to 1.0. To define different periods for different dimensions, pass an SVector as the period. To store Hermitian Fourier coefficients in compact form, use the keyword compact to specify:\n\n:N: do not store the coefficients in compact form\n:L: store the lower triangle of the coefficients\n:U: store the upper triangle of the coefficients\n:S: store the lower triangle of the symmetrized coefficients, (c+c')/2\n\n\n\n\n\nload_position_operator(seed; period=1, compact=nothing)\n\nLoad a position operator Hamiltonian output from Wannier90 into filename as an evaluatable ManyFourierSeries with separate x, y, and z components whose periodicity can be set by the keyword argument period which defaults to setting the period along each dimension to 1.0. To define different periods for different dimensions, pass an SVector as the period. To store Hermitian Fourier coefficients in compact form, use the keyword compact to specify:\n\n:N: do not store the coefficients in compact form\n:L: store the lower triangle of the coefficients\n:U: store the upper triangle of the coefficients\n:S: store the lower triangle of the symmetrized coefficients, (c+c')/2\n\nNote that in some cases the coefficients are not Hermitian even though the values of the series are.\n\n\n\n\n\nload_interp(::Type{<:GradientVelocityInterp}, seed, A; precision=Float64, period=1, compact=:N, soc=nothing,\ngauge=Wannier(), vcomp=Whole(), coord=Lattice())\n\n\n\n\n\nload_covariant_hamiltonian_velocities(::Type{<:CovariantVelocityInterp}, seed, A;\nprecision=Float64, compact=:N, soc=nothing,\ngauge=Wannier(), vcomp=whole(), coord=Lattice())\n\n\n\n\n\nload_interp(::Type{<:MassVelocityInterp}, seed, A;\nprecision=Float64, compact=:N, soc=nothing,\ngauge=Wannier(), vcomp=whole(), coord=Lattice())\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.load_autobz","page":"Interfaces","title":"AutoBZ.load_autobz","text":"load_autobz(::AbstractBZ, seedname; kws...)\n\nAutomatically load a BZ using data from a \"seedname.wout\" file with the load_bz interface from AutoBZCore.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.parse_hamiltonian","page":"Interfaces","title":"AutoBZ.parse_hamiltonian","text":"parse_hamiltonian(filename)\n\nParse an ab-initio Hamiltonian output from Wannier90 into filename, extracting the fields (date_time, num_wann, nrpts, degen, irvec, C)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.parse_position_operator","page":"Interfaces","title":"AutoBZ.parse_position_operator","text":"parse_position_operator(filename, rot=I)\n\nParse a position operator output from Wannier90 into filename, extracting the fields (date_time, num_wann, nrpts, irvec, A1, A2, A3). By default, A1, A2, A3 are in the Cartesian basis (i.e. X, Y, Z because the Wannier90 seedname_r.dat file is), however a rotation matrix rot can be applied to change the basis of the input to other coordinates.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.parse_wout","page":"Interfaces","title":"AutoBZ.parse_wout","text":"parse_wout(filename; iprint=1)\n\nreturns the lattice vectors a and reciprocal lattice vectors b\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#Python","page":"Interfaces","title":"Python","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Julia code, including AutoBZ.jl, can be called from Python using the package PyJulia","category":"page"},{"location":"pages/app/interfaces/#Setup","page":"Interfaces","title":"Setup","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"TL;DR","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"$ julia -e 'import Pkg; Pkg.add(\"PyCall\")'\n$ python3 -m pip install julia","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"If you want to, you can install PyJulia in a Python venv, but on the Julia side PyCall.jl must be installed in the default environment","category":"page"},{"location":"pages/app/interfaces/#Demo","page":"Interfaces","title":"Demo","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The Python snippet below shows how from the demos folder of the AutoBZ repository you can run one of the demo scripts:","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"from julia.api import Julia\njl = Julia(compiled_modules=False)\n\n# julia environment setup in working directory 'demos'\njl.eval(\"\"\"\nimport Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n\"\"\")\n\n# capture output of script\nout = jl.eval('include(\"dos_test.jl\")')","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The first two lines are adapted for loading PyJulia on Debian systems.","category":"page"},{"location":"pages/app/interfaces/#MATLAB","page":"Interfaces","title":"MATLAB","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Julia code, including AutoBZ.jl, can be called from MATLAB using the package MATDaemon.jl.","category":"page"},{"location":"pages/app/interfaces/#Setup-2","page":"Interfaces","title":"Setup","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Download the","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"jlcall.m script, which will install the Julia server when first called.","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Install Julia and give MATLAB the path the Julia binary by running setenv('PATH',['path-to-julia/bin:',getenv('PATH')]);\nTest that jlcall works by running jlcall('sort', {rand(2,5)}, struct('dims', int64(2)))\nCreate setup.jl with the lines import Pkg; Pkg.activate(\".\"); Pkg.develop(path=expanduser(\"path-to-AutoBZ.jl\"));\nStart a julia server within MATLAB with the appropriate modules: jlcall('', 'project', 'path-to-myproject', 'setup', 'path-to-setup.jl', 'modules', {'LinearAlgebra','AutoBZ'}, 'threads', 'auto', 'restart', true);\nNow AutoBZ can be used via jlcall","category":"page"},{"location":"pages/app/interfaces/#Demo-2","page":"Interfaces","title":"Demo","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Suppose we would like to run the function get_dos defined in this script.jl","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"import Pkg; Pkg.activate(\".\"); Pkg.develop(path=expanduser(\"path-to-AutoBZ.jl\"))\nusing AutoBZ\n\nfunction get_dos(seedname, self_energy_path, ωs, rtol, atol)\n    H, FBZ = load_wannier90_data(seedname)\n    Σ = load_self_energy(self_energy_path)\n    integrand = DOSIntegrand(H, Σ)\n    dos = IntegralSolver(integrand, FBZ, abstol=atol, reltol=rtol)\n    return batchsolve(dos, ωs)\nend","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The MATLAB snippet below shows how to setup the Julia server to run a demo script.","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"jlcall('', ...\n    'project', '/path/to/MyProject', % use Julia environment with AutoBZ\n    'setup', '/path/to/setup.jl', % path to script shown above\n    'modules', {'AutoBZ'}, % import AutoBZ and other modules\n    'threads', 'auto', % use the default number of Julia threads\n    'restart', true % start a fresh Julia server environment\n)","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"and the snippet below shows how to call get_dos from MATLAB","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"jlcall('get_dos', '.../svo', '.../svo_self_energy.txt', {0.5})","category":"page"},{"location":"pages/app/integrands/#Integrands","page":"Integrands","title":"Integrands","text":"","category":"section"},{"location":"pages/app/integrands/#User-defined","page":"Integrands","title":"User-defined","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"For integrands that can be evaluated by Wannier interpolation, the following data are necessary to define an integrand:","category":"page"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"the integrand evaluator\na Fourier series\nadditional parameters for the evaluator","category":"page"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"Consider implementing custom integrands using the generic template type AutoBZCore.FourierIntegrand that is compatible with all of the adaptive and equispace integration routines. Using this interface will automatically optimize multi-dimensional Fourier series evaluations with the various integration routines.","category":"page"},{"location":"pages/app/integrands/#Pre-defined","page":"Integrands","title":"Pre-defined","text":"","category":"section"},{"location":"pages/app/integrands/#Types","page":"Integrands","title":"Types","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.GlocIntegrand\nAutoBZ.DiagGlocIntegrand\nAutoBZ.TrGlocIntegrand\nAutoBZ.DOSIntegrand\nAutoBZ.TransportFunctionIntegrand\nAutoBZ.TransportDistributionIntegrand\nAutoBZ.KineticCoefficientIntegrand\nAutoBZ.OpticalConductivityIntegrand\nAutoBZ.ElectronDensityIntegrand\nAutoBZ.AuxTransportDistributionIntegrand\nAutoBZ.AuxKineticCoefficientIntegrand\nAutoBZ.AuxOpticalConductivityIntegrand","category":"page"},{"location":"pages/app/integrands/#AutoBZ.GlocIntegrand","page":"Integrands","title":"AutoBZ.GlocIntegrand","text":"GlocIntegrand(h, Σ, ω, μ)\nGlocIntegrand(h, Σ, ω; μ=0)\nGlocIntegrand(h, Σ; ω, μ=0)\n\nGreen's function integrands accepting a self energy Σ that can either be a matrix or a function of ω (see the self energy section of the documentation for examples)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.DiagGlocIntegrand","page":"Integrands","title":"AutoBZ.DiagGlocIntegrand","text":"DiagGlocIntegrand(h, Σ, ω, μ)\nDiagGlocIntegrand(h, Σ, ω; μ=0)\nDiagGlocIntegrand(h, Σ; ω, μ=0)\n\nGreen's function integrands accepting a self energy Σ that can either be a matrix or a function of ω (see the self energy section of the documentation for examples)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.TrGlocIntegrand","page":"Integrands","title":"AutoBZ.TrGlocIntegrand","text":"TrGlocIntegrand(h, Σ, ω, μ)\nTrGlocIntegrand(h, Σ, ω; μ=0)\nTrGlocIntegrand(h, Σ; ω, μ=0)\n\nGreen's function integrands accepting a self energy Σ that can either be a matrix or a function of ω (see the self energy section of the documentation for examples)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.DOSIntegrand","page":"Integrands","title":"AutoBZ.DOSIntegrand","text":"DOSIntegrand(h, Σ, ω, μ)\nDOSIntegrand(h, Σ, ω; μ=0)\nDOSIntegrand(h, Σ; ω, μ=0)\n\nGreen's function integrands accepting a self energy Σ that can either be a matrix or a function of ω (see the self energy section of the documentation for examples)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.TransportFunctionIntegrand","page":"Integrands","title":"AutoBZ.TransportFunctionIntegrand","text":"TransportFunctionIntegrand(hv; β, μ=0)\n\nComputes the following integral\n\nD_alphabeta = int_textBZ dk operatornameTrnu_alpha(k) A(komega_1) nu_beta(k) A(k omega_2)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.TransportDistributionIntegrand","page":"Integrands","title":"AutoBZ.TransportDistributionIntegrand","text":"TransportDistributionIntegrand(hv, Σ, ω₁, ω₂, μ)\nTransportDistributionIntegrand(hv, Σ, ω₁, ω₂; μ)\nTransportDistributionIntegrand(hv, Σ; ω₁, ω₂, μ)\n\nA function whose integral over the BZ gives the transport distribution\n\nGamma_alphabeta(omega_1 omega_2) = int_textBZ dk operatornameTrnu_alpha(k) A(komega_1) nu_beta(k) A(k omega_2)\n\nBased on TRIQS. See Integrand for more details.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.KineticCoefficientIntegrand","page":"Integrands","title":"AutoBZ.KineticCoefficientIntegrand","text":"KineticCoefficientIntegrand(bz, alg::AutoBZAlgorithm, hv::AbstracVelocity, Σ; n, β, Ω, abstol, reltol, maxiters)\nKineticCoefficientIntegrand([lb=lb(Σ), ub=ub(Σ),] alg, hv::AbstracVelocity, Σ; n, β, Ω, abstol, reltol, maxiters)\n\nA function whose integral over the BZ gives the kinetic coefficient. Mathematically, this computes\n\nA_nalphabeta(Omega) = int_-infty^infty d omega (betaomega)^n fracf(omega) - f(omega+Omega)Omega Gamma_alphabeta(omega omega+Omega)\n\nwhere f(omega) = (e^betaomega+1)^-1 is the Fermi distriubtion. Based on TRIQS. The argument alg determines what the order of integration is. Given a BZ algorithm, the inner integral is the BZ integral. Otherwise it is the frequency integral.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.OpticalConductivityIntegrand","page":"Integrands","title":"AutoBZ.OpticalConductivityIntegrand","text":"OpticalConductivityIntegrand\n\nReturns a KineticCoefficientIntegrand with n=0. See KineticCoefficientIntegrand for further details\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.ElectronDensityIntegrand","page":"Integrands","title":"AutoBZ.ElectronDensityIntegrand","text":"ElectronDensityIntegrand(bz, alg::AutoBZAlgorithm, h::AbstractHamiltonianInterp, Σ; β, [μ=0])\nElectronDensityIntegrand([lb=lb(Σ), ub=ub(Σ),] alg, h::AbstractHamiltonianInterp, Σ; β, [μ=0])\n\nA function whose integral over the BZ gives the electron density. Mathematically, this computes\n\nn(mu) = int_-infty^infty d omega f(omega) operatornameDOS(omega+mu)\n\nwhere f(omega) = (e^betaomega+1)^-1 is the Fermi distriubtion. The argument alg determines what the order of integration is. Given a BZ algorithm, the inner integral is the BZ integral. Otherwise it is the frequency integral.\n\nTo get the density/number of electrons, multiply the result of this integral by n_sp/det(bz.B)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.AuxTransportDistributionIntegrand","page":"Integrands","title":"AutoBZ.AuxTransportDistributionIntegrand","text":"AuxTransportDistributionIntegrand(hv, Σ, ω₁, ω₂, μ)\nAuxTransportDistributionIntegrand(hv, Σ, ω₁, ω₂; μ)\nAuxTransportDistributionIntegrand(hv, Σ; ω₁, ω₂, μ)\n\nA function whose integral over the BZ gives the transport distribution\n\nGamma_alphabeta(omega_1 omega_2) = int_textBZ dk operatornameTrnu_alpha(k) A(komega_1) nu_beta(k) A(k omega_2)\n\nBased on TRIQS. See Integrand for more details.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.AuxKineticCoefficientIntegrand","page":"Integrands","title":"AutoBZ.AuxKineticCoefficientIntegrand","text":"AuxKineticCoefficientIntegrand\n\nA kinetic coefficient integrand that is more robust to the peak-missing problem. See KineticCoefficientIntegrand for arguments.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.AuxOpticalConductivityIntegrand","page":"Integrands","title":"AutoBZ.AuxOpticalConductivityIntegrand","text":"AuxOpticalConductivityIntegrand\n\nReturns a AuxKineticCoefficientIntegrand with n=0. See AuxKineticCoefficientIntegrand for further details\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#Functions","page":"Integrands","title":"Functions","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.fermi\nAutoBZ.fermi′\nAutoBZ.fermi_window\nAutoBZ.fermi_window_limits","category":"page"},{"location":"pages/app/integrands/#AutoBZ.fermi","page":"Integrands","title":"AutoBZ.fermi","text":"fermi(β, ω)\nfermi(x)\n\nEvaluates a Fermi distribution with unitless input\n\nf(x) = frac1e^x+1\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.fermi′","page":"Integrands","title":"AutoBZ.fermi′","text":"fermi′(x)\n\nEvaluates a first derivative of the Fermi distribution with unitless input\n\npartial_x f(x) = -frac12(cosh(x)+1)\n\nNote that the analytic expression above can be rewritten many ways using hypertrigonometric identities.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.fermi_window","page":"Integrands","title":"AutoBZ.fermi_window","text":"fermi_window(β, ω, Ω)\nfermi_window(x, y)\n\nEvaluates a unitless window function with unitless inputs determined by the Fermi distribution f and defined by\n\nchi(x y) = fracf(x) - f(x+y)y\n\nIn the case y==0 then this simplifies to the derivative of the Fermi distribution.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.fermi_window_limits","page":"Integrands","title":"AutoBZ.fermi_window_limits","text":"fermi_window_limits(Ω, β [; atol=0.0, rtol=1e-20])\n\nReturns limits (a,b) over ω restricted to the interval where the Fermi window is larger than max(atol,rtol*fermi_window(0,β*Ω)). Choosing atol and rtol wisely is important to integrating the entire region of interest, since this is a truncation of an infinite interval, and should be tested for convergence.\n\n\n\n\n\n","category":"function"},{"location":"pages/workflow/#Workflow","page":"Workflow","title":"Workflow","text":"","category":"section"},{"location":"pages/workflow/#Installation","page":"Workflow","title":"Installation","text":"","category":"section"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"To install Julia, download the latest binaries from https://julialang.org/ and add them to your PATH.","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"Since AutoBZ.jl is an unregistered Julia package, adding it to a Julia environment must be done with the repository URL and Julia's package manager","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/lxvm/AutoBZ.jl.git\")","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"Or to download the repository with SSH use the git link: git@github.com:lxvm/AutoBZ.jl.git","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"For users interested in keeping up to date with the latest developments in the package, the next section also describes a convenient setup.","category":"page"},{"location":"pages/workflow/#Development-installation","page":"Workflow","title":"Development installation","text":"","category":"section"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"The following workflow sets up an environment that makes it convenient to run AutoBZ either locally or on a cluster, as well as to update the repository. First, create a working directory for this project that will also serve as the home of its Julia environment","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"$ mkdir workdir\n$ cd workdir\n$ julia --project=. # start an interactive session in the <workdir> environment","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"In the Julia session, adding AutoBZ to the environment while cloning the repository to the working directory can be done interactively as shown below","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"julia> ] # enters the package manager\n(workdir) pkg> develop --local https://github.com/lxvm/AutoBZ.jl.git # clones repo into ./dev/AutoBZ","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"An equivalent shell script to set up the environment is the following","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"$ mkdir dev\n$ git clone https://github.com/lxvm/AutoBZ.jl.git dev/AutoBZ\n$ julia -e 'import Pkg; Pkg.activate(\".\"); Pkg.develop(path=\"dev/AutoBZ\")'","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"Updating the repository can now be done with cd dev/AutoBZ and git pull.","category":"page"},{"location":"pages/workflow/#Running-jobs","page":"Workflow","title":"Running jobs","text":"","category":"section"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"Users of AutoBZ will find scripts in the demos to use as templates for their jobs. From the working directory configured above, the scripts from the demos folder can be copied back, as well any coefficient files for the calculations that will be run.","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"julia> ; # enters a shell\nshell> cp -t . dev/AutoBZ/demos/svo_hr.dat dev/AutoBZ/demos/svo_r.dat dev/AutoBZ/demos/kc_benchmark.jl","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"In the lines above, the script kc_benchmark.jl was copied along with its default data files into the working directory. Note if you have data files with different names, the script needs to be edited to load those files instead. Moreover, the files in the working directory can be freely edited without affecting those in the AutoBZ repository, and likewise the repository can be updated without affecting the files in workdir. Note that any script dependencies other than AutoBZ will need to be added to the environment in workdir (e.g. pkg> add Plots).","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"Finally, to run the script from the Julia session in the workdir, simply include(\"kc_benchmark.jl\"). If you would like to run a script as a cluster job, include the line below in your bash script submitted to the scheduler.","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"julia --project=. kc_benchmark.jl","category":"page"},{"location":"pages/workflow/#Notes","page":"Workflow","title":"Notes","text":"","category":"section"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"When AutoBZ is released as a registered package, it will be enough to add AutoBZ to the Julia environment and copy the scripts from the installation location, although the method described above conveniently saves the repository in the working directory, letting you easily update the git repository or change branches. If working in an interactive session, this method also works with a Revise.jl workflow.","category":"page"},{"location":"pages/app/self_energy/#Self-energies","page":"Self energies","title":"Self energies","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"This section of the documentation explains how scalar and matrix-valued self energy data are formatted, loaded, and evaluated","category":"page"},{"location":"pages/app/self_energy/#IO","page":"Self energies","title":"IO","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"For self energy data stored on equispaced frequency grids, the following file formats and routines use the EquiBaryInterp.jl package to interpolate the data for continuous evaluation. Otherwise, a rational approximation of the self energy data is constructed with the AAA algorithm in BaryRational.jl and that is converted into a piecewise Chebyshev interpolant with HChebInterp.jl.","category":"page"},{"location":"pages/app/self_energy/#File-format","page":"Self energies","title":"File format","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"Depending on the amount of data necessary to represent the self-energy, there are different data file formats for scalar and matrix-valued self energies. Within matrix-valued self energies. There is also a special case diagonal matrices.","category":"page"},{"location":"pages/app/self_energy/#Scalar","page":"Self energies","title":"Scalar","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"First line contains only nfpts, the number of frequency points in the data set. The following nfpts lines contain three columns with the frequency point, real part of the self energy, and imaginary part of the self energy. For example","category":"page"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"3001\n-15.00   7.9224534011421888  -0.0608455837453997\n-14.99   7.9107083143558103  -0.0627222170930403\n...","category":"page"},{"location":"pages/app/self_energy/#Diagonal","page":"Self energies","title":"Diagonal","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"First line contains only nfpts, the number of frequency points in the data set. Second line contains only num_wann, the number of bands used for Wannier interpolation (i.e. should be the same as the Hamiltonian). The following nfpts*num_wann lines contain four columns with the frequency point, one-base index of the self energy in the diagonal of the matrix, real part of the self energy, and imaginary part of the self energy. It is assumed that the frequency data is sorted wih the index as the faster index than the frequency. For example","category":"page"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"3001\n3\n-15.00   1   7.9224534011421888  -0.0608455837453997\n-15.00   2   7.9224534011422065  -0.0608455837453997\n...","category":"page"},{"location":"pages/app/self_energy/#Matrix","page":"Self energies","title":"Matrix","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"First line contains only nfpts, the number of frequency points in the data set. Second line contains only num_wann, the number of bands used for Wannier interpolation (i.e. should be the same as the Hamiltonian). The following nfpts*num_wann^2 lines contain five columns with the frequency point, one-base index of the self energy in the row of the matrix, one-base index of the self energy in the column of the matrix, real part of the self energy, and imaginary part of the self energy. It is assumed that the frequency data is sorted wih the index as the faster index than the frequency. For example","category":"page"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"3001\n3\n-15.00   1   1   7.9224534011421888  -0.0608455837453997\n-15.00   1   2   7.9224534011422065  -0.0608455837453997\n...","category":"page"},{"location":"pages/app/self_energy/#Routines","page":"Self energies","title":"Routines","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"AutoBZ.load_self_energy","category":"page"},{"location":"pages/app/self_energy/#AutoBZ.load_self_energy","page":"Self energies","title":"AutoBZ.load_self_energy","text":"load_self_energy(filename; [sigdigits=8, output=:interp, degree=:default])\n\nRead the self energy data in filename, which should be in either :scalar, :diagonal, or :matrix format, and return a self-energy evaluator. Note that the frequency data is assumed to be an equispace grid. The optional argument degree indicates the degree of barycentric Lagrange interpolation, and that sigdigits indicates the number of significant digits used to round the frequency data so as to avoid rounding errors.\n\nThe keyword output may take values of :interp (default) or :raw which will either return the self energy data wrapped with a high-order interpolating function (details below) or in the latter option, just the raw data.\n\nThe interpolating function will always be a piecewise high-order polynomial whose details depend on the distribution of frequency points:\n\nFor equispaced frequency points, a local barycentric Lagrange interpolant is used with a default polynomial degree of 8\nFor other frequency point distributions, first a global rational approximant is formed using the AAA algorithm, and then h-adaptive Chebyshev interpolation is performed on the global interpolant in order to obtain a fast-to-evaluate representation of default polynomial degree 16.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#Interface","page":"Self energies","title":"Interface","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"AutoBZ.AbstractSelfEnergy\nAutoBZ.lb\nAutoBZ.ub","category":"page"},{"location":"pages/app/self_energy/#AutoBZ.AbstractSelfEnergy","page":"Self energies","title":"AutoBZ.AbstractSelfEnergy","text":"AbstractSelfEnergy\n\nAn abstract type whose instances implement the following interface:\n\ninstances are callable and return a square matrix as a function of frequency\ninstances have methods lb and ub that return the lower and upper bounds of of the frequency domain for which the instance can be evaluated\n\n\n\n\n\n","category":"type"},{"location":"pages/app/self_energy/#AutoBZ.lb","page":"Self energies","title":"AutoBZ.lb","text":"lb(::AbstractSelfEnergy)\n\nReturn the greatest lower bound of the domain of the self energy evaluator\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#AutoBZ.ub","page":"Self energies","title":"AutoBZ.ub","text":"ub(::AbstractSelfEnergy)\n\nReturn the least upper bound of the domain of the self energy evaluator\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#Types","page":"Self energies","title":"Types","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"AutoBZ.EtaSelfEnergy\nAutoBZ.ConstScalarSelfEnergy\nAutoBZ.ScalarSelfEnergy\nAutoBZ.DiagonalSelfEnergy\nAutoBZ.MatrixSelfEnergy","category":"page"},{"location":"pages/app/self_energy/#AutoBZ.EtaSelfEnergy","page":"Self energies","title":"AutoBZ.EtaSelfEnergy","text":"EtaSelfEnergy(η::Real)\n\nConstruct a ConstScalarSelfEnergy with value -im*η.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#AutoBZ.ConstScalarSelfEnergy","page":"Self energies","title":"AutoBZ.ConstScalarSelfEnergy","text":"ConstScalarSelfEnergy(v::Number)\n\nConstruct a self-energy evaluator which returns v I for any frequency.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/self_energy/#AutoBZ.ScalarSelfEnergy","page":"Self energies","title":"AutoBZ.ScalarSelfEnergy","text":"ScalarSelfEnergy(interpolant, lb, ub)\n\nConstruct a self-energy evaluator which for frequencies above lb and below ub returns the scalar interpolant at that frequency times an identity matrix.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/self_energy/#AutoBZ.DiagonalSelfEnergy","page":"Self energies","title":"AutoBZ.DiagonalSelfEnergy","text":"DiagonalSelfEnergy(interpolant, lb, ub)\n\nConstruct a self-energy evaluator which for frequencies above lb and below ub returns the vector interpolant at that frequency wrapped by a Diagonal.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/self_energy/#AutoBZ.MatrixSelfEnergy","page":"Self energies","title":"AutoBZ.MatrixSelfEnergy","text":"MatrixSelfEnergy(interpolant, lb, ub)\n\nConstruct a self-energy evaluator which for frequencies above lb and below ub returns the matrix-valued interpolant at that frequency.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#Fourier-series","page":"Fourier series","title":"Fourier series","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Wannier-interpolated Hamiltonians are represented by Fourier series with a modest number of Fourier coefficients. The goal of this page of documentation is to describe the features, interface, and conventions of Fourier series evaluation as implemented by this library.","category":"page"},{"location":"pages/man/fourier/#Conventions","page":"Fourier series","title":"Conventions","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Fourier series represent functions as linear combinations of sinusoids whose frequencies are integer multiples of a fundamental mode. In the band theory of solids, the fundamental frequencies, or normal modes, for a Hamiltonian correspond to linear combinations of real-space lattice vectors that generate a Bravais lattice. The sections below define conventions for each of these linear combinations.","category":"page"},{"location":"pages/man/fourier/#Lattice-vectors","page":"Fourier series","title":"Lattice vectors","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"It is conventional to construct a reciprocal lattice bmb_j from a Bravais lattice bma_i such that ","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"bmb_j cdot bma_i = 2pidelta_ij","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Then we write the momentum space variable in the reciprocal lattice vector basis and the position space variable in the real lattice vector basis","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"bmk = sum_j=1^d k_j bmb_j\nqquad\nbmR = sum_i=1^d R_i bma_i","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Without loss of generality, the k_j can be taken in the domain 01 and the R_i are integers.","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Additionally, any coordinate transformations of bmk from the Cartesian basis to the reciprocal lattice basis only modify Brillouin zone integrals by a multiplicative factor of the absolute value of the determinant of the basis transformation.","category":"page"},{"location":"pages/man/fourier/#Series-coefficients","page":"Fourier series","title":"Series coefficients","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Wannier-interpolated Hamiltonians are small matrices obtained by projecting the ab-initio Hamiltonian onto a low energy subspace, a process called downfolding. These Hamiltonians can be expressed by a Fourier series as in the sum below","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"H(bmk) = sum_bmR e^ibmkcdotbmR H_bmR","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"where the coefficients H_bmR are the matrix-valued Fourier coefficients. Truncating the sum over bmR at a modest number of modes can be done for Wannier Hamiltonians in the maximally-localized orbital basis, for which H(bmk) is a smooth and periodic function and thus the truncation error of its Fourier series converges super-algebraically with respect to the number of modes.","category":"page"},{"location":"pages/man/fourier/#Hamiltonian-recipe","page":"Fourier series","title":"Hamiltonian recipe","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"In model systems, a Bloch Hamiltonian can often be written down analytically. The recipe to write it as a Fourier series has two-steps","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Identify the real and reciprocal Bravais lattices, bma_i and bmb_j, and rewrite all of the phase dependences of the Hamiltonian as bmkcdotbmR with each vector in its corresponding basis, as explained above.\nFactor the Hamiltonian into a linear combination of normal modes indexed by the distinct bmR vectors. If the Hamiltonian is matrix-valued, this can be done one matrix element at a time.","category":"page"},{"location":"pages/man/fourier/#Interface","page":"Fourier series","title":"Interface","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"See FourierSeriesEvaluators.jl for the AbstractFourierSeries interface, which allows evaluation of the series with a function-like f(x) syntax","category":"page"},{"location":"pages/man/fourier/#Types","page":"Fourier series","title":"Types","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"The concrete types listed below all implement the AbstractFourierSeries interface and should cover most use cases.","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.AbstractWannierInterp\nAutoBZ.AbstractGaugeInterp\nAutoBZ.AbstractHamiltonianInterp\nAutoBZ.HamiltonianInterp\nAutoBZ.AbstractCoordInterp\nAutoBZ.BerryConnectionInterp\nAutoBZ.AbstractVelocityInterp\nAutoBZ.GradientVelocityInterp\nAutoBZ.CovariantVelocityInterp\nAutoBZ.MassVelocityInterp","category":"page"},{"location":"pages/man/fourier/#AutoBZ.AbstractWannierInterp","page":"Fourier series","title":"AutoBZ.AbstractWannierInterp","text":"AbstractWannierInterp{N,T,iip} <: AbstractFourierSeries{N,T,iip}\n\nAbstract supertype for all Wannier-interpolated quantities in AutoBZ\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.AbstractGaugeInterp","page":"Fourier series","title":"AutoBZ.AbstractGaugeInterp","text":"AbstractGaugeInterp{G,N,T,iip} <: AbstractWannierInterp{N,T,iip}\n\nAn abstract subtype of AbstractFourierSeries representing in-place Fourier series evaluators for Wannier-interpolated quantities with a choice of basis, or gauge, G, which is typically Hamiltonian or Wannier. For details, see to_gauge.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.AbstractHamiltonianInterp","page":"Fourier series","title":"AutoBZ.AbstractHamiltonianInterp","text":"AbstractHamiltonianInterp{G,N,T,iip} <: AbstractGaugeInterp{G,N,T,iip}\n\nAbstract type representing Hamiltonians, which are matrix-valued Hermitian Fourier series. They should also have period 1, but produce derivatives with wavenumber 1.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.HamiltonianInterp","page":"Fourier series","title":"AutoBZ.HamiltonianInterp","text":"HamiltonianInterp(f::FourierSeries; gauge=:Wannier)\n\nA wrapper for FourierSeries with an additional gauge that allows for convenient diagonalization of the result. For details see to_gauge.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.AbstractCoordInterp","page":"Fourier series","title":"AutoBZ.AbstractCoordInterp","text":"AbstractCoordInterp{B,G,N,T,iip} <:AbstractGaugeInterp{G,N,T,iip}\n\nAn abstract subtype of AbstractGaugeInterp also containing information about the coordinate basis B, which is either Lattice or Cartesian. For details see to_coord and CoordDefault.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.BerryConnectionInterp","page":"Fourier series","title":"AutoBZ.BerryConnectionInterp","text":"BerryConnectionInterp{P}(a::ManyFourierSeries, B; coord)\n\nInterpolate the Berry connection in basis coord. a must evaluate the components of the connection in coordinate basis P, and B is the coordinate transformation from P to coord.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.AbstractVelocityInterp","page":"Fourier series","title":"AutoBZ.AbstractVelocityInterp","text":"AbstractVelocityInterp{C,B,G,N,T,iip} <:AbstractCoordInterp{B,G,N,T,iip}\n\nAn abstract subtype of AbstractCoordInterp also containing information the velocity component, C, which is typically Val(:whole), Val(:inter), or Val(:intra). For details see to_vcomp_gauge. Since the velocity depends on the Hamiltonian, subtypes should also evaluate the Hamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.GradientVelocityInterp","page":"Fourier series","title":"AutoBZ.GradientVelocityInterp","text":"GradientVelocityInterp(h::AbstractHamiltonianInterp, A; gauge, coord, vcomp)\n\nEvaluate the Hamiltonian and its gradient, which doesn't produce gauge-covariant velocities. The Hamiltonian h must be in the Wannier gauge, but this will give the result in the requested gauge. A must be the coordinate transformation from the lattice basis to the desired coord system. vcomp selects the contribution to the velocities.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.CovariantVelocityInterp","page":"Fourier series","title":"AutoBZ.CovariantVelocityInterp","text":"CovariantVelocityInterp(hv::GradientVelocityInterp, a::BerryConnectionInterp)\n\nUses the Berry connection to return fully gauge-covariant velocities. Returns a tuple of the Hamiltonian and the three velocity matrices.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.MassVelocityInterp","page":"Fourier series","title":"AutoBZ.MassVelocityInterp","text":"MassVelocityInterp(h::AbstractHamiltonianInterp, A; gauge, coord, vcomp)\n\nCompute the Hamiltonian, its gradient and Hessian, which are not gauge-covariant. See GradientVelocityInterp for explanation of the arguments\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#Gauges","page":"Fourier series","title":"Gauges","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.AbstractGauge\nAutoBZ.Wannier\nAutoBZ.Hamiltonian","category":"page"},{"location":"pages/man/fourier/#AutoBZ.AbstractGauge","page":"Fourier series","title":"AutoBZ.AbstractGauge","text":"AbstractGauge\n\nAbstract supertype of gauges (or bases) for orbital/band indices\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Wannier","page":"Fourier series","title":"AutoBZ.Wannier","text":"Wannier <: AbstractGauge\n\nSingleton type representing the Wannier gauge\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Hamiltonian","page":"Fourier series","title":"AutoBZ.Hamiltonian","text":"Hamiltonian <: AbstractGauge\n\nSingleton type representing the Hamiltonian gauge\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#Coordinate-systems","page":"Fourier series","title":"Coordinate systems","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.AbstractCoordinate\nAutoBZ.Cartesian\nAutoBZ.Lattice","category":"page"},{"location":"pages/man/fourier/#AutoBZ.AbstractCoordinate","page":"Fourier series","title":"AutoBZ.AbstractCoordinate","text":"AbstractCoordinate\n\nAbstract supertype of bases for coordinate/spatial indices\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Cartesian","page":"Fourier series","title":"AutoBZ.Cartesian","text":"Cartesian <: AbstractCoordinate\n\nSingleton type representing Cartesian coordinates.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Lattice","page":"Fourier series","title":"AutoBZ.Lattice","text":"Lattice <: AbstractCoordinate\n\nSingleton type representing lattice coordinates.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#Velocity-components","page":"Fourier series","title":"Velocity components","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.AbstractVelocityComponent\nWhole\nIntra\nInter","category":"page"},{"location":"pages/man/fourier/#AutoBZ.AbstractVelocityComponent","page":"Fourier series","title":"AutoBZ.AbstractVelocityComponent","text":"AbstractVelocityComponent\n\nAbstract supertype representing velocity components.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Whole","page":"Fourier series","title":"AutoBZ.Whole","text":"Whole <: AbstractVelocityComponent\n\nSingleton type representing whole velocities\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Intra","page":"Fourier series","title":"AutoBZ.Intra","text":"Intra <: AbstractVelocityComponent\n\nSingleton type representing intraband velocities\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Inter","page":"Fourier series","title":"AutoBZ.Inter","text":"Inter <: AbstractVelocityComponent\n\nSingleton type representing interband velocities\n\n\n\n\n\n","category":"type"},{"location":"pages/demo/#Demos","page":"Demos","title":"Demos","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"To illustrate the principles and practice of using AutoBZ.jl, the tutorials below show how to setup and compute BZ integrals for various observables of toy, tight-binding models with the package. Additionally, scripts corresponding to the tutorials are available in the demos folder of the repo.","category":"page"},{"location":"pages/demo/#DOS-of-the-integer-lattice-tight-binding-model","page":"Demos","title":"DOS of the integer lattice tight-binding model","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"In this tutorial, we consider a tight-binding model on the n-dimensional integer lattice with lattice constant a and hopping strength t0 given by the following Hamiltonian:","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"H = -t sum_i in Z^n sum_j=1^n ketibrai+hatj + keti+hatjbrai","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where keti represents the state at lattice site iin Z^n and hatj represents a vector of zeros except for a one at position j. We will compute the density of states (DOS) of this system, which as a function of n shows the dimension-dependent behavior of Van-Hove singularities.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Employing Bloch's theorem, which for this problem implies keti+hatj = e^ibmkcdothatjketi, yields the following band structure","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"H(k_1 ldots k_n) = -t(cos(k_1 a) + cdots + cos(k_n a))","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"We shall input this Hamiltonian to AutoBZ by constructing an equivalent Fourier series, which boils down to writing this Hamiltonian in the form H(bmk) = sum_bmR e^ibmkcdotbmR H_bmR, where bmR is an integer multi-index. To do this, we follow the Hamiltonian recipe. In the first step, we identify the real and reciprocal lattice basis vectors as the Cartesian coordinate basis and then observe that the bmR vectors with non-zero coefficients are exactly the nearest neighbor vectors pmhatj_j=1^n. In step two, we identify the coefficients to be -t2 for all the terms by simply writing the cosines as complex exponentials. Finally we fill the array of coefficients by taking each bmR to be the array index of the corresponding coefficient H_bmR.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using OffsetArrays\n\nusing AutoBZ\n\nn = 3 # arbitrary positive integer representing the number of k-space dimensions\na = 1.0 # lattice spacing\nt = 1.0 # hopping amplitude\n#=\nconstruct the array of scalar coefficients and use an OffsetArray so that the\narray indices correspond to the R integer multi-index of the Fourier series\n=#\nC = OffsetArray(zeros(ntuple(_ -> 3, n)), ntuple(_ -> -1:1, n)...)\nfor i in 1:n, j in (-1, 1)\n    C[CartesianIndex(ntuple(k -> k == i ? j : 0, n))] = -0.5t\nend\nH = FourierSeries(C, period = 2pi/a)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Then we can define the integration problem to compute DOS, defined by the integral","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"operatornameDOS(omega) = -frac1pi int_textBZ dbmk operatornameIm left (hbaromega+mu-H(bmk)+ieta)^-1 right","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where omega is a frequency variable, bmk is the reciprocal space vector, mu is the chemical potential and eta is a constant scattering rate. We implement our own user-defined integrand with the AutoBZCore.FourierIntegrand type:","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"ω = t*n # frequency at the band edge/Van-Hove singularity\nħ = 1.0 # reduced Planck's constant\nη = 0.1 # broadening\ndos_integrand(H_k, ω, η) = -imag(inv(ħ*ω - H_k + im*η))/pi # integrand evaluator\ndos_integrand(H_k::FourierValue, ω, η) = dos_integrand(H_k.s, ω, η) # unwrap the value of the series\nD = FourierIntegrand(dos_integrand, H, ω, η) # user-defined integrand","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"To compute the integral, we also need to provide the limits of integration, to specify an error tolerance, and to call one of the integration routines","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using LinearAlgebra\nbz = load_bz(CubicSymIBZ(), Diagonal(collect(AutoBZ.period(H)))) # Irreducible BZ for cubic symmetries is tetrahedron\n\natol = 1e-3 # absolute error tolerance requests the result to within ±atol\n\nprob = AutoBZCore.IntegralProblem(D, bz)\n\nsol = AutoBZCore.solve(prob, IAI(), abstol=atol)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"The routine returns the estimate of the integral sol.u and an error estimate sol.resid.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"You will find a working example of this model in the DOS_example.jl demo that computes DOS over a range of frequencies for this model.","category":"page"},{"location":"pages/demo/#DOS-of-Graphene","page":"Demos","title":"DOS of Graphene","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"In this tutorial, we will build the Fourier series corresponding to a tight-binding model of graphene. This example is more complex in that the lattice vectors are not orthogonal and that there are multiple bands.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"The tight-binding model on the hexagonal lattice with lattice constant a and hopping amplitude t. Applying Bloch's theorem to each triangular sublattice brings the Hamiltonian into block-diagonal form, where each block is of the form","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"-t\nbeginpmatrix\n0  f(bmk)\n f^*(bmk)  0\nendpmatrix","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where f(k) = sum_j=1^3 e^ibmkcdotbmdelta_j depends on the nearest-neighbor vectors","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"bmdelta_1 = ahatx\nqquad\nbmdelta_2 = a(-12hatx+sqrt32haty)\nqquad\nbmdelta_3 = a(-12hatx-sqrt32haty)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"To exactly construct this Fourier series, we begin with step one of the Hamiltonian recipe identifying a basis of lattice vectors that forms a Bravais lattice. We can choose these as the following triangular lattice vectors","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"bma_1 = (bmdelta_1 - bmdelta_3)3\nqquad\nbma_2 = (bmdelta_1 - bmdelta_2)3","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"such that in this basis we write","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"bmdelta_1 = bma_1 + bma_2\nqquad\nbmdelta_2 = bma_1 - 2bma_2\nqquad\nbmdelta_3 = -2bma_1 + bma_2","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Now taking step two, we factor the Hamiltonian into different normal modes and observe the bmR vectors are just the pairs of integer coefficients in the linear combination of Bravais lattice vectors for each exponential.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"(e^ibmkcdot(bma_1 + bma_2) + e^ibmkcdot(bma_1 - 2bma_2) + e^ibmkcdot(-2bma_1 + bma_2))\nbeginpmatrix\n0  0\n -t  0\nendpmatrix\n+ (e^ibmkcdot(-bma_1 - bma_2) + e^ibmkcdot(-bma_1 + 2bma_2) + e^ibmkcdot(2bma_1 - bma_2))\nbeginpmatrix\n0  -t\n 0  0\nendpmatrix","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"This corresponds to the following Fourier series in AutoBZ","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using StaticArrays\nusing OffsetArrays\n\nusing AutoBZ\n\na = 1.0 # length of Bravais lattice vectors\nt = 1.0 # hopping amplitude\nC = OffsetArray(zeros(SMatrix{2,2,ComplexF64,4}, (5,5)), -2:2, -2:2)\nC[1,1]   = C[1,-2] = C[-2,1] = [0 -t; 0 0] # Define C[R] = H_R\nC[-1,-1] = C[-1,2] = C[2,-1] = [0 0; -t 0]\nH = FourierSeries(C, period = 2*pi/a)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"The DOS integrand can be formulated as before, except it must also compute the trace since this Hamiltonian is matrix-valued. Another option would be to use the pre-defined AutoBZ.DOSIntegrand.","category":"page"},{"location":"pages/man/internal/#Internal","page":"Internal","title":"Internal","text":"","category":"section"},{"location":"pages/man/internal/","page":"Internal","title":"Internal","text":"The following symbols used by AutoBZ may change in future versions","category":"page"},{"location":"pages/man/internal/","page":"Internal","title":"Internal","text":"AutoBZ.SSymmetricCompact\nAutoBZ.hinv\nAutoBZ.dos_integrand\nAutoBZ.tr_kron\nAutoBZ.gloc_integrand\nAutoBZ.diag_inv\nAutoBZ.tr_mul\nAutoBZ.to_gauge\nAutoBZ.fermi_window_halfwidth\nAutoBZ.diaggloc_integrand\nAutoBZ.CoordDefault\nAutoBZ.CartesianRep\nAutoBZ.to_coord\nAutoBZ.shift!\nAutoBZ.tr_inv\nAutoBZ.to_vcomp_gauge\nAutoBZ.get_safe_fermi_window_limits\nAutoBZ.parentseries\nAutoBZ.commutator\nAutoBZ.trgloc_integrand\nAutoBZ.covariant_velocity\nAutoBZ.coord\nAutoBZ.LatticeRep\nAutoBZ.SOC\nAutoBZ.GaugeDefault\nAutoBZ.VcompDefault\nAutoBZ.herm","category":"page"},{"location":"pages/man/internal/#AutoBZ.SSymmetricCompact","page":"Internal","title":"AutoBZ.SSymmetricCompact","text":"SSymmetricCompact{N, T, L} <: StaticMatrix{N, N, T}\n\nA StaticArray subtype that represents a Symmetric matrix. Unlike LinearAlgebra.Symmetric, SSymmetricCompact stores only the lower triangle of the matrix (as an SVector). The lower triangle is stored in column-major order. For example, for an SSymmetricCompact{3}, the indices of the stored elements can be visualized as follows:\n\n┌ 1 ⋅ ⋅ ┐\n| 2 4 ⋅ |\n└ 3 5 6 ┘\n\nType parameters:\n\nN: matrix dimension;\nT: element type for lower triangle;\nL: length of the SVector storing the lower triangular elements.\n\nNote that L is always the Nth triangular number.\n\nAn SSymmetricCompact may be constructed either:\n\nfrom an AbstractVector containing the lower triangular elements; or\nfrom a Tuple containing both upper and lower triangular elements in column major order; or\nfrom another StaticMatrix.\n\nFor the latter two cases, only the lower triangular elements are used; the upper triangular elements are ignored.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/internal/#AutoBZ.hinv","page":"Internal","title":"AutoBZ.hinv","text":"hinv(A::SHermitianCompact{3})\n\nCalculate the inverse of a SHermitianCompact matrix using its lower triangle. Note that if the elements on the diagonal are complex, the inverse is not Hermitian.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.dos_integrand","page":"Internal","title":"AutoBZ.dos_integrand","text":"dos_integrand(h, M)\n\nReturns -imag(tr(inv(M-h)))/pi where M = ω*I-Σ(ω). It is unsafe to use this in the inner integral for small eta due to the localized tails of the integrand. The default, safe version also integrates the real part which is less localized, at the expense of a slight slow-down due to complex arithmetic. See TrGlocIntegrand.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.tr_kron","page":"Internal","title":"AutoBZ.tr_kron","text":"tr_kron(A::T, B::T) where {T<:SVector{AbstractMatrix}}\n\nReturns a matrix whose [i,j]th entry is tr(A[i]*B[j]).\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.gloc_integrand","page":"Internal","title":"AutoBZ.gloc_integrand","text":"gloc_integrand(h, M)\n\nReturns inv(M-h) where M = ω*I-Σ(ω)\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.diag_inv","page":"Internal","title":"AutoBZ.diag_inv","text":"diag_inv(A)\n\nCalculate the diagonal entries of the inverse of A.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.tr_mul","page":"Internal","title":"AutoBZ.tr_mul","text":"tr_mul(A, B)\n\nCalculate tr(A*B) without storing the intermediate result.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.to_gauge","page":"Internal","title":"AutoBZ.to_gauge","text":"to_gauge(::AbstractGauge, h) where gauge\n\nTransform the Hamiltonian according to the following values of gauge\n\nWannier: keeps h, vs in the original, orbital basis\nHamiltonian: diagonalizes h and rotates h into the energy, band basis\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.fermi_window_halfwidth","page":"Internal","title":"AutoBZ.fermi_window_halfwidth","text":"fermi_window_halfwidth(Ω, β, atol)\nfermi_window_halfwidth(β, atol)\n\nOne can show that βΩfermiwindow(ω, β, Ω) = -tanh(βΩ/2)/(cosh(β(ω+Ω/2))/cosh(βΩ/2)+1) > -tanh(βΩ/2)/(exp(abs(β(ω+Ω/2)))/2cosh(βΩ/2)+1) as well as when Ω==0, β*fermiwindow(ω, β, 0.0) = and these can be inverted to give a good bound on the width of the frequency window for which the Fermi window function is greater than atol. Returns half the width of this window.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.diaggloc_integrand","page":"Internal","title":"AutoBZ.diaggloc_integrand","text":"diaggloc_integrand(h, M)\n\nReturns diag(inv(M-h)) where M = ω*I-Σ(ω)\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.CoordDefault","page":"Internal","title":"AutoBZ.CoordDefault","text":"CoordDefault(::Type{T})::AbstractCoordinate where T\n\nAbstractCoordInterps should define this trait to declare the coordinate basis where they assume their data is in.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.CartesianRep","page":"Internal","title":"AutoBZ.CartesianRep","text":"CartesianRep()\n\nSymmetry representation of objects that transform under the group action in the same way as the lattice and in Cartesian coordinates.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/internal/#AutoBZ.to_coord","page":"Internal","title":"AutoBZ.to_coord","text":"to_coord(B::AbstractCoordinate, D::AbstractCoordinate, A, vs)\n\nIf B and D are the same type return vs, however and if they differ return A*vs.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.shift!","page":"Internal","title":"AutoBZ.shift!","text":"shift!(h::AbstractHamiltonianInterp, λ::Number)\n\nModifies and returns h such that it returns h - λ*I. Will throw a BoundsError if this operation cannot be done on the existing data.\n\n\n\n\n\nshift!(::AbstractVelocityInterp, λ)\n\nOffset the zero-point energy in a Hamiltonian system by a constant\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.tr_inv","page":"Internal","title":"AutoBZ.tr_inv","text":"tr_inv(A)\n\nCalculate the trace of the inverse of A.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.to_vcomp_gauge","page":"Internal","title":"AutoBZ.to_vcomp_gauge","text":"to_vcomp_gauge(::Val{C}, ::Val{G}, h, vs...) where {C,G}\n\nTake the velocity components of vs in any gauge according to the value of C\n\nWhole: return the whole velocity (sum of interband and intraband components)\nIntra: return the intraband velocity (diagonal in Hamiltonian gauge)\nInter: return the interband velocity (off-diagonal terms in Hamiltonian gauge)\n\nTransform the velocities into a gauge according to the following values of G\n\nWannier: keeps H, vs in the original, orbital basis\nHamiltonian: diagonalizes H and rotates H, vs into the energy, band basis\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.get_safe_fermi_window_limits","page":"Internal","title":"AutoBZ.get_safe_fermi_window_limits","text":"get_safe_fermi_window_limits(Ω, β, lb, ub)\n\nGiven a frequency, Ω, inverse temperature, β,  returns an interval (l,u) with possibly truncated limits of integration for the frequency integral at each (Ω, β) point that are determined by the fermi_window_limits routine set to the default tolerances for the decay of the Fermi window function. The arguments lb and ub are lower and upper limits on the frequency to which the default result gets truncated if the default result would recommend a wider interval. If there is any truncation, a warning is emitted to the user, but the program will continue with the truncated limits.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.parentseries","page":"Internal","title":"AutoBZ.parentseries","text":"parentseries(::AbstractHamiltonianInterp)::FourierSeries\n\nReturn the Fourier series that the Hamiltonian wraps\n\n\n\n\n\nparent(::AbstractVelocityInterp)::DerivativeSeries\n\nReturn the Hamiltonian object used for Wannier interpolation\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.commutator","page":"Internal","title":"AutoBZ.commutator","text":"commutator(A, B)\n\nReturn the commutator [A, B] = A*B - B*A.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.trgloc_integrand","page":"Internal","title":"AutoBZ.trgloc_integrand","text":"trgloc_integrand(h, M)\n\nReturns tr(inv(M-h)) where M = ω*I-Σ(ω)\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.covariant_velocity","page":"Internal","title":"AutoBZ.covariant_velocity","text":"covariant_velocity(H, Hα, Aα)\n\nEvaluates the velocity operator hatv_alpha = -fracihbar hatr_alpha hatH with the following expression, equivalent to eqn. 18 in Yates et al.\n\nhatv_alpha = frac1hbar hatH_alpha + fracihbar hatH hatA_alpha\n\nwhere the alpha index implies differentiation by k_alpha. Note that the terms that correct the derivative of the band velocity Also, this function takes hbar = 1.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.coord","page":"Internal","title":"AutoBZ.coord","text":"coord(::AbstractCoordInterp{B})::AbstractCoordinate where B = B\n\nReturn the AbstractCoordinate basis in which an AbstractCoordInterp will be evaluated.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.LatticeRep","page":"Internal","title":"AutoBZ.LatticeRep","text":"LatticeRep()\n\nSymmetry representation of objects that transform under the group action in the same way as the lattice.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/internal/#AutoBZ.SOC","page":"Internal","title":"AutoBZ.SOC","text":"SOC(A)\n\nWrapper for a matrix A that should be used as a block-diagonal matrix     [A 0      0 A] as when dealing with spin-orbit coupling\n\n\n\n\n\n","category":"type"},{"location":"pages/man/internal/#AutoBZ.GaugeDefault","page":"Internal","title":"AutoBZ.GaugeDefault","text":"GaugeDefault(::Type{T})::AbstractCoordinate where T\n\nAbstractGaugeInterps should define this trait to declare the gauge that they assume their data is in.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.VcompDefault","page":"Internal","title":"AutoBZ.VcompDefault","text":"VcompDefault(::Type{T})::AbstractVelocityComponent where T\n\nAbstractVelocityInterps should define this trait to declare the velocity component that they assume their data is in.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.herm","page":"Internal","title":"AutoBZ.herm","text":"herm(A::AbstractMatrix)\n\nReturn the Hermitian part of the matrix A, i.e. (A+A')/2.\n\n\n\n\n\n","category":"function"},{"location":"#AutoBZ.jl","page":"Home","title":"AutoBZ.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AutoBZ","category":"page"},{"location":"#AutoBZ","page":"Home","title":"AutoBZ","text":"This Julia package provides routines for multi-dimensional Brillouin zone (BZ) integration for applications of Wannier interpolation to the calculation of density of states and optical conductivity with self energies and spin-orbit coupling. It uses algorithms which automatically compute BZ integrals to a specified error tolerance by resolving smooth yet highly localized integrands.\n\nSee AutoBZCore.jl on how to create custom integrands and for more details on the algorithms.\n\nIn many-body Green's function methods, BZ integrands are localized at a scale determined by a non-zero, but possibly small, system- and temperature-dependent scattering rate. For example, the single-particle retarded Green's function of an electronic system for frequency omega and reciprocal space vector bmk with chemical potential mu, Hermitian Hamiltonian matrix H(bmk), and self-energy matrix Sigma(omega), which is given by\n\nG(omega) = int_textBZ dbmk operatornameTr left (hbaromega - H(bmk) - Sigma(omega))^-1 right\n\nis localized about the manifold defined by det(hbaromega - H(bmk))=0 (i.e. the Fermi surface when hbaromega=mu) by a scattering rate depending on operatornameIm Sigma(omega).\n\nPackage features\n\nIterated adaptive integration (IAI) with nested calls to QuadGK.jl\nAlgorithm with logarithmic complexity for increasingly localized integrands\nIrreducible Brillouin zone (IBZ) integration for the cubic lattice\nEquispace integration (PTR) as described by Kaye et al. [1]\nAutomatic algorithm that refines k-grid to meet requested error\nSupport for Wannier-interpolated integrands\nUser-defined integrands based on Bloch Hamiltonians\nDensity of states (DOS) calculations\nTransport calculations based on   TRIQS DFTTools\nCalculation of transport function and kinetic coefficients\nOption to separate intra-band and inter-band contributions\nParallelized calculations available through batchsolve interface of AutoBZCore.jl\nWannier90-based parsers Hamiltonians (*_hr.dat files) and position operators (*_r.dat files)\nAutomated interpolation for frequency-dependent self-energy data in text files, using EquiBaryInterp.jl and HChebInterp.jl.\nIBZ integration for arbitrary symmetry groups (via an interface to SymmetryReduceBZ.jl)\nSupports systems with spin-orbit coupling expressed in the self-energy\n\n[1]: Kaye et al. \"Automatic, high-order, and adaptive algorithms for Brillouin zone integration\"\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"To start using the package, see the Workflow and Demos sections.","category":"page"},{"location":"#Notes","page":"Home","title":"Notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are an interested Python user, see the Python section","category":"page"},{"location":"","page":"Home","title":"Home","text":"To see a poster showcasing calculations with the library, click this link","category":"page"},{"location":"#Contact-the-developer","page":"Home","title":"Contact the developer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Lorenzo Van Muñoz","category":"page"}]
}
