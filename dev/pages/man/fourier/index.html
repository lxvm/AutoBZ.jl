<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fourier series · AutoBZ.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">AutoBZ.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Core</span><ul><li><a class="tocitem" href="../../core/adaptive_integration/">Adaptive integration</a></li><li><a class="tocitem" href="../../core/equispace_integration/">Equispace integration</a></li><li><a class="tocitem" href="../../core/integration_limits/">Integration limits</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>Fourier series</a><ul class="internal"><li><a class="tocitem" href="#Conventions"><span>Conventions</span></a></li><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li class="toplevel"><a class="tocitem" href="#Optimized-3D-evaluators"><span>Optimized 3D evaluators</span></a></li><li><a class="tocitem" href="#Interface-2"><span>Interface</span></a></li><li><a class="tocitem" href="#Types-2"><span>Types</span></a></li><li><a class="tocitem" href="#Methods-2"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../integrands/">Integrands</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../self_energy/">Self energies</a></li></ul></li><li><a class="tocitem" href="../../jobs/">Jobs</a></li><li><a class="tocitem" href="../../adaptinterp/">AdaptChebInterp</a></li><li><a class="tocitem" href="../../equiinterp/">EquiBaryInterp</a></li><li><a class="tocitem" href="../../demo/">Demos</a></li><li><a class="tocitem" href="../../workflow/">Workflow</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Fourier series</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fourier series</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lxvm/AutoBZ.jl/blob/main/docs/src/pages/man/fourier.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Fourier-series"><a class="docs-heading-anchor" href="#Fourier-series">Fourier series</a><a id="Fourier-series-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-series" title="Permalink"></a></h1><p>Wannier-interpolated Hamiltonians are represented by Fourier series with a modest number of Fourier coefficients. The goal of this page of documentation is to describe the features, interface, and conventions of Fourier series evaluation as implemented by this library.</p><h2 id="Conventions"><a class="docs-heading-anchor" href="#Conventions">Conventions</a><a id="Conventions-1"></a><a class="docs-heading-anchor-permalink" href="#Conventions" title="Permalink"></a></h2><p>Fourier series represent functions as linear combinations of sinusoids whose frequencies are integer multiples of a fundamental mode. In the band theory of solids, the fundamental frequencies, or normal modes, for a Hamiltonian correspond to linear combinations of real-space lattice vectors that generate a Bravais lattice. The sections below define conventions for each of these linear combinations.</p><h3 id="Lattice-vectors"><a class="docs-heading-anchor" href="#Lattice-vectors">Lattice vectors</a><a id="Lattice-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Lattice-vectors" title="Permalink"></a></h3><p>It is conventional to construct a reciprocal lattice <span>$\{\bm{b}_j\}$</span> from a Bravais lattice <span>$\{\bm{a}_i\}$</span> such that </p><p class="math-container">\[\bm{b}_j \cdot \bm{a}_i = 2\pi\delta_{ij}\]</p><p>Then we write the momentum space variable in the reciprocal lattice vector basis and the position space variable in the real lattice vector basis</p><p class="math-container">\[\bm{k} = \sum_{j=1}^{d} k_j \bm{b}_j
\qquad
\bm{R} = \sum_{i=1}^{d} R_i \bm{a}_i\]</p><p>Without loss of generality, the <span>$k_j$</span> can be taken in the domain <span>$[0,1]$</span> and the <span>$R_i$</span> are integers.</p><p>Additionally, any coordinate transformations of <span>$\bm{k}$</span> from the Cartesian basis to the reciprocal lattice basis only modify Brillouin zone integrals by a multiplicative factor of the absolute value of the determinant of the basis transformation. To find a non-trivial example of representing a Hamiltonian in the reciprocal lattice basis, see the <a href="../../demo/#Graphene-example-with-ManyOffsetsFourierSeries">Graphene example with <code>ManyOffsetsFourierSeries</code></a>.</p><h3 id="Series-coefficients"><a class="docs-heading-anchor" href="#Series-coefficients">Series coefficients</a><a id="Series-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Series-coefficients" title="Permalink"></a></h3><p>Wannier-interpolated Hamiltonians are small matrices obtained by projecting the ab-initio Hamiltonian onto a low energy subspace, a process called downfolding. These Hamiltonians can be expressed by a Fourier series as in the sum below</p><p class="math-container">\[H(\bm{k}) = \sum_{\bm{R}} e^{i\bm{k}\cdot\bm{R}} H_{\bm{R}}\]</p><p>where the coefficients <span>$H_{\bm{R}}$</span> are the matrix-valued Fourier coefficients. Truncating the sum over <span>$\bm{R}$</span> at a modest number of modes can be done for Wannier Hamiltonians in the maximally-localized orbital basis, for which <span>$H(\bm{k})$</span> is a smooth and periodic function and thus the truncation error of its Fourier series converges super-algebraically with respect to the number of modes.</p><h3 id="Hamiltonian-recipe"><a class="docs-heading-anchor" href="#Hamiltonian-recipe">Hamiltonian recipe</a><a id="Hamiltonian-recipe-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian-recipe" title="Permalink"></a></h3><p>In model systems, a Bloch Hamiltonian can often be written down analytically. The recipe to write it as a Fourier series has two-steps</p><ol><li>Identify the real and reciprocal Bravais lattices, <span>$\{\bm{a}_i\}$</span> and <span>$\{\bm{b}_j\}$</span>, and rewrite all of the phase dependences of the Hamiltonian as <span>$\bm{k}\cdot\bm{R}$</span> with each vector in its corresponding basis, as explained above.</li><li>Factor the Hamiltonian into a linear combination of normal modes indexed by the distinct <span>$\bm{R}$</span> vectors. If the Hamiltonian is matrix-valued, this can be done one matrix element at a time.</li></ol><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.AbstractFourierSeries" href="#AutoBZ.AbstractFourierSeries"><code>AutoBZ.AbstractFourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFourierSeries{N}</code></pre><p>A supertype for Fourier series that are periodic maps <span>$\R^N \to V$</span> where <span>$V$</span> is any vector space. Typically these can be represented by <code>N</code>-dimensional arrays whose elements belong to the vector space. See the manual section on the <code>AbstractFourierSeries</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/FourierSeries.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.period" href="#AutoBZ.period"><code>AutoBZ.period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">period(f::AbstractFourierSeries{N}) where {N}</code></pre><p>Return a <code>NTuple{N}</code> whose <code>m</code>-th element corresponds to the period of <code>f</code> along its <code>m</code>-th input dimension. Typically, these values set the units of length for the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/FourierSeries.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.contract" href="#AutoBZ.contract"><code>AutoBZ.contract</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contract(f::AbstractFourierSeries{N}, x::Number, [dim=N]) where {N}</code></pre><p>Return another Fourier series of dimension <code>N-1</code> by summing over dimension <code>dim</code> of <code>f</code> with the phase factors evaluated at <code>x</code>. If <code>N=1</code>, this function should return an <code>AbstractFourierSeries{0}</code> that stores the evaluated Fourier series, but has no more input dimensions to contract.</p><p>The default of <code>dim=N</code> is motivated by preserving memory locality in Julia&#39;s column-major array format.</p><pre><code class="nohighlight hljs">contract(f::AbstractFourierSeries{N}, x::SVector{M}) where {N,M}</code></pre><p>Contract the outermost indices <code>M</code> of <code>f</code> in order of <code>last(x)</code> to <code>first(x)</code>. If <code>M&gt;N</code>, the default behavior is just to try and contract <code>M</code> indices, which will likely lead to an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/FourierSeries.jl#L26-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.value" href="#AutoBZ.value"><code>AutoBZ.value</code></a> — <span class="docstring-category">Function</span></header><section><div><p>value(::AbstractFourierSeries{0})</p><p>Return the evaluated Fourier series whose indices have all been contracted. Typically, this value has the same units as the Fourier series coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/FourierSeries.jl#L47-L52">source</a></section></article><p>Additonally, concrete subtypes of <code>AbstractFourierSeries</code> must have an element type, which they can do by extending <code>Base.eltype</code> with a method. For example, if a type <code>MyFourierSeries &lt;: AbstractFourierSeries</code> always returns <code>ComplexF64</code> outputs, then the correct <code>eltype</code> method to define would be:</p><pre><code class="language-julia hljs">Base.eltype(::Type{MyFourierSeries}) = ComplexF64</code></pre><p>The type returned should correspond to the vector space <span>$V$</span> of the output space of the Fourier series, i.e. the output of <code>value</code> should be of this type. For good performance, the <code>eltype</code> should be a concrete type and should be inferrable.</p><p>With the above implemented, several methods which define functors for <code>AbstractFourierSeries</code> allow the user (and integration routines) to evaluate the type like a function with the <code>f(x)</code> syntax.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>The concrete types listed below all implement the <code>AbstractFourierSeries</code> interface and should cover most use cases.</p><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.FourierSeries" href="#AutoBZ.FourierSeries"><code>AutoBZ.FourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FourierSeries(coeffs, period::SVector{N,Float64}) where {N}</code></pre><p>Construct a Fourier series whose coefficients are given by the coefficient array array <code>coeffs</code> whose <code>eltype</code> should support addition and scalar multiplication, and whose periodicity on the <code>i</code>th axis is given by <code>period[i]</code>. This type represents the Fourier series</p><p class="math-container">\[f(\vec{x}) = \sum_{\vec{n} \in \mathcal I} C_{\vec{n}} \exp(i2\pi\vec{k}_{\vec{n}}\cdot\overrightarrow{x})\]</p><p>where <span>$i = \sqrt{-1}$</span> is the imaginary unit, <span>$C$</span> is the array <code>coeffs</code>, <span>$\mathcal I$</span> is <code>CartesianIndices(C)</code>, <span>$\vec{n}$</span> is a <code>CartesianIndex</code> and <span>$\vec{k}_{\vec{n}}$</span> is equal to <span>$n_j/p_j$</span> in the <span>$j$</span>th position with <span>$p_j$</span> the <span>$j$</span>th element of <code>period</code>. Because of the choice to use Cartesian indices to set the phase factors, typically the indices of <code>coeffs</code> should be specified by using an <code>OffsetArray</code>.</p><pre><code class="nohighlight hljs">FourierSeries(coeffs::AbstractArray{T,N}, period::Real) where {T,N}</code></pre><p>If period is a <code>Real</code>, this constructor will infer the number of input dimensions of the Fourier series from the array dimensionality of the coefficients, and <code>period</code> will become the period of all of the dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/FourierSeries.jl#L65-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.FourierSeriesDerivative" href="#AutoBZ.FourierSeriesDerivative"><code>AutoBZ.FourierSeriesDerivative</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FourierSeriesDerivative(f::FourierSeries{N}, a::SVector{N}) where {N}</code></pre><p>Represent the differential of Fourier series <code>f</code> by a multi-index <code>a</code> of derivatives, e.g. <code>[1,2,...]</code>, whose <code>i</code>th entry represents the order of differentiation on the <code>i</code>th input dimension of <code>f</code>. Mathematically, this means</p><p class="math-container">\[\left( \prod_{j=1}^N \partial_{x_j}^{a_j} \right) f(\vec{x}) = \sum_{\vec{n} \in \mathcal I} \left( \prod_{j=1}^N (i 2\pi k_j)^{a_j} \right) C_{\vec{n}} \exp(i2\pi\vec{k}_{\vec{n}}\cdot\overrightarrow{x})\]</p><p>where <span>$\partial_{x_j}^{a_j}$</span> represents the <span>$a_j$</span>th derivative of <span>$x_j$</span>, <span>$i = \sqrt{-1}$</span> is the imaginary unit, <span>$C$</span> is the array <code>coeffs</code>, <span>$\mathcal I$</span> is <code>CartesianIndices(C)</code>, <span>$\vec{n}$</span> is a <code>CartesianIndex</code> and <span>$\vec{k}_{\vec{n}}$</span> is equal to <span>$n_j/p_j$</span> in the <span>$j$</span>th position with <span>$p_j$</span> the <span>$j$</span>th element of <code>period</code>. Because of the choice to use Cartesian indices to set the phase factors, typically the indices of <code>coeffs</code> should be specified by using an <code>OffsetArray</code>. Also, note that termwise differentiation of the Fourier series results in additional factors of <span>$i2\pi$</span> which should be anticipated for the use case. Also, note that this type can be used to represent fractional differentiation or integration by suitably choosing the <span>$a_j$</span>s.</p><p>This is a &#39;lazy&#39; representation of the derivative because instead of differentiating by computing all of the Fourier coefficients of the derivative upon constructing the object, the evaluator waits until it contracts the differentiated dimension to evaluate the new coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/FourierSeries.jl#L182-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.OffsetFourierSeries" href="#AutoBZ.OffsetFourierSeries"><code>AutoBZ.OffsetFourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OffsetFourierSeries(f::AbstractFourierSeries{N}, q::SVector{N,Float64}) where {N}</code></pre><p>Represent a Fourier series whose argument is offset by the vector <span>$\vec{q}$</span> and evaluates it as <span>$f(\vec{x}-\vec{q})$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/FourierSeries.jl#L311-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.ManyFourierSeries" href="#AutoBZ.ManyFourierSeries"><code>AutoBZ.ManyFourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManyFourierSeries(fs::AbstractFourierSeries{N}...) where {N}</code></pre><p>Represents a tuple of Fourier series of the same dimension and periodicity and contracts them all simultaneously.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/FourierSeries.jl#L326-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.ManyOffsetsFourierSeries" href="#AutoBZ.ManyOffsetsFourierSeries"><code>AutoBZ.ManyOffsetsFourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManyOffsetsFourierSeries(f, qs..., [origin=true])</code></pre><p>Represent a Fourier series evaluated at many different points, and contract them all simultaneously, returning them in the order the <code>qs</code> were passed, i.e. <code>(f(x-qs[1]), f(x-qs[2]), ...)</code> The <code>origin</code> keyword decides whether or not to evaluate <span>$f$</span> without an offset, and if <code>origin</code> is true, the value of <span>$f$</span> evaluated without an offset will be returned in the first position of the output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/FourierSeries.jl#L345-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.BandEnergyVelocity" href="#AutoBZ.BandEnergyVelocity"><code>AutoBZ.BandEnergyVelocity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BandEnergyVelocity{kind}(H::FourierSeries{N}, V::ManyFourierSeries{N}) where {kind,N}
BandEnergyVelocity(H::FourierSeries{N}; kind=:orbital) where N</code></pre><p>The bottom constructor takes a Fourier series representing the Hamiltonian and also evaluates the band velocities so that the return value after all the dimensions are contracted is a tuple containing <code>(H, v₁, v₂, ..., vₙ)</code>. The band velocities are defined by dipole operators <span>$\nu_{\alpha} = \frac{1}{\hbar} \partial_{k_{\alpha}} H$</span> where <span>$k_{\alpha}$</span> is one of three input dimensions of <span>$H$</span> and <span>$\hbar=1$</span>. Effectively, this type evaluates <code>H</code> and its gradient. Note that differentiation by <span>$k$</span> changes the units to have an additional dimension of length and a factor of <span>$2\pi$</span>, so if <span>$H$</span> has dimensions of energy, <span>$\nu$</span> has dimensions of energy times length. The caller is responsible for transforming the units of the velocity (i.e. <span>$\hbar$</span>) if they want other units, which can usually be done as a post-processing step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/band_velocities.jl#L34-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.BandEnergyBerryVelocity" href="#AutoBZ.BandEnergyBerryVelocity"><code>AutoBZ.BandEnergyBerryVelocity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BandEnergyBerryVelocity{kind}(H::BandEnergyVelocity{Val{:orbital}(),N}, A::ManyFourierSeries{N}) where {kind,N}
BandEnergyBerryVelocity(H::BandEnergyVelocity{kind,N}, A::ManyFourierSeries{N,&lt;:NTuple{N}}) where {kind,N}
BandEnergyBerryVelocity(H::FourierSeries, A; kind=:orbital)</code></pre><p>This constructor takes a <code>FourierSeries</code>, <code>H</code>, representing the Hamiltonian and also a <code>ManyFourierSeries</code>, <code>A</code>, representing the gradient of the Berry connection, and evaluates modified band velocities so that the return value after all the dimensions are contracted is a tuple containing <code>(H, ṽ₁, ṽ₂, ..., ṽₙ)</code>. The modified band velocities are defined by</p><p class="math-container">\[\tilde{\nu}_{\alpha} = \frac{1}{\hbar} \partial_{k_{\alpha}} H -
\frac{i}{\hbar} [H,(A_{\alpha} + A_{\alpha}^{\dagger})/2]\]</p><p>where <span>$k_{\alpha}$</span> is one of three input dimensions of <span>$H$</span> and <span>$\hbar=1$</span>. Effectively, this type evaluates the Hamiltonian and its gradient modified by a commutator of the Hamiltonian with the gradient of the Berry connection. Note that differentiation by <span>$k$</span> changes the units to have an additional dimension of length and a factor of <span>$2\pi$</span>, so if <span>$H$</span> has dimensions of energy, <span>$\nu$</span> has dimensions of energy times length. The caller is responsible for transforming the units of the velocity (i.e. <span>$\hbar$</span>) if they want other units, which can usually be done as a post-processing step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/band_velocities.jl#L79-L101">source</a></section></article><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.contract-Tuple{AbstractFourierSeries}" href="#AutoBZ.contract-Tuple{AbstractFourierSeries}"><code>AutoBZ.contract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contract(f::FourierSeries{N}, x::Number, [dim=N]) where N</code></pre><p>Contract index <code>dim</code> of the coefficients of <code>f</code> at the spatial point <code>x</code>. The default <code>dim</code> is the outermost dimension to preserve memory locality.</p><p>There is a special optimization when <code>dim=N</code>, <code>size(f.coeffs,dim)=2M+1</code> for an integer <code>M</code>, and <code>axes(f.coeffs,dim)=-M:M</code> that evaluates the Fourier series by recurrence. In this case, <code>f.coeffs</code> must be an <code>OffsetArray</code> with odd axis lengths and indices that are odd about the center of the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/FourierSeries.jl#L97-L107">source</a></section><section><div><pre><code class="nohighlight hljs">contract(f::FourierSeriesDerivative{N}, x::Number, [dim=N]) where {N}</code></pre><p>Contract index <code>dim</code> of the coefficients of <code>f</code> at the spatial point <code>x</code>. The default <code>dim</code> is the outermost dimension to preserve memory locality.</p><p>There is a special optimization when <code>dim=N</code>, <code>size(f.f.coeffs,dim)=2M+1</code> for an integer <code>M</code>, and <code>axes(f.f.coeffs,dim)=-M:M</code> that evaluates the Fourier series by recurrence. In this case, <code>f.f.coeffs</code> must be an <code>OffsetArray</code> with odd axis lengths and indices that are odd about the center of the array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/FourierSeries.jl#L214-L224">source</a></section></article><h1 id="Optimized-3D-evaluators"><a class="docs-heading-anchor" href="#Optimized-3D-evaluators">Optimized 3D evaluators</a><a id="Optimized-3D-evaluators-1"></a><a class="docs-heading-anchor-permalink" href="#Optimized-3D-evaluators" title="Permalink"></a></h1><p>For the use-case of Wannier90 calculations, the following Fourier series evaluators are optimized to improve performance by reducing allocations.</p><h2 id="Interface-2"><a class="docs-heading-anchor" href="#Interface-2">Interface</a><a class="docs-heading-anchor-permalink" href="#Interface-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.AbstractFourierSeries3D" href="#AutoBZ.AbstractFourierSeries3D"><code>AutoBZ.AbstractFourierSeries3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFourierSeries3D &lt;: AbstractFourierSeries{3}</code></pre><p>An abstract subtype of <code>AbstractFourierSeries{3}</code> representing in-place Fourier series evaluators</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/fourier3d.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.contract!" href="#AutoBZ.contract!"><code>AutoBZ.contract!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contract!(f::AbstractFourierSeries3D, x::Number, dim::Int)</code></pre><p>An in-place version of <code>contract</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/fourier3d.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.shift!" href="#AutoBZ.shift!"><code>AutoBZ.shift!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shift!(f::FourierSeries3D, λ::Number)</code></pre><p>Modifies and returns <code>f</code> such that it returns <code>f - λ*I</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/fourier3d.jl#L157-L161">source</a></section></article><h2 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.FourierSeries3D" href="#AutoBZ.FourierSeries3D"><code>AutoBZ.FourierSeries3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FourierSeries3D(coeffs::Array{T,3}, [period=(1.0, 1.0, 1.0)])</code></pre><p>This type is an <code>AbstractFourierSeries{3}</code> designed for in-place evaluation of <code>FourierSeries</code>, and unlike <code>FourierSeries</code> is specialized for 3D Fourier series and does not allocate a new array every time <code>contract</code> is called on it. This type stores the intermediate arrays used in a calculation and assumes that the size of <code>coeffs</code> on each axis is odd because it treats the zeroth harmonic as the center of the array (i.e. <code>(size(coeffs) .÷ 2) .+ 1</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/fourier3d.jl#L112-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.BandEnergyVelocity3D" href="#AutoBZ.BandEnergyVelocity3D"><code>AutoBZ.BandEnergyVelocity3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BandEnergyVelocity3D(coeffs, [period=(1.0,1.0,1.0), kind=:full])
BandEnergyVelocity3D(H::FourierSeries3D, [kind=:full])</code></pre><p>The in-place equivalent of <code>BandEnergyVelocity</code> for 3D series evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/fourier3d.jl#L169-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.BandEnergyBerryVelocity3D" href="#AutoBZ.BandEnergyBerryVelocity3D"><code>AutoBZ.BandEnergyBerryVelocity3D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BandEnergyBerryVelocity3D(H::FourierSeries3D{TH,0,0,0}, Ax::FourierSeries3D{TA,0,0,0}, Ay::FourierSeries3D{TA,0,0,0}, Az::FourierSeries3D{TA,0,0,0}, [kind=:full]) where {TH,TA}</code></pre><p>The in-place equivalent of <code>BandEnergyBerryVelocity</code> for 3D series evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/fourier3d.jl#L239-L243">source</a></section></article><h2 id="Methods-2"><a class="docs-heading-anchor" href="#Methods-2">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-2" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AutoBZ.contract!(::AutoBZ.AbstractFourierSeries3D)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.fourier_kernel!" href="#AutoBZ.fourier_kernel!"><code>AutoBZ.fourier_kernel!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fourier_kernel!(r::Array{T,N-1}, C::Array{T,N}, x, ξ, [::Val{a}=Val{0}()]) where {T,N,a}</code></pre><p>Contract the outermost index of array <code>C</code> and write it to the array <code>r</code>. Assumes the size of the outermost dimension of <code>C</code> is <code>2m+1</code> and sums the coefficients</p><p class="math-container">\[r_{i_{1},\dots,i_{N-1}} = \sum_{i_{N}=-m}^{m} C_{i_{1},\dots,i_{N-1},i_{N}+m+1} (i2\pi\xi i_{N})^{a} \exp(i2\pi\xi x i_{N})\]</p><p>Hence this represents evaluation of a Fourier series with <code>m</code> modes. The parameter <code>a</code> represents the order of derivative of the Fourier series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/e27a19dc214ab6c08526a7e45243103b491dbc49/src/fourier3d.jl#L30-L40">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../core/integration_limits/">« Integration limits</a><a class="docs-footer-nextpage" href="../integrands/">Integrands »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 9 January 2023 03:12">Monday 9 January 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
