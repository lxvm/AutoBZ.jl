<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integrands · AutoBZ.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">AutoBZ.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Core</span><ul><li><a class="tocitem" href="../../core/adaptive_integration/">Adaptive integration</a></li><li><a class="tocitem" href="../../core/equispace_integration/">Equispace integration</a></li><li><a class="tocitem" href="../../core/integration_limits/">Integration limits</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../fourier/">Fourier series</a></li><li class="is-active"><a class="tocitem" href>Integrands</a><ul class="internal"><li><a class="tocitem" href="#User-defined"><span>User-defined</span></a></li><li><a class="tocitem" href="#Pre-defined"><span>Pre-defined</span></a></li></ul></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../self_energy/">Self energies</a></li></ul></li><li><a class="tocitem" href="../../jobs/">Jobs</a></li><li><a class="tocitem" href="../../adaptinterp/">AdaptChebInterp</a></li><li><a class="tocitem" href="../../equiinterp/">EquiBaryInterp</a></li><li><a class="tocitem" href="../../demo/">Demos</a></li><li><a class="tocitem" href="../../workflow/">Workflow</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Integrands</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Integrands</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lxvm/AutoBZ.jl/blob/main/docs/src/pages/man/integrands.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Integrands"><a class="docs-heading-anchor" href="#Integrands">Integrands</a><a id="Integrands-1"></a><a class="docs-heading-anchor-permalink" href="#Integrands" title="Permalink"></a></h1><h2 id="User-defined"><a class="docs-heading-anchor" href="#User-defined">User-defined</a><a id="User-defined-1"></a><a class="docs-heading-anchor-permalink" href="#User-defined" title="Permalink"></a></h2><p>For integrands that can be evaluated by Wannier interpolation, the following data are necessary to define an integrand:</p><ul><li>the integrand evaluator</li><li>a Fourier series</li><li>additional parameters for the evaluator</li></ul><p>Consider implementing custom integrands using the generic template type <a href="#AutoBZ.WannierIntegrand"><code>AutoBZ.WannierIntegrand</code></a> that is compatible with all of the adaptive and equispace integration routines.</p><div class="admonition is-success"><header class="admonition-header">Optimizing equispace integration</header><div class="admonition-body"><p>Unlike for adaptive integration, the caller is responsible for passing pre-computed grid values to the equispace integration routines, which is explained in the documentation for <a href="../../core/equispace_integration/#Equispace-integration">Equispace integration</a> and <a href="../../core/equispace_integration/#AutoBZ.AutoBZCore.equispace_pre_eval"><code>AutoBZ.equispace_pre_eval</code></a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Mixing adaptive and equispace integrals</header><div class="admonition-body"><p>While it is possible to perform an integral where some variables are integrated adaptively and others are integrated uniformly, this guide will not explain how to do this. However, an example implementation of this is  <a href="#AutoBZ.AutoEquispaceKineticIntegrand"><code>AutoBZ.AutoEquispaceKineticIntegrand</code></a>.</p></div></div><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.WannierIntegrand" href="#AutoBZ.WannierIntegrand"><code>AutoBZ.WannierIntegrand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WannierIntegrand(f, s::AbstractFourierSeries, p)</code></pre><p>A type generically representing an integrand <code>f</code> whose entire dependence on the variables of integration is in a Fourier series <code>s</code>, and which may also accept some input parameters <code>p</code>, which are preferrably contained in a tuple. The caller must be aware that their function, <code>f</code>, will be called at many evaluation points, <code>x</code>, in the following way: <code>f(s(x), p...)</code>. Therefore the caller is expected to know the type of <code>s(x)</code> (hint: <code>eltype(s)</code>) and the layout of the parameters in the tuple <code>p</code>. Additionally, <code>f</code> is assumed to be type-stable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/1ca21008d6e31d27b3705ed51e31d2bf2ec614db/src/integrands.jl#L3-L13">source</a></section></article><h3 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AutoBZ.pre_eval_contract(::AutoBZ.WannierIntegrand,::Any,::Any)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Pre-defined"><a class="docs-heading-anchor" href="#Pre-defined">Pre-defined</a><a id="Pre-defined-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-defined" title="Permalink"></a></h2><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.DOSIntegrand" href="#AutoBZ.DOSIntegrand"><code>AutoBZ.DOSIntegrand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DOSIntegrand(H, ω, Σ)
DOSIntegrand(H, M)</code></pre><p>A type whose integral gives the density of states.</p><p class="math-container">\[D(ω) = -{\pi}^{-1} \int_{\text{BZ}} dk \operatorname{Tr}[\Im[{((\omega + \mu) I - H(k) - \Sigma(\omega))}^{-1}]]\]</p><p>This type works with both adaptive and equispace integration routines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/1ca21008d6e31d27b3705ed51e31d2bf2ec614db/src/integrands.jl#L29-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.TransportIntegrand" href="#AutoBZ.TransportIntegrand"><code>AutoBZ.TransportIntegrand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TransportIntegrand(HV, Σ, ω₁, ω₂)
TransportIntegrand(HV, Mω₁, Mω₂)</code></pre><p>A type whose integral over the BZ gives the transport distribution.</p><p class="math-container">\[\Gamma_{\alpha\beta}(\omega_1, \omega_2) = \int_{\text{BZ}} dk \operatorname{Tr}[\nu_\alpha(k) A(k,\omega_1) \nu_\beta(k) A(k, \omega_2)]\]</p><p>This type works with both adaptive and equispace integration routines. Based on <a href="https://triqs.github.io/dft_tools/latest/guide/transport.html">TRIQS</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/1ca21008d6e31d27b3705ed51e31d2bf2ec614db/src/integrands.jl#L78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.KineticIntegrand" href="#AutoBZ.KineticIntegrand"><code>AutoBZ.KineticIntegrand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KineticIntegrand(HV, Σ, β, n, [Ω=0])</code></pre><p>A function whose integral over the BZ and the frequency axis gives the kinetic coefficient. Mathematically, this computes</p><p class="math-container">\[A_{n,\alpha\beta}(\Omega) = \int_{-\infty}^{\infty} d \omega (\beta\omega)^{n} \frac{f(\omega) - f(\omega+\Omega)}{\Omega} \Gamma_{\alpha\beta}(\omega, \omega+\Omega)\]</p><p>where <span>$f(\omega) = (e^{\beta\omega}+1)^{-1}$</span> is the Fermi distriubtion. Use this type only for adaptive integration and order the limits so that the integral over the Brillouin zone is the outer integral and the frequency integral is the inner integral. Based on <a href="https://triqs.github.io/dft_tools/latest/guide/transport.html">TRIQS</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/1ca21008d6e31d27b3705ed51e31d2bf2ec614db/src/integrands.jl#L108-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.EquispaceKineticIntegrand" href="#AutoBZ.EquispaceKineticIntegrand"><code>AutoBZ.EquispaceKineticIntegrand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EquispaceKineticIntegrand(A::KineticIntegrand, l, npt, pre::Vector{Tuple{eltype(A.HV),Int}})
EquispaceKineticIntegrand(A, l, npt)</code></pre><p>This type represents an <code>KineticIntegrand</code>, <code>A</code> integrated adaptively in frequency and with equispace integration over the Brillouin zone with a fixed number of grid points <code>npt</code>. The argument <code>l</code> should be an <code>IntegrationLimits</code> for just the Brillouin zone. This type should be called by an adaptive integration routine whose limits of integration are only the frequency variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/1ca21008d6e31d27b3705ed51e31d2bf2ec614db/src/integrands.jl#L141-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.AutoEquispaceKineticIntegrand" href="#AutoBZ.AutoEquispaceKineticIntegrand"><code>AutoBZ.AutoEquispaceKineticIntegrand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoEquispaceKineticIntegrand(A, l, atol, rtol, npt1, pre1, npt2, pre2)
AutoEquispaceKineticIntegrand(A, l, atol, rtol; npt1=0, pre1=Tuple{eltype(A.HV),Int}[], npt2=0,pre2=Tuple{eltype(σ.HV),Int}[])</code></pre><p>This type represents an <code>KineticIntegrand</code>, <code>A</code> integrated adaptively in frequency and with equispace integration over the Brillouin zone with a number of grid points necessary to meet the maximum of the tolerances given by <code>atol</code> and <code>rtol</code>. The argument <code>l</code> should be an <code>IntegrationLimits</code> for just the Brillouin zone. This type should be called by an adaptive integration routine whose limits of integration are only the frequency variable.</p><p>The keyword arguments, which are just passed to <a href="../../core/equispace_integration/#AutoBZ.AutoBZCore.automatic_equispace_integration"><code>automatic_equispace_integration</code></a>, are:</p><ul><li><code>pre1</code>: a <code>Vector</code> containing tuples of the evaluated Hamiltonian + band   velocities and integration weights</li><li><code>npt1</code>: an integer that should be equivalent to <code>length(pre1)</code></li><li><code>pre2</code>: a <code>Vector</code> containing tuples of the evaluated Hamiltonian + band   velocities and integration weights on a more refined grid than <code>pre1</code></li><li><code>npt2</code>: an integer that should be equivalent to <code>length(pre)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/1ca21008d6e31d27b3705ed51e31d2bf2ec614db/src/integrands.jl#L169-L188">source</a></section></article><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AutoBZ.dos_integrand</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AutoBZ.spectral_function</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.band_velocities" href="#AutoBZ.band_velocities"><code>AutoBZ.band_velocities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">band_velocities(::Type{Val{kind}}, H, vs...) where kind</code></pre><p>Transform the band velocities according to the following values of <code>kind</code></p><ul><li><code>:orbital</code>: return the orbital-basis velocity (i.e. null-op, stays in Wannier gauge)</li><li><code>:band</code>: return the band-basis velocity (transforms to Hamiltonian gauge)</li><li><code>:intraband</code>: return only the diagonal of the band velocity (Hamiltonian gauge)</li><li><code>:interband</code>: return only the off-diagonal terms of the band velocity (Hamiltonian gauge)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/1ca21008d6e31d27b3705ed51e31d2bf2ec614db/src/band_velocities.jl#L3-L11">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AutoBZ.transport_integrand</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AutoBZ.kinetic_integrand</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.fermi" href="#AutoBZ.fermi"><code>AutoBZ.fermi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fermi(x)</code></pre><p>Evaluates a Fermi distribution with unitless input</p><p class="math-container">\[f(x) = \frac{1}{e^{x}+1}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/1ca21008d6e31d27b3705ed51e31d2bf2ec614db/src/fermi.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.fermi′" href="#AutoBZ.fermi′"><code>AutoBZ.fermi′</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fermi′(x)</code></pre><p>Evaluates a first derivative of the Fermi distribution with unitless input</p><p class="math-container">\[\partial_{x} f(x) = -\frac{1}{2(\cosh(x)+1)}\]</p><p>Note that the analytic expression above can be rewritten many ways using hypertrigonometric identities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/1ca21008d6e31d27b3705ed51e31d2bf2ec614db/src/fermi.jl#L16-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.fermi_window" href="#AutoBZ.fermi_window"><code>AutoBZ.fermi_window</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fermi_window(x, y)</code></pre><p>Evaluates a unitless window function with unitless inputs determined by the Fermi distribution <span>$f$</span> and defined by</p><p class="math-container">\[\chi(x, y) = \frac{f(x) - f(x+y)}{y}\]</p><p>In the case <code>y==0</code> then this simplifies to the derivative of the Fermi distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/1ca21008d6e31d27b3705ed51e31d2bf2ec614db/src/fermi.jl#L31-L40">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AutoBZ.cosh_ratio</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>AutoBZ.EXP_P1_SMALL_X</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fourier/">« Fourier series</a><a class="docs-footer-nextpage" href="../interfaces/">Interfaces »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 9 January 2023 21:37">Monday 9 January 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
