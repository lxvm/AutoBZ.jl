<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integrands · AutoBZ.jl</title><meta name="title" content="Integrands · AutoBZ.jl"/><meta property="og:title" content="Integrands · AutoBZ.jl"/><meta property="twitter:title" content="Integrands · AutoBZ.jl"/><meta name="description" content="Documentation for AutoBZ.jl."/><meta property="og:description" content="Documentation for AutoBZ.jl."/><meta property="twitter:description" content="Documentation for AutoBZ.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">AutoBZ.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../workflow/">Getting started</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../demo/dos/">Density of states</a></li><li><a class="tocitem" href="../../demo/density/">Electron density</a></li><li><a class="tocitem" href="../../demo/oc/">Optical conductivity</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/fourier/">Fourier series</a></li><li><a class="tocitem" href="../self_energy/">Self energies</a></li><li class="is-active"><a class="tocitem" href>Integrands</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../../man/internal/">Internal</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Integrands</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Integrands</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lxvm/AutoBZ.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lxvm/AutoBZ.jl/blob/main/docs/src/pages/app/integrands.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Integrands"><a class="docs-heading-anchor" href="#Integrands">Integrands</a><a id="Integrands-1"></a><a class="docs-heading-anchor-permalink" href="#Integrands" title="Permalink"></a></h1><p>AutoBZ.jl defines integrands to compute various physical observables, including the density of states, electronic density, and optical conductivity. To define new observables, visit <a href="https://lxvm.github.io/AutoBZCore.jl/dev/">AutoBZCore.jl</a> for general-purpose interfaces to define integrals.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.GlocSolver" href="#AutoBZ.GlocSolver"><code>AutoBZ.GlocSolver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GlocSolver(Σ, h, bz, bzalg, [linalg=JLInv()]; ω, μ=0, kws...)</code></pre><p>Green&#39;s function integrands accepting a self energy Σ that can either be a matrix or a function of ω (see the self energy section of the documentation for examples) Additional keywords are passed directly to the solver. Use <code>AutoBZ.update_gloc!(solver; ω, μ=0)</code> to change the parameters. The <code>linalg</code> argument sets the linear system solver</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/GreensSolver.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.TrGlocSolver" href="#AutoBZ.TrGlocSolver"><code>AutoBZ.TrGlocSolver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TrGlocSolver(Σ, h, bz, bzalg, [trinvalg=JLTrInv()]; ω, μ=0, kws...)</code></pre><p>Green&#39;s function integrands accepting a self energy Σ that can either be a matrix or a function of ω (see the self energy section of the documentation for examples) Additional keywords are passed directly to the solver. Use <code>AutoBZ.update_trgloc!(solver; ω, μ=0)</code> to change the parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/GreensSolver.jl#L60-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.DOSSolver" href="#AutoBZ.DOSSolver"><code>AutoBZ.DOSSolver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DOSSolver(Σ, h, bz, bzalg, [trinvalg=JLTrInv()]; ω, μ=0, kws...)</code></pre><p>Green&#39;s function integrands accepting a self energy Σ that can either be a matrix or a function of ω (see the self energy section of the documentation for examples) Additional keywords are passed directly to the solver. Use <code>AutoBZ.update_dos!(solver; ω, μ=0)</code> to change the parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/GreensSolver.jl#L80-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.TransportFunctionSolver" href="#AutoBZ.TransportFunctionSolver"><code>AutoBZ.TransportFunctionSolver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TransportFunctionSolver(hv::AbstractVelocityInterp, bz, bzalg; β, μ=0, kws...)</code></pre><p>A function whose integral over the BZ gives the transport function, proportional to the Drude weight,</p><p class="math-container">\[D_{\alpha\beta} = \sum_{nm} \int_{\text{BZ}} dk f&#39;(\epsilon_{nk}-\mu) \nu_{n\alpha}(k) \nu_{m\beta}(k)\]</p><p>where <span>$f(\omega) = (e^{\beta\omega}+1)^{-1}$</span> is the Fermi distribution. Additional keywords are passed directly to the solver. Use <code>AutoBZ.update_tf!(solver; β, μ=0)</code> to update the parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/TransportFunctionSolver.jl#L15-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.TransportDistributionSolver" href="#AutoBZ.TransportDistributionSolver"><code>AutoBZ.TransportDistributionSolver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TransportDistributionSolver(Σ, hv::AbstractVelocityInterp, bz, bzalg; ω₁, ω₂, μ=0, kws...)</code></pre><p>A function whose integral over the BZ gives the transport distribution</p><p class="math-container">\[\Gamma_{\alpha\beta}(\omega_1, \omega_2) = \int_{\text{BZ}} dk \operatorname{Tr}[\nu_\alpha(k) A(k,\omega_1) \nu_\beta(k) A(k, \omega_2)]\]</p><p>Based on <a href="https://triqs.github.io/dft_tools/latest/guide/transport.html">TRIQS</a>. Additional keywords are passed directly to the solver. Use <code>AutoBZ.update_td!(solver; ω₁, ω₂, μ=0)</code> to update the parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/TransportDistributionSolver.jl#L138-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.KineticCoefficientSolver" href="#AutoBZ.KineticCoefficientSolver"><code>AutoBZ.KineticCoefficientSolver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KineticCoefficientSolver(hv, bz, bzalg, Σ, [fdom,] falg, [linalg=JLInv()]; n, β, Ω, μ=0, scale_inner=inv(abs(det(bz.B))*nsyms(bz)), kws...)
KineticCoefficientSolver(Σ, [fdom,] falg, hv, bz, bzalg, [linalg=JLInv()]; n, β, Ω, μ=0, scale_inner=1, kws...)</code></pre><p>A solver for kinetic coefficients. The two orderings of arguments correspond to orders of integration. (The outer integral appears first in the argument list.) Use <code>AutoBZ.update_kc!(solver; β, Ω, μ, n)</code> to change parameters. <code>linalg</code> selects the algorithm to compute the resolvent.</p><p>Mathematically, this computes</p><p class="math-container">\[A_{n,\alpha\beta}(\Omega) = \int_{-\infty}^{\infty} d \omega (\beta\omega)^{n} \frac{f(\omega) - f(\omega+\Omega)}{\Omega} \Gamma_{\alpha\beta}(\omega, \omega+\Omega)\]</p><p>where <span>$f(\omega) = (e^{\beta\omega}+1)^{-1}$</span> is the Fermi distriubtion. Based on <a href="https://triqs.github.io/dft_tools/latest/guide/transport.html">TRIQS</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/KineticCoefficientSolver.jl#L108-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.OpticalConductivitySolver" href="#AutoBZ.OpticalConductivitySolver"><code>AutoBZ.OpticalConductivitySolver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OpticalConductivitySolver(hv, bz, bzalg, Σ, [fdom,] falg, [linalg=JLInv()]; β, Ω, μ=0, scale_inner=inv(abs(det(bz.B))*nsyms(bz)), kws...)
OpticalConductivitySolver(Σ, [fdom,] falg, hv, bz, bzalg, [linalg=JLInv()]; β, Ω, μ=0, scale_inner=1, kws...)</code></pre><p>A solver for the optical conductivity. For details see <a href="#AutoBZ.KineticCoefficientSolver"><code>KineticCoefficientSolver</code></a> and note that by default the parameter <code>n=0</code>. Use <code>AutoBZ.update_oc!(solver; β, Ω, μ)</code> to change parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/KineticCoefficientSolver.jl#L139-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.ElectronDensitySolver" href="#AutoBZ.ElectronDensitySolver"><code>AutoBZ.ElectronDensitySolver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ElectronDensitySolver(h, bz, bzalg, Σ, [fdom,] falg, [trinvalg=JLTrInv()]; β, μ=0, scale_inner=inv(abs(det(bz.B))*nsyms(bz)), kws...)
ElectronDensitySolver(Σ, [fdom,] falg, h, bz, bzalg, [trinvalg=JLTrInv()]; β, μ=0, scale_inner=inv(oneunit(μ)), kws...)</code></pre><p>A solver for the electron density. The two orderings of arguments correspond to orders of integration. (The outer integral appears first in the argument list.) Use <code>AutoBZ.update_density!(solver; β, μ=0)</code>. If <code>fdom</code> is not specified the default is <code>(AutoBZ.lb(Σ), AutoBZ.ub(Σ))</code>. The <code>scale_inner</code> keyword is used to rescale inner integration tolerances and can be estimated to reduce computational effort, although the default will be robust. <code>trinvalg</code> may be specified as an algorithm for the inverse trace calculation.</p><p>Mathematically, this computes the electron density:</p><p class="math-container">\[n(\mu) = \int_{-\infty}^{\infty} d \omega f(\omega) \operatorname{DOS}(\omega+\mu)\]</p><p>where <span>$f(\omega) = (e^{\beta\omega}+1)^{-1}$</span> is the Fermi distriubtion. To get the density/number of electrons, multiply the result of this integral by <code>n_sp/det(bz.B)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/ElectronDensitySolver.jl#L88-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AuxTransportDistributionSolver" href="#AutoBZ.AuxTransportDistributionSolver"><code>AutoBZ.AuxTransportDistributionSolver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AuxTransportDistributionSolver([auxfun], Σ, hv::AbstractVelocityInterp, bz, bzalg; ω₁, ω₂, μ=0, kws...)</code></pre><p>A function whose integral over the BZ gives the transport distribution</p><p class="math-container">\[\Gamma_{\alpha\beta}(\omega_1, \omega_2) = \int_{\text{BZ}} dk \operatorname{Tr}[\nu_\alpha(k) A(k,\omega_1) \nu_\beta(k) A(k, \omega_2)]\]</p><p>Based on <a href="https://triqs.github.io/dft_tools/latest/guide/transport.html">TRIQS</a>. Additional keywords are passed directly to the solver. Use <code>AutoBZ.update_auxtd!(solver; ω₁, ω₂, μ)</code> to update the parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/TransportDistributionSolver.jl#L154-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AuxKineticCoefficientSolver" href="#AutoBZ.AuxKineticCoefficientSolver"><code>AutoBZ.AuxKineticCoefficientSolver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AuxKineticCoefficientSolver([auxfun], hv, bz, bzalg, Σ, [fdom,] falg, [linalg=JLInv()]; n, β, Ω, μ=0, scale_inner=inv(abs(det(bz.B))*nsyms(bz)), kws...)
AuxKineticCoefficientSolver([auxfun], Σ, [fdom,] falg, hv, bz, bzalg, [linalg=JLInv()]; n, β, Ω, μ=0, scale_inner=1, kws...)</code></pre><p>A solver for kinetic coefficients using an auxiliary integrand. The two orderings of arguments correspond to orders of integration. (The outer integral appears first in the argument list.) The default <code>auxfun</code> is the sum of the Green&#39;s functions. Use <code>AutoBZ.update_auxkc!(solver; β, Ω, μ, n)</code> to change parameters. If <code>fdom</code> is not specified the default is <code>(AutoBZ.lb(Σ), AutoBZ.ub(Σ))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/KineticCoefficientSolver.jl#L151-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AuxOpticalConductivitySolver" href="#AutoBZ.AuxOpticalConductivitySolver"><code>AutoBZ.AuxOpticalConductivitySolver</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AuxOpticalConductivitySolver([auxfun], hv, bz, bzalg, Σ, [fdom,] falg, [linalg=JLInv()]; β, Ω, μ=0, scale_inner=inv(abs(det(bz.B))*nsyms(bz)), kws...)
AuxOpticalConductivitySolver([auxfun], Σ, [fdom,] falg, hv, bz, bzalg, [linalg=JLInv()]; β, Ω, μ=0, scale_inner=1, kws...)</code></pre><p>A solver for the optical conductivity. For details see <a href="#AutoBZ.AuxKineticCoefficientSolver"><code>AuxKineticCoefficientSolver</code></a> and note that by default the parameter <code>n=0</code>. Use <code>AutoBZ.update_auxoc!(solver; β, Ω, μ)</code> to change parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/KineticCoefficientSolver.jl#L190-L197">source</a></section></article><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.fermi" href="#AutoBZ.fermi"><code>AutoBZ.fermi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fermi(β, ω)
fermi(x)</code></pre><p>Evaluates a Fermi distribution with unitless input</p><p class="math-container">\[f(x) = \frac{1}{e^{x}+1}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/fermi.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.fermi′" href="#AutoBZ.fermi′"><code>AutoBZ.fermi′</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fermi′(x)</code></pre><p>Evaluates a first derivative of the Fermi distribution with unitless input</p><p class="math-container">\[\partial_{x} f(x) = -\frac{1}{2(\cosh(x)+1)}\]</p><p>Note that the analytic expression above can be rewritten many ways using hypertrigonometric identities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/fermi.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.fermi_window" href="#AutoBZ.fermi_window"><code>AutoBZ.fermi_window</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fermi_window(β, ω, Ω)
fermi_window(x, y)</code></pre><p>Evaluates a unitless window function with unitless inputs determined by the Fermi distribution <span>$f$</span> and defined by</p><p class="math-container">\[\chi(x, y) = \frac{f(x) - f(x+y)}{y}\]</p><p>In the case <code>y==0</code> then this simplifies to the derivative of the Fermi distribution.</p><p>See also <a href="#AutoBZ.fermi"><code>fermi</code></a> and <a href="#AutoBZ.fermi′"><code>fermi′</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/fermi.jl#L36-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.fermi_window_limits" href="#AutoBZ.fermi_window_limits"><code>AutoBZ.fermi_window_limits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fermi_window_limits(Ω, β [; atol=0.0, rtol=1e-20])</code></pre><p>Returns limits <code>(a,b)</code> over ω restricted to the interval where the Fermi window is larger than <code>max(atol,rtol*fermi_window(0,β*Ω))</code>. Choosing <code>atol</code> and <code>rtol</code> wisely is important to integrating the entire region of interest, since this is a truncation of an infinite interval, and should be tested for convergence.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/d71a5de0b105d5f491541a22b708ddc1e36012e1/src/fermi.jl#L98-L105">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../self_energy/">« Self energies</a><a class="docs-footer-nextpage" href="../interfaces/">Interfaces »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Thursday 29 August 2024 21:05">Thursday 29 August 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
