var documenterSearchIndex = {"docs":
[{"location":"pages/workflow/#Workflow","page":"Workflow","title":"Workflow","text":"","category":"section"},{"location":"pages/workflow/#Installation","page":"Workflow","title":"Installation","text":"","category":"section"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"To install Julia, download the latest binaries from https://julialang.org/ and add them to your PATH.","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"Since AutoBZ.jl is an unregistered Julia package, adding it to a Julia environment must be done with the repository URL and Julia's package manager","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/lxvm/AutoBZ.jl.git\")","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"Or to download the repository with SSH use the git link: git@github.com:lxvm/AutoBZ.jl.git","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"For users interested in keeping up to date with the latest developments in the package, the next section also describes a convenient setup.","category":"page"},{"location":"pages/workflow/#Development-installation","page":"Workflow","title":"Development installation","text":"","category":"section"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"The following workflow sets up an environment that makes it convenient to run AutoBZ either locally or on a cluster, as well as to update the repository. First, create a working directory for this project that will also serve as the home of its Julia environment","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"$ mkdir workdir\n$ cd workdir\n$ julia --project=. # start an interactive session in the <workdir> environment","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"In the Julia session, adding AutoBZ to the environment while cloning the repository to the working directory can be done interactively as shown below","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"julia> ] # enters the package manager\n(workdir) pkg> develop --local https://github.com/lxvm/AutoBZ.jl.git # clones repo into ./dev/AutoBZ","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"An equivalent shell script to set up the environment is the following","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"$ mkdir dev\n$ git clone https://github.com/lxvm/AutoBZ.jl.git dev/AutoBZ\n$ julia -e 'import Pkg; Pkg.activate(\".\"); Pkg.develop(path=\"dev/AutoBZ\")'","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"Updating the repository can now be done with cd dev/AutoBZ and git pull.","category":"page"},{"location":"pages/workflow/#Running-jobs","page":"Workflow","title":"Running jobs","text":"","category":"section"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"Users of AutoBZ who would like to use the AutoBZ.Jobs module will find scripts in the demos folder of the repository titled OC_calculation_... that demonstrate how to use those scripts. From the working directory configured above, the scripts from the demos folder can be copied back, as well any coefficient files for the calculations that will be run.","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"julia> ; # enters a shell\nshell> cp -t . dev/AutoBZ/demos/svo_hr.dat dev/AutoBZ/demos/svo_r.dat dev/AutoBZ/demos/OC_berry.jl","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"In the lines above, the script OC_berry.jl was copied along with its default data files into the working directory. Note if you have data files with different names, the script needs to be edited to load those files instead. Moreover, the files in the working directory can be freely edited without affecting those in the AutoBZ repository, and likewise the repository can be updated without affecting the files in workdir. Note that any script dependencies other than AutoBZ will need to be added to the environment in workdir (e.g. pkg> add Plots).","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"Finally, to run the script from the Julia session in the workdir, simply include(\"OC_berry.jl\"). If you would like to run a script as a cluster job, include the line below in your bash script submitted to the scheduler.","category":"page"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"julia --project=. OC_berry.jl","category":"page"},{"location":"pages/workflow/#Notes","page":"Workflow","title":"Notes","text":"","category":"section"},{"location":"pages/workflow/","page":"Workflow","title":"Workflow","text":"When AutoBZ is released as a registered package, it will be enough to add AutoBZ to the Julia environment and copy the scripts from the installation location, although the method described above conveniently saves the repository in the working directory, letting you easily update the git repository or change branches. If working in an interactive session, this method also works with a Revise.jl workflow.","category":"page"},{"location":"pages/man/equispace_integration/#Equispace-integration","page":"Equispace integration","title":"Equispace integration","text":"","category":"section"},{"location":"pages/man/equispace_integration/#Routines","page":"Equispace integration","title":"Routines","text":"","category":"section"},{"location":"pages/man/equispace_integration/","page":"Equispace integration","title":"Equispace integration","text":"equispace_integration\nautomatic_equispace_integration","category":"page"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_integration","page":"Equispace integration","title":"AutoBZ.equispace_integration","text":"equispace_integration(f, l, npt; pre=nothing)\n\nEvaluate the integral of f over domain l using an equispace grid of npt points per dimension, optionally using precomputation pre\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.automatic_equispace_integration","page":"Equispace integration","title":"AutoBZ.automatic_equispace_integration","text":"automatic_equispace_integration(f, a, b; kwargs)\nautomatic_equispace_integration(f, l::IntegrationLimits; npt1=0, pre1=0, npt2=0, pre2=0, atol=0.0, rtol=1e-3 maxevals=typemax(Int64))\n\nAutomatically evaluates the integral of f over domain l to within the requested error tolerances atol and rtol. Allows optional precomputed data at two levels of grid refinement npt1, pre1 and npt2, pre2.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#Customization","page":"Equispace integration","title":"Customization","text":"","category":"section"},{"location":"pages/man/equispace_integration/","page":"Equispace integration","title":"Equispace integration","text":"The methods below can be extended/customized to integrand types","category":"page"},{"location":"pages/man/equispace_integration/","page":"Equispace integration","title":"Equispace integration","text":"equispace_npt_update\nequispace_pre_eval\nequispace_int_eval\nevaluate_integrand","category":"page"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_npt_update","page":"Equispace integration","title":"AutoBZ.equispace_npt_update","text":"equispace_npt_update(npt, f, atol, rtol)\n\nReturns a new npt to try and get another digit of accuracy from PTR. This fallback option is a heuristic, since the scaling of the error is generally problem-dependent.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_pre_eval","page":"Equispace integration","title":"AutoBZ.equispace_pre_eval","text":"equispace_pre_eval(f, l, npt)\n\nPrecomputes the grid points and weights to use for equispace quadrature of f on the domain l while applying the relevant symmetries to l to reduce the number of evaluation points. Should return a vector of tuples with the integration weight in the first position and the precomputation in the second. This output is passed to the argument pre of equispace_int_eval.\n\n\n\n\n\nequispace_pre_eval(w::WannierIntegrand, l::IntegrationLimits, npt)\n\nThis function will evaluate the Fourier series and integration weights needed for equispace integration of f at npt points per dimension. l should contain the relevant symmetries needed for IBZ integration, if desired.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_int_eval","page":"Equispace integration","title":"AutoBZ.equispace_int_eval","text":"equispace_int_eval(f, pre, dvol)\n\nSums the values of f on the precomputed grid points with corresponding quadrature weights and also multiplies by the mesh cell volume to obtain the integral on the precomputed domain represented by pre, obtained from equispace_pre_eval. Evaluation of f is done by the function evaluate_integrand in order to create a function boundary between the quadrature and the integrand evaluation.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.evaluate_integrand","page":"Equispace integration","title":"AutoBZ.evaluate_integrand","text":"evaluate_integrand(f, x)\n\nBy default, this calls f(x), however the caller may dispatch on the type of f if they would like to specialize this function together with equispace_pre_eval so that x is a more useful precomputation (e.g. a Fourier series evaluated at a grid point).\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#Self-energies","page":"Self energies","title":"Self energies","text":"","category":"section"},{"location":"pages/app/self_energy/#Interface","page":"Self energies","title":"Interface","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"AutoBZ.Applications.AbstractSelfEnergy\nAutoBZ.Applications.lb\nAutoBZ.Applications.ub","category":"page"},{"location":"pages/app/self_energy/#AutoBZ.Applications.AbstractSelfEnergy","page":"Self energies","title":"AutoBZ.Applications.AbstractSelfEnergy","text":"AbstractSelfEnergy\n\nAn abstract type whose instances implement the following interface:\n\ninstances are callable and return a square matrix as a function of frequency\ninstances have methods lb and ub that return the lower and upper bounds of of the frequency domain for which the instance can be evaluated\n\n\n\n\n\n","category":"type"},{"location":"pages/app/self_energy/#AutoBZ.Applications.lb","page":"Self energies","title":"AutoBZ.Applications.lb","text":"lb(::AbstractSelfEnergy)\n\nReturn the greatest lower bound of the domain of the self energy evaluator\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#AutoBZ.Applications.ub","page":"Self energies","title":"AutoBZ.Applications.ub","text":"ub(::AbstractSelfEnergy)\n\nReturn the least upper bound of the domain of the self energy evaluator\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#Types","page":"Self energies","title":"Types","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"AutoBZ.Applications.EtaEnergy\nAutoBZ.Applications.ScalarEnergy","category":"page"},{"location":"pages/app/self_energy/#AutoBZ.Applications.EtaEnergy","page":"Self energies","title":"AutoBZ.Applications.EtaEnergy","text":"EtaEnergy(η::Real)\n\nConstruct a self-energy evaluator which returns -ieta I for any frequency.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/self_energy/#AutoBZ.Applications.ScalarEnergy","page":"Self energies","title":"AutoBZ.Applications.ScalarEnergy","text":"ScalarEnergy(interpolant, lb, ub)\n\nConstruct a self-energy evaluator which for frequencies above lb and below ub returns the interpolant at that frequency times an identity matrix.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#Integrands","page":"Integrands","title":"Integrands","text":"","category":"section"},{"location":"pages/app/integrands/#User-defined","page":"Integrands","title":"User-defined","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"For integrands that can be evaluated by Wannier interpolation, the following data are necessary to define an integrand:","category":"page"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"the integrand evaluator\na Fourier series\nadditional parameters for the evaluator","category":"page"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"Consider implementing custom integrands using the generic template type AutoBZ.Applications.WannierIntegrand that is compatible with all of the adaptive and equispace integration routines.","category":"page"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"tip: Optimizing equispace integration\nUnlike for adaptive integration, the caller is responsible for passing pre-computed grid values to the equispace integration routines, which is explained in the documentation for Equispace integration and AutoBZ.Applications.equispace_pre_eval.","category":"page"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"warning: Mixing adaptive and equispace integrals\nWhile it is possible to perform an integral where some variables are integrated adaptively and others are integrated uniformly, this guide will not explain how to do this. However, an example implementation of this is  AutoBZ.Applications.AutoEquispaceKineticIntegrand.","category":"page"},{"location":"pages/app/integrands/#Types","page":"Integrands","title":"Types","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.WannierIntegrand","category":"page"},{"location":"pages/app/integrands/#AutoBZ.Applications.WannierIntegrand","page":"Integrands","title":"AutoBZ.Applications.WannierIntegrand","text":"WannierIntegrand(f, s::AbstractFourierSeries, p)\n\nA type generically representing an integrand f whose entire dependence on the variables of integration is in a Fourier series s, and which may also accept some input parameters p, which are preferrably contained in a tuple. The caller must be aware that their function, f, will be called at many evaluation points, x, in the following way: f(s(x), p...). Therefore the caller is expected to know the type of s(x) (hint: eltype(s)) and the layout of the parameters in the tuple p. Additionally, f is assumed to be type-stable.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#Methods","page":"Integrands","title":"Methods","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.pre_eval_contract(::AutoBZ.Applications.WannierIntegrand,::Any,::Any)","category":"page"},{"location":"pages/app/integrands/#Pre-defined","page":"Integrands","title":"Pre-defined","text":"","category":"section"},{"location":"pages/app/integrands/#Types-2","page":"Integrands","title":"Types","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.DOSIntegrand\nAutoBZ.Applications.TransportIntegrand\nAutoBZ.Applications.KineticIntegrand\nAutoBZ.Applications.EquispaceKineticIntegrand\nAutoBZ.Applications.AutoEquispaceKineticIntegrand","category":"page"},{"location":"pages/app/integrands/#AutoBZ.Applications.DOSIntegrand","page":"Integrands","title":"AutoBZ.Applications.DOSIntegrand","text":"DOSIntegrand(H, ω, Σ, μ)\nDOSIntegrand(H, ω, Σ)\nDOSIntegrand(H, M)\n\nA type whose integral gives the density of states.\n\nD(ω) = -pi^-1 int_textBZ dk operatornameTrIm((omega + mu) I - H(k) - Sigma(omega))^-1\n\nThis type works with both adaptive and equispace integration routines.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.TransportIntegrand","page":"Integrands","title":"AutoBZ.Applications.TransportIntegrand","text":"TransportIntegrand(HV, Σ, ω₁, ω₂, μ)\nTransportIntegrand(HV, Mω₁, Mω₂)\n\nA type whose integral over the BZ gives the transport distribution.\n\nGamma_alphabeta(omega_1 omega_2) = int_textBZ dk operatornameTrnu_alpha(k) A(komega_1) nu_beta(k) A(k omega_2)\n\nThis type works with both adaptive and equispace integration routines. Based on TRIQS\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.KineticIntegrand","page":"Integrands","title":"AutoBZ.Applications.KineticIntegrand","text":"KineticIntegrand(HV, Σ, β, μ, n, [Ω=0])\n\nA function whose integral over the BZ and the frequency axis gives the kinetic coefficient. Mathematically, this computes\n\nA_nalphabeta(Omega) = int_-infty^infty d omega (betaomega)^n fracf(omega) - f(omega+Omega)Omega Gamma_alphabeta(omega omega+Omega)\n\nwhere f(omega) = (e^betaomega+1)^-1 is the Fermi distriubtion. Use this type only for adaptive integration and order the limits so that the integral over the Brillouin zone is the outer integral and the frequency integral is the inner integral. Based on TRIQS\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.EquispaceKineticIntegrand","page":"Integrands","title":"AutoBZ.Applications.EquispaceKineticIntegrand","text":"EquispaceKineticIntegrand(A::KineticIntegrand, l, npt, pre::Vector{Tuple{eltype(A.HV),Int}})\nEquispaceKineticIntegrand(A, l, npt)\n\nThis type represents an KineticIntegrand, A integrated adaptively in frequency and with equispace integration over the Brillouin zone with a fixed number of grid points npt. The argument l should be an IntegrationLimits for just the Brillouin zone. This type should be called by an adaptive integration routine whose limits of integration are only the frequency variable.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.AutoEquispaceKineticIntegrand","page":"Integrands","title":"AutoBZ.Applications.AutoEquispaceKineticIntegrand","text":"AutoEquispaceKineticIntegrand(A, l, atol, rtol, npt1, pre1, npt2, pre2)\nAutoEquispaceKineticIntegrand(A, l, atol, rtol; npt1=0, pre1=Tuple{eltype(A.HV),Int}[], npt2=0,pre2=Tuple{eltype(σ.HV),Int}[])\n\nThis type represents an KineticIntegrand, A integrated adaptively in frequency and with equispace integration over the Brillouin zone with a number of grid points necessary to meet the maximum of the tolerances given by atol and rtol. The argument l should be an IntegrationLimits for just the Brillouin zone. This type should be called by an adaptive integration routine whose limits of integration are only the frequency variable.\n\nThe keyword arguments, which are just passed to automatic_equispace_integration, are:\n\npre1: a Vector containing tuples of the evaluated Hamiltonian + band   velocities and integration weights\nnpt1: an integer that should be equivalent to length(pre1)\npre2: a Vector containing tuples of the evaluated Hamiltonian + band   velocities and integration weights on a more refined grid than pre1\nnpt2: an integer that should be equivalent to length(pre)\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#Functions","page":"Integrands","title":"Functions","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.dos_integrand\nAutoBZ.Applications.spectral_function\nAutoBZ.Applications.band_velocities\nAutoBZ.Applications.transport_integrand\nAutoBZ.Applications.kinetic_integrand\nAutoBZ.Applications.fermi\nAutoBZ.Applications.fermi′\nAutoBZ.Applications.fermi_window\nAutoBZ.Applications.cosh_ratio\nAutoBZ.Applications.EXP_P1_SMALL_X","category":"page"},{"location":"pages/app/integrands/#AutoBZ.Applications.band_velocities","page":"Integrands","title":"AutoBZ.Applications.band_velocities","text":"band_velocities(::Type{Val{kind}}, H, vs...) where kind\n\nTransform the band velocities according to the following values of kind\n\n:full: return the full band velocity (Wannier gauge)\n:intra: return only the diagonal of the band velocity (Hamiltonian gauge)\n:inter: return only the off-diagonal terms of the band velocity (Hamiltonian gauge)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.Applications.fermi_window","page":"Integrands","title":"AutoBZ.Applications.fermi_window","text":"Evaluates a unitless window function determined by the Fermi distribution\n\n\n\n\n\n","category":"function"},{"location":"pages/equiinterp/#EquiBaryInterp","page":"EquiBaryInterp","title":"EquiBaryInterp","text":"","category":"section"},{"location":"pages/equiinterp/","page":"EquiBaryInterp","title":"EquiBaryInterp","text":"AutoBZ.EquiBaryInterp.LocalEquiBaryInterp\nAutoBZ.EquiBaryInterp.BaryPoly\nAutoBZ.EquiBaryInterp.barycentric_weights","category":"page"},{"location":"pages/equiinterp/#AutoBZ.EquiBaryInterp.LocalEquiBaryInterp","page":"EquiBaryInterp","title":"AutoBZ.EquiBaryInterp.LocalEquiBaryInterp","text":"LocalEquiBaryInterp(x::AbstractVector, y::AbstractVector, [degree=8])\nLocalEquiBaryInterp(x::Vector, y::Vector, w::Vector, h)\n\nConstruct a local barycentric Lagrange interpolant that forms a degree degree local polynomial approximation of the data y on the equispace grid x, which must be identical to a range with step size h. w are the equispace interpolation weights.\n\n\n\n\n\n","category":"type"},{"location":"pages/equiinterp/#AutoBZ.EquiBaryInterp.BaryPoly","page":"EquiBaryInterp","title":"AutoBZ.EquiBaryInterp.BaryPoly","text":"BaryPoly(x, y)\nBaryPoly(x, y, w)\n\nConstructs a barycentric Lagrange polynomial from the data y sampled on x.\n\n\n\n\n\n","category":"type"},{"location":"pages/equiinterp/#AutoBZ.EquiBaryInterp.barycentric_weights","page":"EquiBaryInterp","title":"AutoBZ.EquiBaryInterp.barycentric_weights","text":"barycentric_weights(x::AbstractVector{T}) where {T<:Real}\n\nComputes barycentric weights for the nodes x.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#Adaptive-integration","page":"Adaptive integration","title":"Adaptive integration","text":"","category":"section"},{"location":"pages/man/adaptive_integration/#Routines","page":"Adaptive integration","title":"Routines","text":"","category":"section"},{"location":"pages/man/adaptive_integration/","page":"Adaptive integration","title":"Adaptive integration","text":"tree_integration\niterated_integration\nAutoBZ.alloc_segbufs\nAutoBZ.thunk\nAutoBZ.ThunkIntegrand","category":"page"},{"location":"pages/man/adaptive_integration/#AutoBZ.tree_integration","page":"Adaptive integration","title":"AutoBZ.tree_integration","text":"tree_integration(f, a, b)\ntree_integration(f, ::CubicLimits)\n\nCalls HCubature to perform multi-dimensional integration of f over a cube.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.iterated_integration","page":"Adaptive integration","title":"AutoBZ.iterated_integration","text":"iterated_integration(f, ::IntegrationLimits; order=7, atol=nothing, rtol=nothing, norm=norm, maxevals=typemax(Int), initdivs=ntuple(i -> i == 1 ? 5 : 1, Val{d}()), segbufs=nothing)\niterated_integration(f, a, b; kwargs...)\n\nCalls QuadGK to perform iterated 1D integration of f over a domain parametrized by IntegrationLimits. In the case two points a and b are passed, the integration region becomes the hypercube with those extremal vertices.\n\nReturns a tuple (I, E) of the estimated integral and estimated error.\n\nKeyword options include a relative error tolerance rtol (if atol==0, defaults to sqrt(eps) in the precision of the norm of the return type), an absolute error tolerance atol (defaults to 0), a maximum number of function evaluations maxevals for each nested integral (defaults to 10^7), and the order of the integration rule (defaults to 7).\n\nThe algorithm is an adaptive Gauss-Kronrod integration technique: the integral in each interval is estimated using a Kronrod rule (2*order+1 points) and the error is estimated using an embedded Gauss rule (order points). The interval with the largest error is then subdivided into two intervals and the process is repeated until the desired error tolerance is achieved. This 1D procedure is applied recursively to each variable of integration in an order determined by l to obtain the multi-dimensional integral.\n\nUnlike quadgk, this routine does not allow infinite limits of integration nor unions of intervals to avoid singular points of the integrand. However, the initdivs keyword allows passing a tuple of integers which specifies the initial number of panels in each quadgk call at each level of integration.\n\nIn normal usage, iterated_integration will allocate segment buffers. You can instead pass a preallocated buffer allocated using alloc_segbufs as the segbuf argument. This buffer can be used across multiple calls to avoid repeated allocation.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.alloc_segbufs","page":"Adaptive integration","title":"AutoBZ.alloc_segbufs","text":"alloc_segbufs(eltype_l, typeof_fx, typeof_nfx, ndims_l)\n\nThis helper function will allocate enough segment buffers as are needed for an iterated_integration call of integrand f and integration limits l. eltype_l should be eltype(l), typeof_fx should be the return type of the integrand f, typeof_nfx should be the type of the norm of a value of f, and ndims_l should be ndims(l).\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.thunk","page":"Adaptive integration","title":"AutoBZ.thunk","text":"thunk(f, x)\n\nDelay the computation of f(x). Needed to normally evaluate an integrand in nested integrals, a setting in which the values of the variables of integration are passed one at a time. Importantly, thunk assumes that the variables of integration are passed from the outermost to the innermost. For example, to evaluate f([1, 2]), call thunk(f, 2)(1).\n\nThis behavior is consistent with CubicLimits, but may come as a surprise if implementing new IntegrationLimits.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.ThunkIntegrand","page":"Adaptive integration","title":"AutoBZ.ThunkIntegrand","text":"ThunkIntegrand(f, x)\n\nStore f and x to evaluate f(x) at a later time. Employed by iterated_integration for generic integrands that haven't been specialized to use iterated_pre_eval.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/adaptive_integration/#Customization","page":"Adaptive integration","title":"Customization","text":"","category":"section"},{"location":"pages/man/adaptive_integration/","page":"Adaptive integration","title":"Adaptive integration","text":"The methods below can be extended/customized to integrand types","category":"page"},{"location":"pages/man/adaptive_integration/","page":"Adaptive integration","title":"Adaptive integration","text":"iterated_tol_update\niterated_pre_eval\niterated_segs\nAutoBZ.infer_f","category":"page"},{"location":"pages/man/adaptive_integration/#AutoBZ.iterated_tol_update","page":"Adaptive integration","title":"AutoBZ.iterated_tol_update","text":"iterated_tol_update(f, l, atol, rtol)\n\nChoose a new set of error tolerances for the next inner integral. By default returns (atol, rtol) unchanged.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.iterated_pre_eval","page":"Adaptive integration","title":"AutoBZ.iterated_pre_eval","text":"iterated_pre_eval(f, x, dim)\niterated_pre_eval(f, x)\n\nPerform a precomputation on f using the value of a variable of integration, x. The default is to store x and delay the computation of f(x) until all of the values of the variables of integration are determined at a integration point. Certain types of functions, such as Fourier series, take can use x to precompute a new integrand for the remaining variables of integration that is more computationally efficient. This function must return the integrand for the subsequent integral.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.iterated_segs","page":"Adaptive integration","title":"AutoBZ.iterated_segs","text":"iterated_segs(f, l, d, initdivs)\n\nReturns a Tuple of integration nodes that are passed to QuadGK to initialize the segments for adaptive integration. By default, returns initdivs equally spaced panels on (lower(l), upper(l)). If f is localized, specializing this function can also help avoid errors when QuadGK fails to adapt.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.infer_f","page":"Adaptive integration","title":"AutoBZ.infer_f","text":"infer_f(f, Tx)\n\nEvaluates f(zero(Tx)) and norm(f(zero(Tx))) and returns their types. If the type of the range of f is known apriori, this method is meant to be specialized. Implicitly this assumes that f is type-stable.\n\n\n\n\n\n","category":"function"},{"location":"pages/demo/#Demos","page":"Demos","title":"Demos","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"To illustrate the principles and practice of using AutoBZ.jl, the tutorials below show how to setup and compute BZ integrals for various observables of toy, tight-binding models with the package. Additionally, scripts corresponding to the tutorials are available in the demos folder of the repo.","category":"page"},{"location":"pages/demo/#DOS-of-the-integer-lattice-tight-binding-model","page":"Demos","title":"DOS of the integer lattice tight-binding model","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"In this tutorial, we consider a tight-binding model on the n-dimensional integer lattice with lattice constant a and hopping strength t0 given by the following Hamiltonian:","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"H = -t sum_i in Z^n sum_j=1^n ketibrai+hatj + keti+hatjbrai","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where keti represents the state at lattice site iin Z^n and hatj represents a vector of zeros except for a one at position j. We will compute the density of states (DOS) of this system, which as a function of n shows the dimension-dependent behavior of Van-Hove singularities.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Employing Bloch's theorem, which for this problem implies keti+hatj = e^ibmkcdothatjketi, yields the following band structure","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"H(k_1 ldots k_n) = -t(cos(k_1 a) + cdots + cos(k_n a))","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"We shall input this Hamiltonian to AutoBZ by constructing an equivalent Fourier series, which boils down to writing this Hamiltonian in the form H(bmk) = sum_bmR e^ibmkcdotbmR H_bmR, where bmR is an integer multi-index. To do this, we follow the Hamiltonian recipe. In the first step, we identify the real and reciprocal lattice basis vectors as the Cartesian coordinate basis and then observe that the bmR vectors with non-zero coefficients are exactly the nearest neighbor vectors pmhatj_j=1^n. In step two, we identify the coefficients to be -t2 for all the terms by simply writing the cosines as complex exponentials. Finally we fill the array of coefficients by taking each bmR to be the array index of the corresponding coefficient H_bmR.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using OffsetArrays\n\nusing AutoBZ\nusing AutoBZ.Applications\n\nn = 3 # arbitrary positive integer representing the number of k-space dimensions\na = 1.0 # lattice spacing\nt = 1.0 # hopping amplitude\n#=\nconstruct the array of scalar coefficients and use an OffsetArray so that the\narray indices correspond to the R integer multi-index of the Fourier series\n=#\nC = OffsetArray(zeros(ntuple(_ -> 3, n)), ntuple(_ -> -1:1, n)...)\nfor i in 1:n, j in (-1, 1)\n    C[CartesianIndex(ntuple(k -> k == i ? j : 0, n))] = -0.5t\nend\nH = FourierSeries(C, 2pi/a)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Then we can define the integration problem to compute DOS, defined by the integral","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"operatornameDOS(omega) = -frac1pi int_textBZ dbmk operatornameIm left (hbaromega+mu-H(bmk)+ieta)^-1 right","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where omega is a frequency variable, bmk is the reciprocal space vector, mu is the chemical potential and eta is a constant scattering rate. We implement our own user-defined integrand with the AutoBZ.Applications.WannierIntegrand type:","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"ω = t*n # frequency at the band edge/Van-Hove singularity\nħ = 1.0 # reduced Planck's constant\nη = 0.1 # broadening\nμ = 0.0 # chemical potential\ndos_integrand(H_k, ω, η, μ) = -imag(inv(ħ*ω + μ - H_k + im*η))/pi # integrand evaluator\nD = WannierIntegrand(dos_integrand, H, (ω, η, μ)) # user-defined integrand","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"To compute the integral, we also need to provide the limits of integration, to specify an error tolerance, and to call one of the integration routines","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"c = CubicLimits(period(H)) # Full BZ limits\nt = TetrahedralLimits(c) # Irreducible BZ limits\n\natol = 1e-3 # absolute error tolerance requests the result to within ±atol\n\nI, E = iterated_integration(D, t; atol=atol)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"The routine returns the estimate of the integral I and an error estimate E.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"You will find a working example of this model in the DOS_example.jl demo that computes DOS over a range of frequencies for this model.","category":"page"},{"location":"pages/demo/#DOS-of-Graphene","page":"Demos","title":"DOS of Graphene","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"In this tutorial, we will build the Fourier series corresponding to a tight-binding model of graphene. This example is more complex in that the lattice vectors are not orthogonal and that there are multiple bands.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"The tight-binding model on the hexagonal lattice with lattice constant a and hopping amplitude t. Applying Bloch's theorem to each triangular sublattice brings the Hamiltonian into block-diagonal form, where each block is of the form","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"-t\nbeginpmatrix\n0  f(bmk)\n f^*(bmk)  0\nendpmatrix","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where f(k) = sum_j=1^3 e^ibmkcdotbmdelta_j depends on the nearest-neighbor vectors","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"bmdelta_1 = ahatx\nqquad\nbmdelta_2 = a(-12hatx+sqrt32haty)\nqquad\nbmdelta_3 = a(-12hatx-sqrt32haty)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"To exactly construct this Fourier series, we begin with step one of the Hamiltonian recipe identifying a basis of lattice vectors that forms a Bravais lattice. We can choose these as the following triangular lattice vectors","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"bma_1 = (bmdelta_1 - bmdelta_3)3\nqquad\nbma_2 = (bmdelta_1 - bmdelta_2)3","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"such that in this basis we write","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"bmdelta_1 = bma_1 + bma_2\nqquad\nbmdelta_2 = bma_1 - 2bma_2\nqquad\nbmdelta_3 = -2bma_1 + bma_2","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Now taking step two, we factor the Hamiltonian into different normal modes and observe the bmR vectors are just the pairs of integer coefficients in the linear combination of Bravais lattice vectors for each exponential.","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"(e^ibmkcdot(bma_1 + bma_2) + e^ibmkcdot(bma_1 - 2bma_2) + e^ibmkcdot(-2bma_1 + bma_2))\nbeginpmatrix\n0  0\n -t  0\nendpmatrix\n+ (e^ibmkcdot(-bma_1 - bma_2) + e^ibmkcdot(-bma_1 + 2bma_2) + e^ibmkcdot(2bma_1 - bma_2))\nbeginpmatrix\n0  -t\n 0  0\nendpmatrix","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"This corresponds to the following Fourier series in AutoBZ","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using StaticArrays\nusing OffsetArrays\n\nusing AutoBZ\nusing AutoBZ.Applications\n\na = 1.0 # length of Bravais lattice vectors\nt = 1.0 # hopping amplitude\nC = OffsetArray(zeros(SMatrix{2,2,ComplexF64,4}, (5,5)), -2:2, -2:2)\nC[1,1]   = C[1,-2] = C[-2,1] = [0 -t; 0 0] # Define C[R] = H_R\nC[-1,-1] = C[-1,2] = C[2,-1] = [0 0; -t 0]\nH = FourierSeries(C, 2*pi/a)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"The DOS integrand can be formulated as before, except it must also compute the trace since this Hamiltonian is matrix-valued. Another option would be to use the pre-defined AutoBZ.Applications.DOSIntegrand.","category":"page"},{"location":"pages/demo/#Graphene-example-with-ManyOffsetsFourierSeries","page":"Demos","title":"Graphene example with ManyOffsetsFourierSeries","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Another Fourier series formulated from graphene is ","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"xi(bmk) = sum_n=1^6 e^ibmkcdotbmdelta_n","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"and by choosing a basis bma_1 = hatx bma_2 = (hatx + sqrt3haty)2 we express the displacement vectors as","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"bmdelta_1 = bma_1 = -bmdelta_4\nqquad\nbmdelta_2 = bma_2 = -bmdelta_5\nqquad\nbmdelta_3 = bma_2 - bma_1 = -bmdelta_6","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"and we can construct the Fourier series in AutoBZ as","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using OffsetArrays\n\nusing AutoBZ\nusing AutoBZ.Applications\n\nC = OffsetArray(zeros(3, 3), -1:1, -1:1)\nC[1,0] = C[-1,0] = C[0,1] = C[0,-1] = C[1,-1] = C[-1,1] = 1\nξ = FourierSeries(C, 2pi)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Now the new integral we want to calculate is","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"g(bmq) = int_textBZ dbmk fraclambda(xi(bmk)) - lambda(xi(bmk-bmq))xi(bmk) - xi(bmk-bmq)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"where lambda(omega) = partial_T f(omega) is the temperature derivative of the Fermi distribution. Since the integrand requires evaluation of the Hamiltonian at various k-points simultaneously, we can express this with a AutoBZ.Applications.ManyOffsetsFourierSeries. Moreover, AutoBZ.Applications has functions to evaluate Fermi functions and their derivatives. Putting these pieces together gives the following integrand definition","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"T = 100.0 # K\nkB = 8.617333262e-5 # eV/K\nq = rand(SVector{2,Float64}) # arbitrary q point to integrate\nf = ManyOffsetsFourierSeries(ξ, q) # makes a new Fourier series from ξ offset by q\n\n# define the function to integrate and wrap it in an integrand type\nlambda(x, T, kB) = -AutoBZ.Applications.fermi′(inv(kB*T), x)/(kB*T^2)\nfunction evaluate_integrand(f, T, kB)\n    ξ_k, ξ_q = f\n    if ξ_k == ξ_q\n        # when the integrand is ill defined, return its limiting value ∂λ/∂ξ\n        return lambda(ξ_k, T, kB)*(2*fermi′(ξ_k, inv(kB*T))/fermi(ξ_k, inv(kB*T)) - inv(ξ_k) - inv(kB*T))\n    else\n        return (lambda(ξ_k, T, kB) - lambda(ξ_q, T, kB))/(ξ_k-ξ_q)\n    end\nend\nintegrand = WannierIntegrand(evaluate_integrand, f, (T, kB))","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"You will find a working example of this code in the graphene.jl demo that calculates this integral for values of bmq in the Brillouin zone.","category":"page"},{"location":"pages/adaptinterp/#AdaptChebInterp","page":"AdaptChebInterp","title":"AdaptChebInterp","text":"","category":"section"},{"location":"pages/adaptinterp/","page":"AdaptChebInterp","title":"AdaptChebInterp","text":"AutoBZ.AdaptChebInterp.adaptchebinterp\nAutoBZ.AdaptChebInterp.fastadaptchebinterp","category":"page"},{"location":"pages/adaptinterp/#AutoBZ.AdaptChebInterp.adaptchebinterp","page":"AdaptChebInterp","title":"AutoBZ.AdaptChebInterp.adaptchebinterp","text":"adaptchebinterp(f, a, b; order=4, atol=0, rtol=0, norm=norm, maxevals=typemax(Int), initdiv=1, npoints=10)\n\nReturn a piecewise polynomial interpolant of f on the interval ab of degree order that is pointwise accurate to the requested tolerances. The error estimate used by this routine to adaptively refine the panels is to bisect the panel and construct an interpolant on each subpanel and to take the error to be the maximum norm of the difference of the original interpolant and the refined interpolants evaluated on an equispaced grid of npoints(order+1) points. If a panel is accepted, the implementation uses the original interpolant for the panel and discards the refinements. (If unnecessary function evaluations to construct the interpolant should be avoided, see fastadaptchebinterp.) norm is also used set the error tolerance of a panel, which is max(atol, maximum(rtol*norm(f.(p)))) where p are the Chebyshev nodes on the panel.\n\n\n\n\n\n","category":"function"},{"location":"pages/adaptinterp/#AutoBZ.AdaptChebInterp.fastadaptchebinterp","page":"AdaptChebInterp","title":"AutoBZ.AdaptChebInterp.fastadaptchebinterp","text":"fastadaptchebinterp(f, a, b; order=15, atol=0, rtol=0, norm=norm, maxevals=typemax(Int), initdiv=1, abs=abs, ncoeffs=3)\n\nReturn a piecewise polynomial interpolant of f on the interval ab of degree order that is pointwise accurate to the requested tolerances. The error estimate used by this routine to adaptively refine the panels is the sum of the abs value of the last ncoeffs Chebyshev coefficients of the interpolant on that panel. norm is used set the error tolerance of a panel, which is max(atol, rtol*maximum(norm, f.(p))) where p are the Chebyshev nodes on the panel. In the case of a non-scalar function, abs may have to be an array norm.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#Jobs","page":"Jobs","title":"Jobs","text":"","category":"section"},{"location":"pages/jobs/","page":"Jobs","title":"Jobs","text":"The module AutoBZ.Jobs has batch functions that setup kinetic coefficient calculations.","category":"page"},{"location":"pages/jobs/#Scripts","page":"Jobs","title":"Scripts","text":"","category":"section"},{"location":"pages/jobs/","page":"Jobs","title":"Jobs","text":"AutoBZ.Jobs.run_kinetic\nAutoBZ.Jobs.run_kinetic_equispace\nAutoBZ.Jobs.run_kinetic_auto\nAutoBZ.Jobs.run_kinetic_auto_equispace","category":"page"},{"location":"pages/jobs/#AutoBZ.Jobs.run_kinetic","page":"Jobs","title":"AutoBZ.Jobs.run_kinetic","text":"run_kinetic(HV, Σ::AbstractSelfEnergy, β, μ, n, Ωs, rtol, atol)\n\nReturns a NamedTuple with names A, err, t, Omega containing the results, errors, and timings for a kinetic coefficient calculation done at frequencies Ωs with parameters β, μ, n, atol, rtol. This function constructs a KineticIntegrand for each parameter value and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_kinetic_equispace","page":"Jobs","title":"AutoBZ.Jobs.run_kinetic_equispace","text":"run_kinetic_equispace(HV, Σ::AbstractSelfEnergy, β, μ, n, Ωs, npt, rtol, atol; pre_eval=pre_eval_contract)\n\nReturns a NamedTuple with names A, err, t, Omega containing the results, errors, and timings for a kinetic coefficient calculation done at frequencies Ωs with parameters β, μ, n, atol, rtol. This function constructs an EquispaceKineticIntegrand for each parameter value, and precomputes HV on an equispace k grid with npt points per dimension (which is reused for all parameter values), and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_kinetic_auto","page":"Jobs","title":"AutoBZ.Jobs.run_kinetic_auto","text":"run_kinetic_auto(HV, Σ::AbstractSelfEnergy, β, μ, n, Ωs, rtol, atol; ertol=1.0, eatol=0.0)\n\nReturns a NamedTuple with names A, err, t, Omega containing the results, errors, and timings for a kinetic coefficient calculation done at frequencies Ωs with parameters β, μ, n, atol, rtol. This function constructs both an AutoEquispaceKineticIntegrand with wide tolerances eatol and ertol which estimates the integral, int, and then uses a narrow absolute tolerance set by max(atol,rtol*norm(int)) to construct a KineticIntegrand for each parameter value and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results.\n\nSince this is intended to compute a cheap equispace integral first, it is recommended to over-ride the default k-grid refinement step to something eta-independent with a line like the one below before calling this script\n\nAutoBZ.equispace_npt_update(npt, ::TransportIntegrand, atol, rtol) = npt + 50\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_kinetic_auto_equispace","page":"Jobs","title":"AutoBZ.Jobs.run_kinetic_auto_equispace","text":"run_kinetic_auto_equispace(HV, Σ::AbstractSelfEnergy, β, μ, n, Ωs, rtol, atol)\n\nReturns a NamedTuple with names A, err, t, Omega containing the results, errors, and timings for a kinetic coefficient calculation done at frequencies Ωs with parameters β, μ, n, atol, rtol. This function constructs an AutoEquispaceKineticIntegrand for each parameter value, reusing k-grids of HV values from previous calculations, and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#Parallelized-scripts","page":"Jobs","title":"Parallelized scripts","text":"","category":"section"},{"location":"pages/jobs/","page":"Jobs","title":"Jobs","text":"\nAutoBZ.Jobs.run_wannier_adaptive\nAutoBZ.Jobs.run_wannier_equispace\nAutoBZ.Jobs.run_wannier_auto_equispace\nAutoBZ.Jobs.run_wannier\nAutoBZ.Jobs.run_dos_adaptive\nAutoBZ.Jobs.run_dos_equispace\nAutoBZ.Jobs.run_dos_auto_equispace\nAutoBZ.Jobs.run_dos\nAutoBZ.Jobs.run_kinetic_parallel\nAutoBZ.Jobs.run_kinetic_equispace_parallel\nAutoBZ.Jobs.run_kinetic_auto_parallel\nAutoBZ.Jobs.run_kinetic_auto_equispace_parallel","category":"page"},{"location":"pages/jobs/#AutoBZ.Jobs.run_wannier_adaptive","page":"Jobs","title":"AutoBZ.Jobs.run_wannier_adaptive","text":"run_wannier_adaptive(integrand, fs, ps, lims, rtol, atol, [nthreads=Threads.nthreads()])\n\nReturns a NamedTuple with names I, E, t, p containing the integrals, errors, and timings for a density of states calculation done at frequencies ωs with parameters μ, atol, rtol. This function constructs a WannierIntegrand for each parameter value and calls iterated_integration with limits of integration lims to get the results.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_wannier_equispace","page":"Jobs","title":"AutoBZ.Jobs.run_wannier_equispace","text":"run_wannier_equispace(integrand, fs, ps, lims, npt, [nthreads=Threads.nthreads()])\n\nReturns a NamedTuple with names I, t, p containing the integrals and timings obtained for a Wannier-interpolated integral from caller-supplied Fourier series fs and evaluator integrand done at parameters ps, npt, where npt is the number of k points per dimension. This function constructs a WannierIntegrand for each parameter value and calls equispace_integration with limits of integration lims to get the results. The caller should check that the result is converged with respect to npt.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_wannier_auto_equispace","page":"Jobs","title":"AutoBZ.Jobs.run_wannier_auto_equispace","text":"run_wannier_auto_equispace(integrand, fs, ps, lims, rtol, atol, [nthreads=1])\n\nReturns a NamedTuple with names I, E, t, p, npt1, npt2 containing the integrals, errors, timings, and number of kpts per dimension obtained for a Wannier-interpolated integral from caller-supplied Fourier series fs and evaluator integrand done at parameters ps, atol, rtol.  This function constructs a WannierIntegrand for each parameter value and calls automatic_equispace_integration with limits of integration lims to get the results.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_wannier","page":"Jobs","title":"AutoBZ.Jobs.run_wannier","text":"run_wannier(integrand, fs, ps, rtol, atol, [nthreads=Threads.nthreads()]; ertol=1.0, eatol=0.0)\n\nReturns a NamedTuple with names I, E, t, p containing the integrals, errors, and timings for obtained for a Wannier-interpolated integral from caller-supplied Fourier series fs and evaluator integrand done at parameters ps, rtol, atol. The integral is evaluated adaptively. However if rtol is nonzero, it is first estimated by an equispace method using wide tolerances eatol and ertol, and then uses a narrow absolute tolerance set by max(atol,rtol*norm(int)) to evaluate and return the adaptive integral.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_dos_adaptive","page":"Jobs","title":"AutoBZ.Jobs.run_dos_adaptive","text":"run_dos_adaptive(H, Σ::AbstractSelfEnergy, μ, ωs, rtol, atol, [nthreads=Threads.nthreads()])\n\nReturns a NamedTuple with names I, E, t, omega containing the results, errors, and timings for a density of states calculation done at frequencies ωs with parameters μ, atol, rtol. This function constructs a DOSIntegrand for each parameter value and calls iterated_integration on it over the domain of the IBZ to get the results.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_dos_equispace","page":"Jobs","title":"AutoBZ.Jobs.run_dos_equispace","text":"run_dos_equispace(HV, Σ::AbstractSelfEnergy, μ, ωs, npt, [nthreads=Threads.nthreads()])\n\nReturns a NamedTuple with names I, t, omega containing the integrals and timings obtained for a density of states calculation done at frequencies ωs with parameters μ, npt, where npt is the number of k points per dimension. The caller should check that the result is converged with respect to npt.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_dos_auto_equispace","page":"Jobs","title":"AutoBZ.Jobs.run_dos_auto_equispace","text":"run_dos_auto_equispace(HV, Σ::AbstractSelfEnergy, μ, ωs, rtol, atol, [nthreads=1])\n\nReturns a NamedTuple with names I, E, t, omega, npt1, npt2 containing the integrals, errors, timings, and number of kpts per dimension used for a density of states calculation done at frequencies ωs with parameters μ, atol, rtol.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_dos","page":"Jobs","title":"AutoBZ.Jobs.run_dos","text":"run_dos(HV, Σ::AbstractSelfEnergy, μ, ωs, rtol, atol, [nthreads=Threads.nthreads()]; ertol=1.0, eatol=0.0)\n\nReturns a NamedTuple with names I, E, t, omega containing the integrals, errors, and timings for a density of states calculation done at frequencies ωs with parameters μ, atol, rtol. This function first estimates the integral, int, with an equispace method using wide tolerances eatol and ertol, and then uses a narrow absolute tolerance set by max(atol,rtol*norm(int)) to evaluate the same integral adaptively.\n\nSince this is intended to compute a cheap equispace integral first, it is recommended to over-ride the default k-grid refinement step to something eta-independent with a line like the one below before calling this script\n\nAutoBZ.equispace_npt_update(npt, ::DOSIntegrand, atol, rtol) = npt + 50\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_kinetic_parallel","page":"Jobs","title":"AutoBZ.Jobs.run_kinetic_parallel","text":"run_kinetic_parallel(filename, HV, Σ::AbstractSelfEnergy, β, μ, n, Ωs, rtol, atol; nthreads=Threads.nthreads())\n\nWrites an h5 archive to filename with groups A, err, t, Omega containing the results, errors, and timings for a kinetic coefficient calculation done at frequencies Ωs with parameters β, μ, n, atol, rtol. This function constructs a KineticIntegrand for each parameter value and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results. The calculation is parallelized over Ωs on nthreads threads.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_kinetic_equispace_parallel","page":"Jobs","title":"AutoBZ.Jobs.run_kinetic_equispace_parallel","text":"run_kinetic_equispace_parallel(filename, HV, Σ::AbstractSelfEnergy, β, μ, n, Ωs, npt, rtol, atol; pre_eval=pre_eval_contract, nthreads=Threads.nthreads())\n\nWrites an h5 archive to filename with groups A, err, t, Omega containing the results, errors, and timings for a kinetic coefficient calculation done at frequencies Ωs with parameters β, μ, n, atol, rtol. This function constructs an EquispaceKineticIntegrand for each parameter value, and precomputes HV on an equispace k grid with npt points per dimension (which is reused for all parameter values), and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results. The calculation is parallelized over Ωs on nthreads threads.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_kinetic_auto_parallel","page":"Jobs","title":"AutoBZ.Jobs.run_kinetic_auto_parallel","text":"run_kinetic_auto_parallel(HV, Σ::AbstractSelfEnergy, β, μ, n, Ωs, rtol, atol; ertol=1.0, eatol=0.0, nthreads=Threads.nthreads())\n\nReturns a NamedTuple with names A, err, t, Omega containing the results, errors, and timings for a kinetic coefficient calculation done at frequencies Ωs with parameters β, μ, n, atol, rtol. This function constructs both an AutoEquispaceKineticIntegrand with wide tolerances eatol and ertol which estimates the integral, int, and then use a narrow absolute tolerance set by max(atol,rtol*norm(int)) to construct a KineticIntegrand for each parameter value and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results. The calculation is parallelized over Ωs on nthreads threads.\n\nSince this is intended to compute a cheap equispace integral first, it is recommended to over-ride the default k-grid refinement step to something eta-independent with a line like the one below before calling this script\n\nAutoBZ.equispace_npt_update(npt, ::TransportIntegrand, atol, rtol) = npt + 50\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.run_kinetic_auto_equispace_parallel","page":"Jobs","title":"AutoBZ.Jobs.run_kinetic_auto_equispace_parallel","text":"run_kinetic_auto_equispace_parallel(filename, HV, Σ::AbstractSelfEnergy, β, μ, n, Ωs, rtol, atol; nthreads=1)\n\nWrites an h5 archive to filename with groups A, err, t, Omega containing the results, errors, and timings for a kinetic coefficient calculation done at frequencies Ωs with parameters β, μ, n, atol, rtol. This function constructs an AutoEquispaceKineticIntegrand for each parameter value, reusing k-grids of HV values from previous calculations, and calls iterated_integration on it over the domain of the IBZ and a safely truncated frequency integral to get the results. The calculation is parallelized over Ωs on nthreads threads. The default is set to 1 thread for frequency parallelization, although k-point parallelization is still enabled, to avoid duplicating calculations of the Hamiltonian and band velocities on the k-mesh.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#I/O","page":"Jobs","title":"I/O","text":"","category":"section"},{"location":"pages/jobs/","page":"Jobs","title":"Jobs","text":"AutoBZ.Jobs.read_h5_to_nt\nAutoBZ.Jobs.write_nt_to_h5\nAutoBZ.Jobs.import_self_energy","category":"page"},{"location":"pages/jobs/#AutoBZ.Jobs.read_h5_to_nt","page":"Jobs","title":"AutoBZ.Jobs.read_h5_to_nt","text":"read_h5_to_nt(filename)\n\nLoads the h5 archive from filename and reads its datasets into a NamedTuple\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.write_nt_to_h5","page":"Jobs","title":"AutoBZ.Jobs.write_nt_to_h5","text":"write_nt_to_h5(nt::NamedTuple, filename)\n\nTakes a NamedTuple and writes its values, which must be arrays, into an h5 archive at filename with dataset names corresponding to the tuple names.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.import_self_energy","page":"Jobs","title":"AutoBZ.Jobs.import_self_energy","text":"import_self_energy(filename)\n\nReads the groups omega and sigma in the h5 archive in filename and tries save it to a NamedTuple with names ω and Σ. The array in sigma should be of size (length(omega), 2), where the two columns are the real and imaginary parts of Σ.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#Internal","page":"Jobs","title":"Internal","text":"","category":"section"},{"location":"pages/jobs/","page":"Jobs","title":"Jobs","text":"AutoBZ.Jobs.get_safe_freq_limits\nAutoBZ.Jobs.batch_smooth_param","category":"page"},{"location":"pages/jobs/#AutoBZ.Jobs.get_safe_freq_limits","page":"Jobs","title":"AutoBZ.Jobs.get_safe_freq_limits","text":"get_safe_freq_limits(Ωs, β, lb, ub)\n\nGiven a collection of frequencies, Ωs, returns a Vector{CubicLimits{1}} with truncated limits of integration for the frequency integral at each (Ω, β) point that are determined by the fermi_window_limits routine set to the default tolerances for the decay of the Fermi window function. The arguments lb and ub are lower and upper limits on the frequency to which the default result gets truncated if the default result would recommend a wider interval. If there is any truncation, a warning is emitted to the user, but the program will continue with the truncated limits.\n\n\n\n\n\n","category":"function"},{"location":"pages/jobs/#AutoBZ.Jobs.batch_smooth_param","page":"Jobs","title":"AutoBZ.Jobs.batch_smooth_param","text":"batch_smooth_param(xs, nthreads)\n\nIf the cost of a calculation smoothly varies with the parameters xs, then batch xs into nthreads groups where the ith element of group j is xs[j+(i-1)*nthreads]\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"pages/app/interfaces/#Wannier90","page":"Interfaces","title":"Wannier90","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"AutoBZ.Applications.load_hamiltonian\nAutoBZ.Applications.load_hamiltonian_velocities\nAutoBZ.Applications.load_position_operator\nAutoBZ.Applications.parse_hamiltonian\nAutoBZ.Applications.parse_position_operator","category":"page"},{"location":"pages/app/interfaces/#AutoBZ.Applications.load_hamiltonian","page":"Interfaces","title":"AutoBZ.Applications.load_hamiltonian","text":"load_hamiltonian(filename; period=1.0, compact=:N)\n\nLoad an ab-initio Hamiltonian output from Wannier90 into filename as an evaluatable FourierSeries whose periodicity can be set by the keyword argument period which defaults to setting the period along each dimension to 1.0. To define different periods for different dimensions, pass an SVector as the period. To store Hermitian Fourier coefficients in compact form, use the keyword compact to specify:\n\n:N: do not store the coefficients in compact form\n:L: store the lower triangle of the coefficients\n:U: store the upper triangle of the coefficients\n:S: store the lower triangle of the symmetrized coefficients, (c+c')/2\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.Applications.load_hamiltonian_velocities","page":"Interfaces","title":"AutoBZ.Applications.load_hamiltonian_velocities","text":"load_hamiltonian_velocities(f_hamiltonian, [f_pos_op]; period=1.0, compact=:N, kind=:full)\n\nLoad the Hamiltonian and band velocities, which may later be passed to one of the integrand constructors. When called with one filename, that file is parsed as a Wannier 90 Hamiltonian and the resulting Band velocities are just the gradient of the Hamiltonian. The return type is BandEnergyVelocity3D. When called with two filenames, the second is parsed as a position operator from Wannier 90 and adds a contribution to band velocities from the Berry connection. The return type is BandEnergyBerryVelocity3D.The keywords period and compact set the reciprocal unit cell length and whether the coefficients of the Fourier series should be compressed as Hermitian matrices. Typically the coefficients cannot be compressed despite the values of the series being Hermitian. The keyword kind can take values :full, :inter, and :intra, referring to whether the Hamiltonian and band velocities are kept in the Wannier gauge, or rotated to the Hamiltonian gauge to take just the inter/intra-band part (i.e. the off-diagonal/diagonal part of the band velocities, respectively).\n\nWarning: a kind of :inter or :intra is incompatible with a non-scalar Σ\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.Applications.load_position_operator","page":"Interfaces","title":"AutoBZ.Applications.load_position_operator","text":"load_position_operator(filename; period=1.0, compact=nothing)\n\nLoad a position operator Hamiltonian output from Wannier90 into filename as an evaluatable ManyFourierSeries with separate x, y, and z components whose periodicity can be set by the keyword argument period which defaults to setting the period along each dimension to 1.0. To define different periods for different dimensions, pass an SVector as the period. To store Hermitian Fourier coefficients in compact form, use the keyword compact to specify:\n\n:N: do not store the coefficients in compact form\n:L: store the lower triangle of the coefficients\n:U: store the upper triangle of the coefficients\n:S: store the lower triangle of the symmetrized coefficients, (c+c')/2\n\nNote that in some cases the coefficients are not Hermitian even though the values of the series are.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.Applications.parse_hamiltonian","page":"Interfaces","title":"AutoBZ.Applications.parse_hamiltonian","text":"parse_hamiltonian(filename)\n\nParse an ab-initio Hamiltonian output from Wannier90 into filename, extracting the fields (date_time, num_wann, nrpts, degen, irvec, C)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.Applications.parse_position_operator","page":"Interfaces","title":"AutoBZ.Applications.parse_position_operator","text":"parse_position_operator(filename)\n\nParse a position operator output from Wannier90 into filename, extracting the fields (date_time, num_wann, nrpts, irvec, X, Y, Z)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#Python","page":"Interfaces","title":"Python","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Julia code, including AutoBZ.jl, can be called from Python using the package PyJulia","category":"page"},{"location":"pages/app/interfaces/#Setup","page":"Interfaces","title":"Setup","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"TL;DR","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"$ julia -e 'import Pkg; Pkg.add(\"PyCall\")'\n$ python3 -m pip install julia","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"If you want to, you can install PyJulia in a Python venv, but on the Julia side PyCall.jl must be installed in the default environment","category":"page"},{"location":"pages/app/interfaces/#Demo","page":"Interfaces","title":"Demo","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The Python snippet below shows how from the demos folder of the AutoBZ repository you can run one of the demo scripts:","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"from julia.api import Julia\njl = Julia(compiled_modules=False)\n\n# julia environment setup in working directory 'demos'\njl.eval(\"\"\"\nimport Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n\"\"\")\n\n# capture output of script\nout = jl.eval('include(\"DOS_test.jl\")')","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The first two lines are adapted for loading PyJulia on Debian systems.","category":"page"},{"location":"pages/app/fourier/#Fourier-series","page":"Fourier series","title":"Fourier series","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Wannier-interpolated Hamiltonians are represented by Fourier series with a modest number of Fourier coefficients. The goal of this page of documentation is to describe the features, interface, and conventions of Fourier series evaluation as implemented by this library.","category":"page"},{"location":"pages/app/fourier/#Conventions","page":"Fourier series","title":"Conventions","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Fourier series represent functions as linear combinations of sinusoids whose frequencies are integer multiples of a fundamental mode. In the band theory of solids, the fundamental frequencies, or normal modes, for a Hamiltonian correspond to linear combinations of real-space lattice vectors that generate a Bravais lattice. The sections below define conventions for each of these linear combinations.","category":"page"},{"location":"pages/app/fourier/#Lattice-vectors","page":"Fourier series","title":"Lattice vectors","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"It is conventional to construct a reciprocal lattice bmb_j from a Bravais lattice bma_i such that ","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"bmb_j cdot bma_i = 2pidelta_ij","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Then we write the momentum space variable in the reciprocal lattice vector basis and the position space variable in the real lattice vector basis","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"bmk = sum_j=1^d k_j bmb_j\nqquad\nbmR = sum_i=1^d R_i bma_i","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Without loss of generality, the k_j can be taken in the domain 01 and the R_i are integers.","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Additionally, any coordinate transformations of bmk from the Cartesian basis to the reciprocal lattice basis only modify Brillouin zone integrals by a multiplicative factor of the absolute value of the determinant of the basis transformation. To find a non-trivial example of representing a Hamiltonian in the reciprocal lattice basis, see the Graphene example with ManyOffsetsFourierSeries.","category":"page"},{"location":"pages/app/fourier/#Series-coefficients","page":"Fourier series","title":"Series coefficients","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Wannier-interpolated Hamiltonians are small matrices obtained by projecting the ab-initio Hamiltonian onto a low energy subspace, a process called downfolding. These Hamiltonians can be expressed by a Fourier series as in the sum below","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"H(bmk) = sum_bmR e^ibmkcdotbmR H_bmR","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"where the coefficients H_bmR are the matrix-valued Fourier coefficients. Truncating the sum over bmR at a modest number of modes can be done for Wannier Hamiltonians in the maximally-localized orbital basis, for which H(bmk) is a smooth and periodic function and thus the truncation error of its Fourier series converges super-algebraically with respect to the number of modes.","category":"page"},{"location":"pages/app/fourier/#Hamiltonian-recipe","page":"Fourier series","title":"Hamiltonian recipe","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"In model systems, a Bloch Hamiltonian can often be written down analytically. The recipe to write it as a Fourier series has two-steps","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Identify the real and reciprocal Bravais lattices, bma_i and bmb_j, and rewrite all of the phase dependences of the Hamiltonian as bmkcdotbmR with each vector in its corresponding basis, as explained above.\nFactor the Hamiltonian into a linear combination of normal modes indexed by the distinct bmR vectors. If the Hamiltonian is matrix-valued, this can be done one matrix element at a time.","category":"page"},{"location":"pages/app/fourier/#Interface","page":"Fourier series","title":"Interface","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.AbstractFourierSeries\nAutoBZ.Applications.period\nAutoBZ.Applications.contract\nAutoBZ.Applications.value","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.AbstractFourierSeries","page":"Fourier series","title":"AutoBZ.Applications.AbstractFourierSeries","text":"AbstractFourierSeries{N}\n\nA supertype for Fourier series that are periodic maps R^N to V where V is any vector space. Typically these can be represented by N-dimensional arrays whose elements belong to the vector space. See the manual section on the AbstractFourierSeries interface.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.period","page":"Fourier series","title":"AutoBZ.Applications.period","text":"period(f::AbstractFourierSeries{N}) where {N}\n\nReturn a NTuple{N} whose m-th element corresponds to the period of f along its m-th input dimension. Typically, these values set the units of length for the problem.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/fourier/#AutoBZ.Applications.contract","page":"Fourier series","title":"AutoBZ.Applications.contract","text":"contract(f::AbstractFourierSeries{N}, x::Number, [dim=N]) where {N}\n\nReturn another Fourier series of dimension N-1 by summing over dimension dim of f with the phase factors evaluated at x. If N=1, this function should return an AbstractFourierSeries{0} that stores the evaluated Fourier series, but has no more input dimensions to contract.\n\nThe default of dim=N is motivated by preserving memory locality in Julia's column-major array format.\n\ncontract(f::AbstractFourierSeries{N}, x::SVector{M}) where {N,M}\n\nContract the outermost indices M of f in order of last(x) to first(x). If M>N, the default behavior is just to try and contract M indices, which will likely lead to an error.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/fourier/#AutoBZ.Applications.value","page":"Fourier series","title":"AutoBZ.Applications.value","text":"value(::AbstractFourierSeries{0})\n\nReturn the evaluated Fourier series whose indices have all been contracted. Typically, this value has the same units as the Fourier series coefficients.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Additonally, concrete subtypes of AbstractFourierSeries must have an element type, which they can do by extending Base.eltype with a method. For example, if a type MyFourierSeries <: AbstractFourierSeries always returns ComplexF64 outputs, then the correct eltype method to define would be:","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"Base.eltype(::Type{MyFourierSeries}) = ComplexF64","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"The type returned should correspond to the vector space V of the output space of the Fourier series, i.e. the output of value should be of this type. For good performance, the eltype should be a concrete type and should be inferrable.","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"With the above implemented, several methods which define functors for AbstractFourierSeries allow the user (and integration routines) to evaluate the type like a function with the f(x) syntax.","category":"page"},{"location":"pages/app/fourier/#Types","page":"Fourier series","title":"Types","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"The concrete types listed below all implement the AbstractFourierSeries interface and should cover most use cases.","category":"page"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.FourierSeries\nAutoBZ.Applications.FourierSeriesDerivative\nAutoBZ.Applications.OffsetFourierSeries\nAutoBZ.Applications.ManyFourierSeries\nAutoBZ.Applications.ManyOffsetsFourierSeries\nAutoBZ.Applications.BandEnergyVelocity\nAutoBZ.Applications.BandEnergyBerryVelocity","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.FourierSeries","page":"Fourier series","title":"AutoBZ.Applications.FourierSeries","text":"FourierSeries(coeffs, period::SVector{N,Float64}) where {N}\n\nConstruct a Fourier series whose coefficients are given by the coefficient array array coeffs whose eltype should support addition and scalar multiplication, and whose periodicity on the ith axis is given by period[i]. This type represents the Fourier series\n\nf(vecx) = sum_vecn in mathcal I C_vecn exp(i2piveck_vecncdotoverrightarrowx)\n\nwhere i = sqrt-1 is the imaginary unit, C is the array coeffs, mathcal I is CartesianIndices(C), vecn is a CartesianIndex and veck_vecn is equal to n_jp_j in the jth position with p_j the jth element of period. Because of the choice to use Cartesian indices to set the phase factors, typically the indices of coeffs should be specified by using an OffsetArray.\n\nFourierSeries(coeffs::AbstractArray{T,N}, period::Real) where {T,N}\n\nIf period is a Real, this constructor will infer the number of input dimensions of the Fourier series from the array dimensionality of the coefficients, and period will become the period of all of the dimensions.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.FourierSeriesDerivative","page":"Fourier series","title":"AutoBZ.Applications.FourierSeriesDerivative","text":"FourierSeriesDerivative(f::FourierSeries{N}, a::SVector{N}) where {N}\n\nRepresent the differential of Fourier series f by a multi-index a of derivatives, e.g. [1,2,...], whose ith entry represents the order of differentiation on the ith input dimension of f. Mathematically, this means\n\nleft( prod_j=1^N partial_x_j^a_j right) f(vecx) = sum_vecn in mathcal I left( prod_j=1^N (i 2pi k_j)^a_j right) C_vecn exp(i2piveck_vecncdotoverrightarrowx)\n\nwhere partial_x_j^a_j represents the a_jth derivative of x_j, i = sqrt-1 is the imaginary unit, C is the array coeffs, mathcal I is CartesianIndices(C), vecn is a CartesianIndex and veck_vecn is equal to n_jp_j in the jth position with p_j the jth element of period. Because of the choice to use Cartesian indices to set the phase factors, typically the indices of coeffs should be specified by using an OffsetArray. Also, note that termwise differentiation of the Fourier series results in additional factors of i2pi which should be anticipated for the use case. Also, note that this type can be used to represent fractional differentiation or integration by suitably choosing the a_js.\n\nThis is a 'lazy' representation of the derivative because instead of differentiating by computing all of the Fourier coefficients of the derivative upon constructing the object, the evaluator waits until it contracts the differentiated dimension to evaluate the new coefficients.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.OffsetFourierSeries","page":"Fourier series","title":"AutoBZ.Applications.OffsetFourierSeries","text":"OffsetFourierSeries(f::AbstractFourierSeries{N}, q::SVector{N,Float64}) where {N}\n\nRepresent a Fourier series whose argument is offset by the vector vecq and evaluates it as f(vecx-vecq).\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.ManyFourierSeries","page":"Fourier series","title":"AutoBZ.Applications.ManyFourierSeries","text":"ManyFourierSeries(fs::AbstractFourierSeries{N}...) where {N}\n\nRepresents a tuple of Fourier series of the same dimension and periodicity and contracts them all simultaneously.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.ManyOffsetsFourierSeries","page":"Fourier series","title":"AutoBZ.Applications.ManyOffsetsFourierSeries","text":"ManyOffsetsFourierSeries(f, qs..., [origin=true])\n\nRepresent a Fourier series evaluated at many different points, and contract them all simultaneously, returning them in the order the qs were passed, i.e. (f(x-qs[1]), f(x-qs[2]), ...) The origin keyword decides whether or not to evaluate f without an offset, and if origin is true, the value of f evaluated without an offset will be returned in the first position of the output.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.BandEnergyVelocity","page":"Fourier series","title":"AutoBZ.Applications.BandEnergyVelocity","text":"BandEnergyVelocity{kind}(H::FourierSeries{N}, V::ManyFourierSeries{N}) where {kind,N}\nBandEnergyVelocity(H::FourierSeries{N}; kind=:full) where N\n\nThe bottom constructor takes a Fourier series representing the Hamiltonian and also evaluates the band velocities so that the return value after all the dimensions are contracted is a tuple containing (H, v₁, v₂, ..., vₙ). The band velocities are defined by dipole operators nu_alpha = frac1hbar partial_k_alpha H where k_alpha is one of three input dimensions of H and hbar=1. Effectively, this type evaluates H and its gradient. Note that differentiation by k changes the units to have an additional dimension of length and a factor of 2pi, so if H has dimensions of energy, nu has dimensions of energy times length. The caller is responsible for transforming the units of the velocity (i.e. hbar) if they want other units, which can usually be done as a post-processing step.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.BandEnergyBerryVelocity","page":"Fourier series","title":"AutoBZ.Applications.BandEnergyBerryVelocity","text":"BandEnergyBerryVelocity{kind}(H::BandEnergyVelocity{Val{:full}(),N}, A::ManyFourierSeries{N}) where {kind,N}\nBandEnergyBerryVelocity(H::BandEnergyVelocity{kind,N}, A::ManyFourierSeries{N,<:NTuple{N}}) where {kind,N}\nBandEnergyBerryVelocity(H::FourierSeries, A; kind=:full)\n\nThis constructor takes a FourierSeries, H, representing the Hamiltonian and also a ManyFourierSeries, A, representing the gradient of the Berry connection, and evaluates modified band velocities so that the return value after all the dimensions are contracted is a tuple containing (H, ṽ₁, ṽ₂, ..., ṽₙ). The modified band velocities are defined by\n\ntildenu_alpha = frac1hbar partial_k_alpha H -\n\fracihbar H(A_alpha + A_alpha^dagger)2\n\nwhere k_alpha is one of three input dimensions of H and hbar=1. Effectively, this type evaluates the Hamiltonian and its gradient modified by a commutator of the Hamiltonian with the gradient of the Berry connection. Note that differentiation by k changes the units to have an additional dimension of length and a factor of 2pi, so if H has dimensions of energy, nu has dimensions of energy times length. The caller is responsible for transforming the units of the velocity (i.e. hbar) if they want other units, which can usually be done as a post-processing step.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#Methods","page":"Fourier series","title":"Methods","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.contract(::AutoBZ.Applications.AbstractFourierSeries)","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.contract-Tuple{AutoBZ.Applications.AbstractFourierSeries}","page":"Fourier series","title":"AutoBZ.Applications.contract","text":"contract(f::FourierSeries{N}, x::Number, [dim=N]) where N\n\nContract index dim of the coefficients of f at the spatial point x. The default dim is the outermost dimension to preserve memory locality.\n\n\n\n\n\ncontract(f::FourierSeriesDerivative{N}, x::Number, [dim=N]) where {N}\n\nContract index dim of the coefficients of f at the spatial point x. The default dim is the outermost dimension to preserve memory locality.\n\n\n\n\n\n","category":"method"},{"location":"pages/app/fourier/#Optimized-3D-evaluators","page":"Fourier series","title":"Optimized 3D evaluators","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"For the use-case of Wannier90 calculations, the following Fourier series evaluators are optimized to improve performance by reducing allocations.","category":"page"},{"location":"pages/app/fourier/#Interface-2","page":"Fourier series","title":"Interface","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.AbstractFourierSeries3D\nAutoBZ.Applications.contract!","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.AbstractFourierSeries3D","page":"Fourier series","title":"AutoBZ.Applications.AbstractFourierSeries3D","text":"AbstractFourierSeries3D <: AbstractFourierSeries{3}\n\nAn abstract subtype of AbstractFourierSeries{3} representing in-place Fourier series evaluators\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.contract!","page":"Fourier series","title":"AutoBZ.Applications.contract!","text":"contract!(f::AbstractFourierSeries3D, x::Number, dim::Int)\n\nAn in-place version of contract.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/fourier/#Types-2","page":"Fourier series","title":"Types","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.FourierSeries3D\nAutoBZ.Applications.BandEnergyVelocity3D\nAutoBZ.Applications.BandEnergyBerryVelocity3D","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.FourierSeries3D","page":"Fourier series","title":"AutoBZ.Applications.FourierSeries3D","text":"FourierSeries3D(coeffs::Array{T,3}, [period=(1.0, 1.0, 1.0)])\n\nThis type is an AbstractFourierSeries{3} designed for in-place evaluation of FourierSeries, and unlike FourierSeries is specialized for 3D Fourier series and does not allocate a new array every time contract is called on it. This type stores the intermediate arrays used in a calculation and assumes that the size of coeffs on each axis is odd because it treats the zeroth harmonic as the center of the array (i.e. (size(coeffs) .÷ 2) .+ 1).\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.BandEnergyVelocity3D","page":"Fourier series","title":"AutoBZ.Applications.BandEnergyVelocity3D","text":"BandEnergyVelocity3D(coeffs, [period=(1.0,1.0,1.0), kind=:full])\nBandEnergyVelocity3D(H::FourierSeries3D, [kind=:full])\n\nThe in-place equivalent of BandEnergyVelocity for 3D series evaluation.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#AutoBZ.Applications.BandEnergyBerryVelocity3D","page":"Fourier series","title":"AutoBZ.Applications.BandEnergyBerryVelocity3D","text":"BandEnergyBerryVelocity3D(H::FourierSeries3D{TH,0,0,0}, Ax::FourierSeries3D{TA,0,0,0}, Ay::FourierSeries3D{TA,0,0,0}, Az::FourierSeries3D{TA,0,0,0}, [kind=:full]) where {TH,TA}\n\nThe in-place equivalent of BandEnergyBerryVelocity for 3D series evaluation.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/fourier/#Methods-2","page":"Fourier series","title":"Methods","text":"","category":"section"},{"location":"pages/app/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.Applications.contract!(::AutoBZ.Applications.AbstractFourierSeries3D)\nAutoBZ.Applications.fourier_kernel!","category":"page"},{"location":"pages/app/fourier/#AutoBZ.Applications.fourier_kernel!","page":"Fourier series","title":"AutoBZ.Applications.fourier_kernel!","text":"fourier_kernel!(r::Array{T,N-1}, C::Array{T,N}, x, ξ, [::Val{a}=Val{0}()]) where {T,N,a}\n\nContract the outermost index of array C and write it to the array r. Assumes the size of the outermost dimension of C is 2m+1 and sums the coefficients\n\nr_i_1dotsi_N-1 = sum_i_N=-m^m C_i_1dotsi_N-1i_N+m+1 (i2pixi i_N)^a exp(i2pixi x i_N)\n\nHence this represents evaluation of a Fourier series with m modes. The parameter a represents the order of derivative of the Fourier series.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#Integration-limits","page":"Integration limits","title":"Integration limits","text":"","category":"section"},{"location":"pages/man/integration_limits/#Interface","page":"Integration limits","title":"Interface","text":"","category":"section"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"IntegrationLimits\nlower\nupper\nbox\nsymmetries\nndims\nnsyms","category":"page"},{"location":"pages/man/integration_limits/#AutoBZ.IntegrationLimits","page":"Integration limits","title":"AutoBZ.IntegrationLimits","text":"IntegrationLimits{d}\n\nRepresents a set of integration limits over d variables. Realizations of this type should implement lower and upper, which return the lower and upper limits of integration along some dimension, rescale which represents the number of symmetries of the BZ which are used by the realization to reduce the BZ (the integrand over the limits gets multiplied by this factor), and a functor that accepts a single numeric argument and returns another realization of that type (in order to do nested integration). Thus the realization is also in control of the order of variables of integration and must coordinate this behavior with their integrand. Instances should also be static structs.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/integration_limits/#AutoBZ.lower","page":"Integration limits","title":"AutoBZ.lower","text":"lower(::IntegrationLimits)\n\nReturn the lower limit of the next variable of integration. If a vector is returned, then the integration routine may attempt to multidimensional integration.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.upper","page":"Integration limits","title":"AutoBZ.upper","text":"upper(::IntegrationLimits)\n\nReturn the upper limit of the next variable of integration. If a vector is returned, then the integration routine may attempt to multidimensional integration.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.box","page":"Integration limits","title":"AutoBZ.box","text":"box(::IntegrationLimits)\n\nReturn an iterator of tuples that for each dimension returns a tuple with the lower and upper limits of the integration domain without symmetries applied.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.symmetries","page":"Integration limits","title":"AutoBZ.symmetries","text":"symmetries(::IntegrationLimits)\n\nReturn an iterator over the symmetry transformations that the parametrization has used to reduce the volume of the integration domain.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#Base.ndims","page":"Integration limits","title":"Base.ndims","text":"ndims(::IntegrationLimits{d})\n\nReturns d. This is a type-based rule.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.nsyms","page":"Integration limits","title":"AutoBZ.nsyms","text":"nsyms(::IntegrationLimits)\n\nReturn the number of symmetries that the parametrization has used to reduce the volume of the integration domain.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"Additionally, all IntegrationLimits must extend Base.eltype to return the type which is the output of lower and upper, which is the type of coordinates in the domain.","category":"page"},{"location":"pages/man/integration_limits/#Types","page":"Integration limits","title":"Types","text":"","category":"section"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"CubicLimits\nCompositeLimits","category":"page"},{"location":"pages/man/integration_limits/#AutoBZ.CubicLimits","page":"Integration limits","title":"AutoBZ.CubicLimits","text":"CubicLimits(a, [b])\n\nStore integration limit information for a hypercube with vertices a and b. If b is not passed as an argument, then the lower limit defaults to zero(a).\n\n\n\n\n\n","category":"type"},{"location":"pages/man/integration_limits/#AutoBZ.CompositeLimits","page":"Integration limits","title":"AutoBZ.CompositeLimits","text":"CompositeLimits(lims::IntegrationLimits...)\nCompositeLimits(::Tuple{Vararg{IntegrationLimits}})\n\nConstruct a collection of limits which yields the first limit followed by the second, and so on.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/integration_limits/#Routines","page":"Integration limits","title":"Routines","text":"","category":"section"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"vol\nsymmetrize\nAutoBZ.discretize_equispace","category":"page"},{"location":"pages/man/integration_limits/#AutoBZ.vol","page":"Integration limits","title":"AutoBZ.vol","text":"vol(::IntegrationLimits)\n\nReturn the volume of the full domain without the symmetries applied\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.symmetrize","page":"Integration limits","title":"AutoBZ.symmetrize","text":"symmetrize(::IntegrationLimits, x)\nsymmetrize(::IntegrationLimits, xs...)\n\nTransform x by the symmetries of the parametrization used to reduce the domain, thus mapping the value of x on the parametrization to the full domain. When the integrand is a scalar, this is equal to nsyms(l)*x. When the integrand is a vector, this is sum(S*x for S in symmetries(l)). When the integrand is a matrix, this is sum(S*x*S' for S in symmetries(l)).\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.discretize_equispace","page":"Integration limits","title":"AutoBZ.discretize_equispace","text":"discretize_equispace(::IntegrationLimits, ::Integer)\n\nReturn an iterator of 2-tuples containing integration nodes and weights that correspond to an equispace integration grid with the symmetry transformations applied to it.\n\n\n\n\n\n","category":"function"},{"location":"#AutoBZ.jl-documentation","page":"Home","title":"AutoBZ.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package provides routines for multi-dimensional Brillouin zone (BZ) integration of both generic and Wannier-interpolated integrands. It aims to implement algorithms which automatically compute BZ integrals to a specified error tolerance by resolving smooth yet highly localized integrands.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In many-body Green's function methods, BZ integrands are localized at a scale determined by a non-zero, but possibly small, system- and temperature-dependent scattering rate. For example, the single-particle retarded Green's function of an electronic system for frequency omega and reciprocal space vector bmk with chemical potential mu, Hermitian Hamiltonian matrix H(bmk), and self-energy matrix Sigma(omega), which is given by","category":"page"},{"location":"","page":"Home","title":"Home","text":"G(omega) = int_textBZ dbmk operatornameTr left (hbaromega + mu - H(bmk) - Sigma(omega))^-1 right","category":"page"},{"location":"","page":"Home","title":"Home","text":"is localized about the manifold defined by det(omega + mu - H(bmk))=0 (i.e. the Fermi surface when omega=0) by a scattering rate depending on operatornameIm Sigma(omega).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To start using the package, see the Workflow and Demos sections.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"#Implemented","page":"Home","title":"Implemented","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Iterated adaptive integration (IAI) with nested calls to QuadGK.jl\nAlgorithm with logarithmic complexity for increasingly localized integrands\nIrreducible Brillouin zone (IBZ) integration for the cubic lattice\nEquispace integration (PTR) as described by Kaye et al. [1]\nAutomatic algorithm that refines k-grid to meet requested error\nIBZ integration for arbitrary symmetry groups\nSupport for Wannier-interpolated integrands in the Applications module\nUser-defined integrands based on Bloch Hamiltonians\nDensity of states (DOS) calculations\nTransport calculations based on    TRIQS DFTTools\nCalculation of transport function and kinetic coefficients\nOption to separate intra-band and inter-band contributions\nParallelized calculations available through Jobs module\nWannier90-based parsers Hamiltonians (*_hr.dat files) and position operators (*_r.dat files)\nSupport for frequency-dependent self energy evaluators from data on uniform grids with the EquiBaryInterp module\n1D adaptive Chebyshev interpolation in the AdaptChebInterp module   using FastChebInterp.jl","category":"page"},{"location":"#In-progress","page":"Home","title":"In progress","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IAI with IBZ integration for arbitrary symmetry groups (via an interface to SymmetryReduceBZ.jl)\nInterface to read frequency-dependent matrix-valued self-energy data","category":"page"},{"location":"#More-ideas","page":"Home","title":"More ideas","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multi-dimensional adaptive Chebyshev interpolation, like baobzi\nGlobally adaptive IAI","category":"page"},{"location":"#Notes","page":"Home","title":"Notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are an interested Python user, see the Python section","category":"page"},{"location":"","page":"Home","title":"Home","text":"To see a poster showcasing calculations with the library, click this link","category":"page"},{"location":"","page":"Home","title":"Home","text":"For tree-adaptive integration (TAI) on the full BZ, see HCubature.jl","category":"page"},{"location":"#Contact-the-developer","page":"Home","title":"Contact the developer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Lorenzo Van Muñoz","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: Kaye et al. \"Automatic, high-order, and adaptive algorithms for Brillouin zone integration\"","category":"page"}]
}
