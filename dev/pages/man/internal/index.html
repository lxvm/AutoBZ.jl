<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal · AutoBZ.jl</title><meta name="title" content="Internal · AutoBZ.jl"/><meta property="og:title" content="Internal · AutoBZ.jl"/><meta property="twitter:title" content="Internal · AutoBZ.jl"/><meta name="description" content="Documentation for AutoBZ.jl."/><meta property="og:description" content="Documentation for AutoBZ.jl."/><meta property="twitter:description" content="Documentation for AutoBZ.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">AutoBZ.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../fourier/">Fourier series</a></li><li><a class="tocitem" href="../../app/self_energy/">Self energies</a></li><li><a class="tocitem" href="../../app/integrands/">Integrands</a></li><li><a class="tocitem" href="../../app/interfaces/">Interfaces</a></li></ul></li><li><a class="tocitem" href="../../demo/">Demos</a></li><li><a class="tocitem" href="../../workflow/">Workflow</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internal</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lxvm/AutoBZ.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lxvm/AutoBZ.jl/blob/main/docs/src/pages/man/internal.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h1><p>The following symbols used by AutoBZ may change in future versions</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.SSymmetricCompact" href="#AutoBZ.SSymmetricCompact"><code>AutoBZ.SSymmetricCompact</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SSymmetricCompact{N, T, L} &lt;: StaticMatrix{N, N, T}</code></pre><p>A <code>StaticArray</code> subtype that represents a Symmetric matrix. Unlike <code>LinearAlgebra.Symmetric</code>, <code>SSymmetricCompact</code> stores only the lower triangle of the matrix (as an <code>SVector</code>). The lower triangle is stored in column-major order. For example, for an <code>SSymmetricCompact{3}</code>, the indices of the stored elements can be visualized as follows:</p><pre><code class="nohighlight hljs">┌ 1 ⋅ ⋅ ┐
| 2 4 ⋅ |
└ 3 5 6 ┘</code></pre><p>Type parameters:</p><ul><li><code>N</code>: matrix dimension;</li><li><code>T</code>: element type for lower triangle;</li><li><code>L</code>: length of the <code>SVector</code> storing the lower triangular elements.</li></ul><p>Note that <code>L</code> is always the <code>N</code>th <a href="https://en.wikipedia.org/wiki/Triangular_number">triangular number</a>.</p><p>An <code>SSymmetricCompact</code> may be constructed either:</p><ul><li>from an <code>AbstractVector</code> containing the lower triangular elements; or</li><li>from a <code>Tuple</code> containing both upper and lower triangular elements in column major order; or</li><li>from another <code>StaticMatrix</code>.</li></ul><p>For the latter two cases, only the lower triangular elements are used; the upper triangular elements are ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/SSymmetricCompact.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.hinv" href="#AutoBZ.hinv"><code>AutoBZ.hinv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hinv(A::SHermitianCompact{3})</code></pre><p>Calculate the inverse of a <code>SHermitianCompact</code> matrix using its lower triangle. Note that if the elements on the diagonal are complex, the inverse is not Hermitian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/linalg.jl#L14-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.dos_integrand" href="#AutoBZ.dos_integrand"><code>AutoBZ.dos_integrand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dos_integrand(h, M)</code></pre><p>Returns <code>-imag(tr(inv(M-h)))/pi</code> where <code>M = ω*I-Σ(ω)</code>. It is unsafe to use this in the inner integral for small eta due to the localized tails of the integrand. The default, safe version also integrates the real part which is less localized, at the expense of a slight slow-down due to complex arithmetic. See <a href="../../app/integrands/#AutoBZ.TrGlocIntegrand"><code>TrGlocIntegrand</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/apps.jl#L55-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractGauge" href="#AutoBZ.AbstractGauge"><code>AutoBZ.AbstractGauge</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGauge</code></pre><p>Abstract supertype of gauges (or bases) for orbital/band indices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.Hamiltonian" href="#AutoBZ.Hamiltonian"><code>AutoBZ.Hamiltonian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Hamiltonian &lt;: AbstractGauge</code></pre><p>Singleton type representing the Hamiltonian gauge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.tr_kron" href="#AutoBZ.tr_kron"><code>AutoBZ.tr_kron</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tr_kron(A::T, B::T) where {T&lt;:SVector{AbstractMatrix}}</code></pre><p>Returns a matrix whose <code>[i,j]</code>th entry is <code>tr(A[i]*B[j])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/linalg.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.gloc_integrand" href="#AutoBZ.gloc_integrand"><code>AutoBZ.gloc_integrand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gloc_integrand(h, M)</code></pre><p>Returns <code>inv(M-h)</code> where <code>M = ω*I-Σ(ω)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/apps.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractGaugeInterp" href="#AutoBZ.AbstractGaugeInterp"><code>AutoBZ.AbstractGaugeInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractGaugeInterp{G,N,T,iip} &lt;: AbstractWannierInterp{N,T,iip}</code></pre><p>An abstract subtype of <code>AbstractFourierSeries</code> representing in-place Fourier series evaluators for Wannier-interpolated quantities with a choice of basis, or gauge, <code>G</code>, which is typically <a href="#AutoBZ.Hamiltonian"><code>Hamiltonian</code></a> or <a href="#AutoBZ.Wannier"><code>Wannier</code></a>. For details, see <a href="#AutoBZ.to_gauge"><code>to_gauge</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.diag_inv" href="#AutoBZ.diag_inv"><code>AutoBZ.diag_inv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diag_inv(A)</code></pre><p>Calculate the diagonal entries of the inverse of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/linalg.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AutoBZ" href="#AutoBZ.AutoBZ"><code>AutoBZ.AutoBZ</code></a> — <span class="docstring-category">Module</span></header><section><div><p>An applications package implementing iterated-adaptive integration and equispace integration for electronic structure and transport calculations. It excels at integrating both localized and also broadened Brillouin-zone integrands, using the algorithms described by <a href="http://arxiv.org/abs/2211.12959">Kaye et al.</a>. This package also provides multi-threaded routines for parallelized calculations. See <code>AutoBZCore</code> if you only need the essential functionality of the library to define custom BZ integrands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/AutoBZ.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.ConstScalarSelfEnergy" href="#AutoBZ.ConstScalarSelfEnergy"><code>AutoBZ.ConstScalarSelfEnergy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstScalarSelfEnergy(v::Number)</code></pre><p>Construct a self-energy evaluator which returns <span>$v I$</span> for any frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/self_energies.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.tr_mul" href="#AutoBZ.tr_mul"><code>AutoBZ.tr_mul</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tr_mul(A, B)</code></pre><p>Calculate <code>tr(A*B)</code> without storing the intermediate result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/linalg.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.to_gauge" href="#AutoBZ.to_gauge"><code>AutoBZ.to_gauge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_gauge(::AbstractGauge, h) where gauge</code></pre><p>Transform the Hamiltonian according to the following values of <code>gauge</code></p><ul><li><a href="#AutoBZ.Wannier"><code>Wannier</code></a>: keeps <code>h, vs</code> in the original, orbital basis</li><li><a href="#AutoBZ.Hamiltonian"><code>Hamiltonian</code></a>: diagonalizes <code>h</code> and rotates <code>h</code> into the energy, band basis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L71-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractVelocityInterp" href="#AutoBZ.AbstractVelocityInterp"><code>AutoBZ.AbstractVelocityInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVelocityInterp{C,B,G,N,T,iip} &lt;:AbstractCoordInterp{B,G,N,T,iip}</code></pre><p>An abstract subtype of <code>AbstractCoordInterp</code> also containing information the velocity component, <code>C</code>, which is typically <code>Val(:whole)</code>, <code>Val(:inter)</code>, or <code>Val(:intra)</code>. For details see <a href="#AutoBZ.to_vcomp_gauge"><code>to_vcomp_gauge</code></a>. Since the velocity depends on the Hamiltonian, subtypes should also evaluate the Hamiltonian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L354-L362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.fermi_window_halfwidth" href="#AutoBZ.fermi_window_halfwidth"><code>AutoBZ.fermi_window_halfwidth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fermi_window_halfwidth(Ω, β, atol)
fermi_window_halfwidth(β, atol)</code></pre><p>One can show that β<em>Ω</em>fermi<em>window(ω, β, Ω) = -tanh(β<em>Ω/2)/(cosh(β</em>(ω+Ω/2))/cosh(β<em>Ω/2)+1) &gt; -tanh(β</em>Ω/2)/(exp(abs(β<em>(ω+Ω/2)))/2cosh(β</em>Ω/2)+1) as well as when Ω==0, β*fermi</em>window(ω, β, 0.0) = and these can be inverted to give a good bound on the width of the frequency window for which the Fermi window function is greater than <code>atol</code>. Returns half the width of this window.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/fermi.jl#L110-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.diaggloc_integrand" href="#AutoBZ.diaggloc_integrand"><code>AutoBZ.diaggloc_integrand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diaggloc_integrand(h, M)</code></pre><p>Returns <code>diag(inv(M-h))</code> where <code>M = ω*I-Σ(ω)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/apps.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.Wannier" href="#AutoBZ.Wannier"><code>AutoBZ.Wannier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Wannier &lt;: AbstractGauge</code></pre><p>Singleton type representing the Wannier gauge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.DiagonalSelfEnergy" href="#AutoBZ.DiagonalSelfEnergy"><code>AutoBZ.DiagonalSelfEnergy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiagonalSelfEnergy(interpolant, lb, ub)</code></pre><p>Construct a self-energy evaluator which for frequencies above <code>lb</code> and below <code>ub</code> returns the vector interpolant at that frequency wrapped by a <code>Diagonal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/self_energies.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.CoordDefault" href="#AutoBZ.CoordDefault"><code>AutoBZ.CoordDefault</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">CoordDefault(::Type{T})::AbstractCoordinate where T</code></pre><p><a href="#AutoBZ.AbstractCoordInterp"><code>AbstractCoordInterp</code></a>s should define this trait to declare the coordinate basis where they assume their data is in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L240-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.CartesianRep" href="#AutoBZ.CartesianRep"><code>AutoBZ.CartesianRep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CartesianRep()</code></pre><p>Symmetry representation of objects that transform under the group action in the same way as the lattice and in Cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.to_coord" href="#AutoBZ.to_coord"><code>AutoBZ.to_coord</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_coord(B::AbstractCoordinate, D::AbstractCoordinate, A, vs)</code></pre><p>If <code>B</code> and <code>D</code> are the same type return <code>vs</code>, however and if they differ return <code>A*vs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractWannierInterp" href="#AutoBZ.AbstractWannierInterp"><code>AutoBZ.AbstractWannierInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractWannierInterp{N,T,iip} &lt;: AbstractFourierSeries{N,T,iip}</code></pre><p>Abstract supertype for all Wannier-interpolated quantities in <code>AutoBZ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractVelocityComponent" href="#AutoBZ.AbstractVelocityComponent"><code>AutoBZ.AbstractVelocityComponent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVelocityComponent</code></pre><p>Abstract supertype representing velocity components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractCoordInterp" href="#AutoBZ.AbstractCoordInterp"><code>AutoBZ.AbstractCoordInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCoordInterp{B,G,N,T,iip} &lt;:AbstractGaugeInterp{G,N,T,iip}</code></pre><p>An abstract subtype of <code>AbstractGaugeInterp</code> also containing information about the coordinate basis <code>B</code>, which is either <a href="#AutoBZ.Lattice"><code>Lattice</code></a> or <a href="#AutoBZ.Cartesian"><code>Cartesian</code></a>. For details see <a href="#AutoBZ.to_coord"><code>to_coord</code></a> and <a href="#AutoBZ.CoordDefault"><code>CoordDefault</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L230-L237">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.shift!" href="#AutoBZ.shift!"><code>AutoBZ.shift!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shift!(h::AbstractHamiltonianInterp, λ::Number)</code></pre><p>Modifies and returns <code>h</code> such that it returns <code>h - λ*I</code>. Will throw a <code>BoundsError</code> if this operation cannot be done on the existing data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L142-L147">source</a></section><section><div><pre><code class="language-julia hljs">shift!(::AbstractVelocityInterp, λ)</code></pre><p>Offset the zero-point energy in a Hamiltonian system by a constant</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L404-L408">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractHamiltonianInterp" href="#AutoBZ.AbstractHamiltonianInterp"><code>AutoBZ.AbstractHamiltonianInterp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractHamiltonianInterp{G,N,T,iip} &lt;: AbstractGaugeInterp{G,N,T,iip}</code></pre><p>Abstract type representing Hamiltonians, which are matrix-valued Hermitian Fourier series. They should also have period 1, but produce derivatives with wavenumber 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.AbstractCoordinate" href="#AutoBZ.AbstractCoordinate"><code>AutoBZ.AbstractCoordinate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCoordinate</code></pre><p>Abstract supertype of bases for coordinate/spatial indices</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.Cartesian" href="#AutoBZ.Cartesian"><code>AutoBZ.Cartesian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cartesian &lt;: AbstractCoordinate</code></pre><p>Singleton type representing Cartesian coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.tr_inv" href="#AutoBZ.tr_inv"><code>AutoBZ.tr_inv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tr_inv(A)</code></pre><p>Calculate the trace of the inverse of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/linalg.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.to_vcomp_gauge" href="#AutoBZ.to_vcomp_gauge"><code>AutoBZ.to_vcomp_gauge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_vcomp_gauge(::Val{C}, ::Val{G}, h, vs...) where {C,G}</code></pre><p>Take the velocity components of <code>vs</code> in any gauge according to the value of <code>C</code></p><ul><li><a href="../fourier/#AutoBZ.Whole"><code>Whole</code></a>: return the whole velocity (sum of interband and intraband components)</li><li><a href="../fourier/#AutoBZ.Intra"><code>Intra</code></a>: return the intraband velocity (diagonal in Hamiltonian gauge)</li><li><a href="../fourier/#AutoBZ.Inter"><code>Inter</code></a>: return the interband velocity (off-diagonal terms in Hamiltonian gauge)</li></ul><p>Transform the velocities into a gauge according to the following values of <code>G</code></p><ul><li><a href="#AutoBZ.Wannier"><code>Wannier</code></a>: keeps <code>H, vs</code> in the original, orbital basis</li><li><a href="#AutoBZ.Hamiltonian"><code>Hamiltonian</code></a>: diagonalizes <code>H</code> and rotates <code>H, vs</code> into the energy, band basis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L306-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.get_safe_fermi_window_limits" href="#AutoBZ.get_safe_fermi_window_limits"><code>AutoBZ.get_safe_fermi_window_limits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_safe_fermi_window_limits(Ω, β, lb, ub)</code></pre><p>Given a frequency, <code>Ω</code>, inverse temperature, <code>β</code>,  returns an interval <code>(l,u)</code> with possibly truncated limits of integration for the frequency integral at each <code>(Ω, β)</code> point that are determined by the <a href="../../app/integrands/#AutoBZ.fermi_window_limits"><code>fermi_window_limits</code></a> routine set to the default tolerances for the decay of the Fermi window function. The arguments <code>lb</code> and <code>ub</code> are lower and upper limits on the frequency to which the default result gets truncated if the default result would recommend a wider interval. If there is any truncation, a warning is emitted to the user, but the program will continue with the truncated limits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/apps.jl#L532-L543">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.parent" href="#Base.parent"><code>Base.parent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parent(::AbstractHamiltonianInterp)::FourierSeries</code></pre><p>Return the Fourier series that the Hamiltonian wraps</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L126-L130">source</a></section><section><div><pre><code class="language-julia hljs">parent(::AbstractVelocityInterp)::DerivativeSeries</code></pre><p>Return the Hamiltonian object used for Wannier interpolation</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L389-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.commutator" href="#AutoBZ.commutator"><code>AutoBZ.commutator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">commutator(A, B)</code></pre><p>Return the commutator <code>[A, B] = A*B - B*A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/linalg.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.trgloc_integrand" href="#AutoBZ.trgloc_integrand"><code>AutoBZ.trgloc_integrand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">trgloc_integrand(h, M)</code></pre><p>Returns <code>tr(inv(M-h))</code> where <code>M = ω*I-Σ(ω)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/apps.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.covariant_velocity" href="#AutoBZ.covariant_velocity"><code>AutoBZ.covariant_velocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">covariant_velocity(H, Hα, Aα)</code></pre><p>Evaluates the velocity operator <span>$\hat{v}_{\alpha} = -\frac{i}{\hbar} [\hat{r}_{\alpha}, \hat{H}]$</span> with the following expression, equivalent to eqn. 18 in <a href="https://doi.org/10.1103/PhysRevB.75.195121">Yates et al.</a></p><p class="math-container">\[\hat{v}_{\alpha} = \frac{1}{\hbar} \hat{H}_{\alpha} + \frac{i}{\hbar} [\hat{H}, \hat{A}_{\alpha}]\]</p><p>where the <span>$\alpha$</span> index implies differentiation by <span>$k_{\alpha}$</span>. Note that the terms that correct the derivative of the band velocity Also, this function takes <span>$\hbar = 1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/interp.jl#L153-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.coord" href="#AutoBZ.coord"><code>AutoBZ.coord</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coord(::AbstractCoordInterp{B})::AbstractCoordinate where B = B</code></pre><p>Return the <a href="#AutoBZ.AbstractCoordinate"><code>AbstractCoordinate</code></a> basis in which an <a href="#AutoBZ.AbstractCoordInterp"><code>AbstractCoordInterp</code></a> will be evaluated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L248-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.LatticeRep" href="#AutoBZ.LatticeRep"><code>AutoBZ.LatticeRep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LatticeRep()</code></pre><p>Symmetry representation of objects that transform under the group action in the same way as the lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L178-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.SOC" href="#AutoBZ.SOC"><code>AutoBZ.SOC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SOC(A)</code></pre><p>Wrapper for a matrix A that should be used as a block-diagonal matrix     [A 0      0 A] as when dealing with spin-orbit coupling</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/soc.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.GaugeDefault" href="#AutoBZ.GaugeDefault"><code>AutoBZ.GaugeDefault</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">GaugeDefault(::Type{T})::AbstractCoordinate where T</code></pre><p><a href="#AutoBZ.AbstractGaugeInterp"><code>AbstractGaugeInterp</code></a>s should define this trait to declare the gauge that they assume their data is in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.VcompDefault" href="#AutoBZ.VcompDefault"><code>AutoBZ.VcompDefault</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">VcompDefault(::Type{T})::AbstractVelocityComponent where T</code></pre><p><a href="#AutoBZ.AbstractVelocityInterp"><code>AbstractVelocityInterp</code></a>s should define this trait to declare the velocity component that they assume their data is in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L367-L372">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.herm" href="#AutoBZ.herm"><code>AutoBZ.herm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">herm(A::AbstractMatrix)</code></pre><p>Return the Hermitian part of the matrix <code>A</code>, i.e. <code>(A+A&#39;)/2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/linalg.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AutoBZ.Lattice" href="#AutoBZ.Lattice"><code>AutoBZ.Lattice</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Lattice &lt;: AbstractCoordinate</code></pre><p>Singleton type representing lattice coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/5703a5d1680dd6bffb174c109033a5d4e5b5d554/src/definitions.jl#L164-L168">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Thursday 16 November 2023 20:57">Thursday 16 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
