<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fourier series · AutoBZ.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">AutoBZ.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/adaptive_integration/">Adaptive integration</a></li><li><a class="tocitem" href="../../man/equispace_integration/">Equispace integration</a></li><li><a class="tocitem" href="../../man/integration_limits/">Integration limits</a></li></ul></li><li><span class="tocitem">Applications</span><ul><li class="is-active"><a class="tocitem" href>Fourier series</a><ul class="internal"><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../integrands/">Integrands</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li></ul></li><li><a class="tocitem" href="../../demo/">Demos</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Applications</a></li><li class="is-active"><a href>Fourier series</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fourier series</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lxvm/AutoBZ.jl/blob/main/docs/src/pages/app/fourier.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Fourier-series"><a class="docs-heading-anchor" href="#Fourier-series">Fourier series</a><a id="Fourier-series-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-series" title="Permalink"></a></h1><p>Wannier-interpolated Hamiltonians are represented by Fourier series with a modest number of Fourier coefficients. The goal of this page of documentation is to describe the features, interface, and conventions of Fourier series evaluation as implemented by this library.</p><div class="admonition is-info"><header class="admonition-header">Representing Hamiltonians with Fourier series</header><div class="admonition-body"><p>Fourier series represent functions with sinusoids whose frequencies are integer multiples of a fundamental. In the band theory of solids, the fundamental frequencies for a Hamiltonian correspond to the real-space lattice vectors that generate a Bravais lattice, and so it is best to represent the momentum variable <span>$\vec{k}$</span> in the basis of the reciprocal lattice. Since it is conventional to construct a reciprocal lattice <span>$\{\vec{b}_j\}$</span> from a Bravais lattice <span>$\{\vec{a}_i\}$</span> such that <span>$\vec{b}_j \cdot \vec{a}_i = 2\pi\delta_{ij}$</span>, the Fourier series in this library are defined with a phase factor scaled by <span>$2\pi$</span>. Additionally, any coordinate transformations of <span>$\vec{k}$</span> from the Cartesian basis to the reciprocal lattice basis only modify Brillouin zone integrals by a multiplicative factor of the absolute value of the determinant of the basis transformation. To find a non-trivial example of representing a Hamiltonian in the reciprocal lattice basis, see the <a href="../../demo/#Graphene-example-with-ManyOffsetsFourierSeries">Graphene example with <code>ManyOffsetsFourierSeries</code></a>.</p></div></div><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.Applications.AbstractFourierSeries" href="#AutoBZ.Applications.AbstractFourierSeries"><code>AutoBZ.Applications.AbstractFourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFourierSeries{N}</code></pre><p>A supertype for Fourier series that are periodic maps <span>$\R^N \to V$</span> where <span>$V$</span> is any vector space. Typically these can be represented by <code>N</code>-dimensional arrays whose elements belong to the vector space. See the manual section on the <code>AbstractFourierSeries</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/cd3cd8cf0346c42399a330129727dfc91170e093/src/FourierSeries.jl#L7-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.Applications.period" href="#AutoBZ.Applications.period"><code>AutoBZ.Applications.period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">period(f::AbstractFourierSeries{N}) where {N}</code></pre><p>Return a <code>NTuple{N}</code> whose <code>m</code>-th element corresponds to the period of <code>f</code> along its <code>m</code>-th input dimension. Typically, these values set the units of length for the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/cd3cd8cf0346c42399a330129727dfc91170e093/src/FourierSeries.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.Applications.contract" href="#AutoBZ.Applications.contract"><code>AutoBZ.Applications.contract</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contract(f::AbstractFourierSeries{N}, x::Number, [dim=N]) where {N}</code></pre><p>Return another Fourier series of dimension <code>N-1</code> by summing over dimension <code>dim</code> of <code>f</code> with the phase factors evaluated at <code>x</code>. If <code>N=1</code>, this function should return an <code>AbstractFourierSeries{0}</code> that stores the evaluated Fourier series, but has no more input dimensions to contract.</p><p>The default of <code>dim=N</code> is motivated by preserving memory locality in Julia&#39;s column-major array format.</p><pre><code class="nohighlight hljs">contract(f::AbstractFourierSeries{N}, x::SVector{M}) where {N,M}</code></pre><p>Contract the outermost indices <code>M</code> of <code>f</code> in order of <code>last(x)</code> to <code>first(x)</code>. If <code>M&gt;N</code>, the default behavior is just to try and contract <code>M</code> indices, which will likely lead to an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/cd3cd8cf0346c42399a330129727dfc91170e093/src/FourierSeries.jl#L26-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.Applications.value" href="#AutoBZ.Applications.value"><code>AutoBZ.Applications.value</code></a> — <span class="docstring-category">Function</span></header><section><div><p>value(::AbstractFourierSeries{0})</p><p>Return the evaluated Fourier series whose indices have all been contracted. Typically, this value has the same units as the Fourier series coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/cd3cd8cf0346c42399a330129727dfc91170e093/src/FourierSeries.jl#L47-L52">source</a></section></article><p>Additonally, concrete subtypes of <code>AbstractFourierSeries</code> must have an element type, which they can do by extending <code>Base.eltype</code> with a method. For example, if a type <code>MyFourierSeries &lt;: AbstractFourierSeries</code> always returns <code>ComplexF64</code> outputs, then the correct <code>eltype</code> method to define would be:</p><pre><code class="language-julia hljs">Base.eltype(::Type{MyFourierSeries}) = ComplexF64</code></pre><p>The type returned should correspond to the vector space <span>$V$</span> of the output space of the Fourier series, i.e. the output of <code>value</code> should be of this type. For good performance, the <code>eltype</code> should be a concrete type and should be inferrable.</p><p>With the above implemented, several methods which define functors for <code>AbstractFourierSeries</code> allow the user (and integration routines) to evaluate the type like a function with the <code>f(x)</code> syntax.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>The concrete types listed below all implement the <code>AbstractFourierSeries</code> interface and should cover most use cases.</p><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.Applications.FourierSeries" href="#AutoBZ.Applications.FourierSeries"><code>AutoBZ.Applications.FourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FourierSeries(coeffs, period::SVector{N,Float64}) where {N}</code></pre><p>Construct a Fourier series whose coefficients are given by the coefficient array array <code>coeffs</code> whose <code>eltype</code> should support addition and scalar multiplication, and whose periodicity on the <code>i</code>th axis is given by <code>period[i]</code>. This type represents the Fourier series</p><p class="math-container">\[f(\vec{x}) = \sum_{\vec{n} \in \mathcal I} C_{\vec{n}} \exp(i2\pi\vec{k}_{\vec{n}}\cdot\overrightarrow{x})\]</p><p>where <span>$i = \sqrt{-1}$</span> is the imaginary unit, <span>$C$</span> is the array <code>coeffs</code>, <span>$\mathcal I$</span> is <code>CartesianIndices(C)</code>, <span>$\vec{n}$</span> is a <code>CartesianIndex</code> and <span>$\vec{k}_{\vec{n}}$</span> is equal to <span>$n_j/p_j$</span> in the <span>$j$</span>th position with <span>$p_j$</span> the <span>$j$</span>th element of <code>period</code>. Because of the choice to use Cartesian indices to set the phase factors, typically the indices of <code>coeffs</code> should be specified by using an <code>OffsetArray</code>.</p><pre><code class="nohighlight hljs">FourierSeries(coeffs::AbstractArray{T,N}, period::Real) where {T,N}</code></pre><p>If period is a <code>Real</code>, this constructor will infer the number of input dimensions of the Fourier series from the array dimensionality of the coefficients, and <code>period</code> will become the period of all of the dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/cd3cd8cf0346c42399a330129727dfc91170e093/src/FourierSeries.jl#L65-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.Applications.FourierSeriesDerivative" href="#AutoBZ.Applications.FourierSeriesDerivative"><code>AutoBZ.Applications.FourierSeriesDerivative</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FourierSeriesDerivative(f::FourierSeries{N}, a::SVector{N}) where {N}</code></pre><p>Represent the differential of Fourier series <code>f</code> by a multi-index <code>a</code> of derivatives, e.g. <code>[1,2,...]</code>, whose <code>i</code>th entry represents the order of differentiation on the <code>i</code>th input dimension of <code>f</code>. Mathematically, this means</p><p class="math-container">\[\left( \prod_{j=1}^N \partial_{x_j}^{a_j} \right) f(\vec{x}) = \sum_{\vec{n} \in \mathcal I} \left( \prod_{j=1}^N (i 2\pi k_j)^{a_j} \right) C_{\vec{n}} \exp(i2\pi\vec{k}_{\vec{n}}\cdot\overrightarrow{x})\]</p><p>where <span>$\partial_{x_j}^{a_j}$</span> represents the <span>$a_j$</span>th derivative of <span>$x_j$</span>, <span>$i = \sqrt{-1}$</span> is the imaginary unit, <span>$C$</span> is the array <code>coeffs</code>, <span>$\mathcal I$</span> is <code>CartesianIndices(C)</code>, <span>$\vec{n}$</span> is a <code>CartesianIndex</code> and <span>$\vec{k}_{\vec{n}}$</span> is equal to <span>$n_j/p_j$</span> in the <span>$j$</span>th position with <span>$p_j$</span> the <span>$j$</span>th element of <code>period</code>. Because of the choice to use Cartesian indices to set the phase factors, typically the indices of <code>coeffs</code> should be specified by using an <code>OffsetArray</code>. Also, note that termwise differentiation of the Fourier series results in additional factors of <span>$i2\pi$</span> which should be anticipated for the use case. Also, note that this type can be used to represent fractional differentiation or integration by suitably choosing the <span>$a_j$</span>s.</p><p>This is a &#39;lazy&#39; representation of the derivative because instead of differentiating by computing all of the Fourier coefficients of the derivative upon constructing the object, the evaluator waits until it contracts the differentiated dimension to evaluate the new coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/cd3cd8cf0346c42399a330129727dfc91170e093/src/FourierSeries.jl#L167-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.Applications.OffsetFourierSeries" href="#AutoBZ.Applications.OffsetFourierSeries"><code>AutoBZ.Applications.OffsetFourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OffsetFourierSeries(f::AbstractFourierSeries{N}, q::SVector{N,Float64}) where {N}</code></pre><p>Represent a Fourier series whose argument is offset by the vector <span>$\vec{q}$</span> and evaluates it as <span>$f(\vec{x}-\vec{q})$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/cd3cd8cf0346c42399a330129727dfc91170e093/src/FourierSeries.jl#L281-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.Applications.ManyFourierSeries" href="#AutoBZ.Applications.ManyFourierSeries"><code>AutoBZ.Applications.ManyFourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManyFourierSeries(fs::AbstractFourierSeries{N}...) where {N}</code></pre><p>Represents a tuple of Fourier series of the same dimension and periodicity and contracts them all simultaneously.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/cd3cd8cf0346c42399a330129727dfc91170e093/src/FourierSeries.jl#L296-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.Applications.ManyOffsetsFourierSeries" href="#AutoBZ.Applications.ManyOffsetsFourierSeries"><code>AutoBZ.Applications.ManyOffsetsFourierSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManyOffsetsFourierSeries(f, qs..., [origin=true])</code></pre><p>Represent a Fourier series evaluated at many different points, and contract them all simultaneously, returning them in the order the <code>qs</code> were passed, i.e. <code>(f(x-qs[1]), f(x-qs[2]), ...)</code> The <code>origin</code> keyword decides whether or not to evaluate <span>$f$</span> without an offset, and if <code>origin</code> is true, the value of <span>$f$</span> evaluated without an offset will be returned in the first position of the output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/cd3cd8cf0346c42399a330129727dfc91170e093/src/FourierSeries.jl#L315-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.Applications.BandEnergyVelocity" href="#AutoBZ.Applications.BandEnergyVelocity"><code>AutoBZ.Applications.BandEnergyVelocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BandEnergyVelocity(H::FourierSeries{3})</code></pre><p>This constructor takes a Fourier series representing the Hamiltonian and also evaluates the band velocities so that the return value after all the dimensions are contracted is a tuple containing <code>(H, ν₁, ν₂, ν₃)</code>. The band velocities are defined by dipole operators <span>$\nu_{\alpha} = \frac{1}{\hbar} \partial_{k_{\alpha}} H$</span> where <span>$k_{\alpha}$</span> is one of three input dimensions of <span>$H$</span> and <span>$\hbar=1$</span>. Note that differentiation by <span>$k$</span> changes the units to have an additional dimension of length and a factor of <span>$2\pi$</span>, so if <span>$H$</span> has dimensions of energy, <span>$\nu$</span> has dimensions of energy times length. The caller is responsible for transforming the units of the velocity (i.e. <span>$\hbar$</span>) if they want other units, which can usually be done as a post-processing step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/cd3cd8cf0346c42399a330129727dfc91170e093/src/band_velocities.jl#L3-L17">source</a></section></article><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AutoBZ.Applications.contract-Tuple{AutoBZ.Applications.AbstractFourierSeries}" href="#AutoBZ.Applications.contract-Tuple{AutoBZ.Applications.AbstractFourierSeries}"><code>AutoBZ.Applications.contract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contract(f::FourierSeries{N}, x::Number, [dim=N]) where {N}</code></pre><p>Contract index <code>dim</code> of the coefficients of <code>f</code> at the spatial point <code>x</code>. The default <code>dim</code> is the outermost dimension to preserve memory locality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/cd3cd8cf0346c42399a330129727dfc91170e093/src/FourierSeries.jl#L97-L102">source</a></section><section><div><pre><code class="nohighlight hljs">contract(f::FourierSeriesDerivative{N}, x::Number, [dim=N]) where {N}</code></pre><p>Contract index <code>dim</code> of the coefficients of <code>f</code> at the spatial point <code>x</code>. The default <code>dim</code> is the outermost dimension to preserve memory locality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lxvm/AutoBZ.jl/blob/cd3cd8cf0346c42399a330129727dfc91170e093/src/FourierSeries.jl#L199-L204">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/integration_limits/">« Integration limits</a><a class="docs-footer-nextpage" href="../integrands/">Integrands »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 1 November 2022 01:28">Tuesday 1 November 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
