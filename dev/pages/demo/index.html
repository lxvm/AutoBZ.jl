<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Demos · AutoBZ.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AutoBZ.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../man/adaptive_integration/">Adaptive integration</a></li><li><a class="tocitem" href="../man/equispace_integration/">Equispace integration</a></li><li><a class="tocitem" href="../man/integration_limits/">Integration limits</a></li></ul></li><li><span class="tocitem">Applications</span><ul><li><a class="tocitem" href="../app/fourier/">Fourier series</a></li><li><a class="tocitem" href="../app/integrands/">Integrands</a></li><li><a class="tocitem" href="../app/interfaces/">Interfaces</a></li><li><a class="tocitem" href="../app/self_energy/">Self energies</a></li></ul></li><li class="is-active"><a class="tocitem" href>Demos</a><ul class="internal"><li><a class="tocitem" href="#DOS-of-the-integer-lattice-tight-binding-model"><span>DOS of the integer lattice tight-binding model</span></a></li><li><a class="tocitem" href="#Custom-integrands"><span>Custom integrands</span></a></li><li><a class="tocitem" href="#Graphene-example-with-ManyOffsetsFourierSeries"><span>Graphene example with <code>ManyOffsetsFourierSeries</code></span></a></li></ul></li><li><a class="tocitem" href="../workflow/">Workflow</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Demos</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Demos</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lxvm/AutoBZ.jl/blob/main/docs/src/pages/demo.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Demos"><a class="docs-heading-anchor" href="#Demos">Demos</a><a id="Demos-1"></a><a class="docs-heading-anchor-permalink" href="#Demos" title="Permalink"></a></h1><h2 id="DOS-of-the-integer-lattice-tight-binding-model"><a class="docs-heading-anchor" href="#DOS-of-the-integer-lattice-tight-binding-model">DOS of the integer lattice tight-binding model</a><a id="DOS-of-the-integer-lattice-tight-binding-model-1"></a><a class="docs-heading-anchor-permalink" href="#DOS-of-the-integer-lattice-tight-binding-model" title="Permalink"></a></h2><p>To demonstrate setting up a DOS calculation with AutoBZ, we consider a tight-binding model on the <span>$n$</span>-dimensional integer lattice with lattice constant <span>$a$</span> and hopping strength <span>$t&gt;0$</span>:</p><p class="math-container">\[H = -t \sum_{i \in Z^n} \sum_{j=1}^n \ket{i}\bra{i+\hat{j}} + \ket{i+\hat{j}}\bra{i}\]</p><p>Solving this model by employing Bloch&#39;s theorem yields the following band</p><p class="math-container">\[H(k_1, \ldots, k_n) = -t(\cos(k_1 a) + \cdots + \cos(k_n a))\]</p><p>We shall input this Hamiltonian by constructing the equivalent Fourier series</p><pre><code class="language-julia hljs">using StaticArrays
using OffsetArrays

using AutoBZ
using AutoBZ.Applications

n = 3 # arbitrary positive integer
a = fill(1.0, SVector{n})
ax = repeat([-1:1], n)
C = zeros(SMatrix{1,1,ComplexF64,1}, ntuple(_ -&gt; 3, n))
for i in 1:n, j in (-1, 1)
    C[CartesianIndex(ntuple(k -&gt; k == i ? 2+j : 2, n))] = SMatrix{1,1,ComplexF64,1}(0.5)
end
H = FourierSeries(OffsetArray(C, ax...), a)</code></pre><p>Then we can define the integration problem to compute DOS, defined by the integral</p><p class="math-container">\[\operatorname{DOS}(\omega) = \int_{\text{BZ}} d\vec{k} \operatorname{Tr}[\Im\{\omega+\mu-H(\vec{k})+i\eta\}]\]</p><p>where <span>$\mu$</span> is the chemical potential and <span>$\eta$</span> is a constant scattering rate.</p><pre><code class="language-julia hljs">ω = 1.0*n # frequency
η = 0.1 # broadening
μ = 0.0 # chemical potential
Σ = EtaEnergy(η) # self energy
D = DOSIntegrand(H, ω, Σ, μ) # integrand

# construct IBZ integration limits
c = CubicLimits(H.period)
t = TetrahedralLimits(c)

# set error tolerances
atol = 1e-3
rtol = 0.0

iterated_integration(D, t; callback=contract, atol=atol, rtol=rtol)</code></pre><p>You will find a working example of this model in the <code>DOS_example.jl</code> demo that computes DOS over a range of frequencies for this model.</p><h2 id="Custom-integrands"><a class="docs-heading-anchor" href="#Custom-integrands">Custom integrands</a><a id="Custom-integrands-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-integrands" title="Permalink"></a></h2><p>For integrands that can be evaluated by Wannier interpolation, the following data are necessary to define an integrand:</p><ul><li>the integrand evaluator</li><li>a Fourier series</li><li>additional parameters for the evaluator</li></ul><p>Consider implementing custom integrands using the generic template type <a href="../app/integrands/#AutoBZ.Applications.WannierIntegrand"><code>AutoBZ.Applications.WannierIntegrand</code></a> that is compatible with all of the adaptive and equispace integration routines. For example, we can replicate the preceding tight-binding example by defining a custom integrand</p><pre><code class="language-julia hljs">using LinearAlgebra
dos(H_k::AbstractMatrix, ω, μ, η) = -tr(imag(inv(complex(ω+μ, η)*I-H_k)))/pi
D = WannierIntegrand(dos, H, (ω, μ, η))</code></pre><div class="admonition is-success"><header class="admonition-header">Optimizing equispace integration</header><div class="admonition-body"><p>Unlike for adaptive integration, the caller is responsible for passing pre-computed grid values to the equispace integration routines, which is explained in the documentation for <a href="../man/equispace_integration/#Equispace-integration">Equispace integration</a> and <a href="pages/@ref"><code>AutoBZ.Applications.pre_eval_contract</code></a>.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Mixing adaptive and equispace integrals</header><div class="admonition-body"><p>While it is possible to perform an integral where some variables are integrated adaptively and others are integrated uniformly, this guide will not explain how to do this. However, an example implementation of this is  <a href="../app/integrands/#AutoBZ.Applications.AutoEquispaceOCIntegrand"><code>AutoBZ.Applications.AutoEquispaceOCIntegrand</code></a>.</p></div></div><h2 id="Graphene-example-with-ManyOffsetsFourierSeries"><a class="docs-heading-anchor" href="#Graphene-example-with-ManyOffsetsFourierSeries">Graphene example with <code>ManyOffsetsFourierSeries</code></a><a id="Graphene-example-with-ManyOffsetsFourierSeries-1"></a><a class="docs-heading-anchor-permalink" href="#Graphene-example-with-ManyOffsetsFourierSeries" title="Permalink"></a></h2><p>Let&#39;s study an example motivated by graphene whose Hamiltonian is given by a tight-binding model on the hexagonal lattice with lattice constant <span>$a$</span> and hopping amplitude <span>$t$</span>. Applying Bloch&#39;s theorem to each triangular sublattice brings the Hamiltonian into block-diagonal form, where each block is of the form</p><p class="math-container">\[-t
\begin{pmatrix}
0 &amp; f(k)
\\ f^*(k) &amp; 0
\end{pmatrix}\]</p><p>where <span>$f(k) = e^{ik\cdot\delta_1} + e^{ik\cdot\delta_2} + e^{ik\cdot\delta_3}$</span> and <span>$\delta_1 = a\hat{x}, \delta_2 = a(-1/2\hat{x}+\sqrt{3}/2\hat{y}), \delta_3 = a(-1/2\hat{x}-\sqrt{3}/2\hat{y})$</span>. To exactly construct this Fourier series, we will have to rotate basis so that these vectors are precisely integer linear combinations of the new lattice vectors. Note that by defining <span>$\hat{a}_1 = (\delta_1 - \delta_3)/3a = (\hat{x} + 1/\sqrt{3}\hat{y})/2, \hat{a}_2 = (\delta_1 - \delta_2)/3a = (\hat{x} - 1/\sqrt{3}\hat{y})/2$</span> we can write <span>$\delta_1 = a(\hat{a}_1 + \hat{a}_2), \delta_2 = a(\hat{a}_1 - 2\hat{a}_2), \delta_3 = a(-2\hat{a}_1 + \hat{a}_2)$</span>. Therefore our coordinate transformation matrix, <span>$T$</span> from Cartesian coordinates to the triangular lattice, <span>$\{\vec{a}_i = 3a\hat{a}_i\}$</span>, is</p><p class="math-container">\[T = \frac{1}{2}
\begin{pmatrix}
1 &amp; 1/\sqrt{3}
\\ 1 &amp; -1/\sqrt{3}
\end{pmatrix}
\qquad
T^{-1} =
\begin{pmatrix}
1 &amp; 1
\\ \sqrt{3} &amp; -\sqrt{3}
\end{pmatrix}\]</p><p>and note <span>$|\operatorname{det}(T)| = 1/2\sqrt{3}$</span>. Now the corresponding reciprocal lattice vectors are constructed by the relation <span>$\hat{b}_i = \epsilon_{ij} (\hat{z} \times \hat{a}_j)$</span> and rescaling so that <span>$\hat{b}_i \cdot \hat{a}_j = 2\pi\delta_{ij}$</span>. This yields <span>$\hat{b}_1 = 2\pi(\hat{x}+\sqrt{3}\hat{y}) = 4\pi(\hat{a}_1 - 2\hat{a_2}), \hat{b}_2 = 2\pi(\hat{x}-\sqrt{3}\hat{y}) = 4\pi(2\hat{a}_1 - \hat{a_2})$</span>. We would now interpret <span>$k$</span> in this basis, and could also use <span>$T$</span> to map from the Cartesian basis to it. Also observe that if <span>$a$</span> is the lattice constant of the hexagonal lattice, then <span>$\sqrt{3}a$</span> is the lattice constant of the triangular lattice, and <span>$2\pi/\sqrt{3}a$</span> is the lattice constant of the reciprocal lattice. However, we will have to rescale integrals by factors of <span>$|\operatorname{det}{T}|$</span> because of our coordinate transformations.</p><p>Having chosen this suitable basis for <span>$k$</span> and <span>$x$</span>, we can now express the <span>$k$</span>-dependence of the block Hamiltonian as</p><p class="math-container">\[f(k) = e^{ik\cdot\delta_1} + e^{ik\cdot\delta_2} + e^{ik\cdot\delta_3}
= e^{iak\cdot(\hat{a}_1 + \hat{a}_2)} + e^{iak\cdot(\hat{a}_1 - 2\hat{a}_2)} + e^{iak\cdot(-2\hat{a}_1 + \hat{a}_2)}\]</p><p>which is amenable to a Fourier series representation.</p><p>Suppose that the integral we want to calculate is</p><p class="math-container">\[g(\vec{q}) = \int_{\text{BZ}} dk_x dk_y \frac{\lambda(\xi(\vec{k})) - \lambda(\xi(\vec{k}-\vec{q}))}{\xi(\vec{k}) - \xi(\vec{k}-\vec{q})}\]</p><p>where <span>$\xi(\vec{k}) = \operatorname{det}(H(\vec{k}))$</span> and <span>$\lambda(\omega) = \partial_T f(\omega)$</span> is the temperature derivative of the Fermi distribution. Since the integrand requires evaluation of the Hamiltonian at various <span>$k$</span>-points simultaneously, the <a href="../app/fourier/#AutoBZ.Applications.ManyOffsetsFourierSeries"><code>AutoBZ.Applications.ManyOffsetsFourierSeries</code></a> type can be used to do this. Moreover, <code>AutoBZ.Applications</code> has functions to evaluate Fermi functions and their derivatives. Putting everything together leads us to the code example below</p><pre><code class="language-julia hljs">using StaticArrays
using OffsetArrays

using AutoBZ
using AutoBZ.Applications

a = 1.0
C = OffsetArray(zeros(SMatrix{2,2,ComplexF64,4}, (5,5)), -2:2, -2:2)
C[1,1]   = C[1,-2] = C[-2,1] = [0 1; 0 0]
C[-1,-1] = C[-1,2] = C[2,-1] = [0 0; 1 0]
H = FourierSeries(C, 2*pi/a)

T = 100.0 # K
kB = 8.617333262e-5 # eV/K
q = rand(SVector{2,Float64}) # arbitrary
f = ManyOffsetsFourierSeries(H, q)

lambda(x, T, kB) = -AutoBZ.Applications.fermi′(inv(kB*T), x)/(kB*T^2)
integrand_(f, T, kB) = (lambda(det(f[1]), T, kB) - lambda(det(f[2]), T, kB))/(det(f[1])-det(f[2]))
integrand = WannierIntegrand(integrand_, f, (T, kB))

c = CubicLimits(H.period)

# set error tolerances
atol = 1e-3
rtol = 0.0

iterated_integration(integrand, c; callback=contract, atol=atol, rtol=rtol)</code></pre><p>You will find a working example of this code in the <code>graphene.jl</code> demo that calculates this integral for values of <span>$\vec{q}$</span> in the Brillouin zone.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../app/self_energy/">« Self energies</a><a class="docs-footer-nextpage" href="../workflow/">Workflow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 13 November 2022 02:26">Sunday 13 November 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
