var documenterSearchIndex = {"docs":
[{"location":"pages/app/interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"pages/app/interfaces/#Wannier90","page":"Interfaces","title":"Wannier90","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"AutoBZ.Applications.parse_hamiltonian\nAutoBZ.Applications.load_hamiltonian","category":"page"},{"location":"pages/app/interfaces/#AutoBZ.Applications.parse_hamiltonian","page":"Interfaces","title":"AutoBZ.Applications.parse_hamiltonian","text":"parse_hamiltonian(filename)\n\nParse an ab-initio Hamiltonian output from Wannier90 into filename, extracting the fields (date_time, num_wann, nrpts, degen, irvec, C)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.Applications.load_hamiltonian","page":"Interfaces","title":"AutoBZ.Applications.load_hamiltonian","text":"load_hamiltonian(filename; period=1.0)\n\nLoad an ab-initio Hamiltonian output from Wannier90 into filename as an evaluatable FourierSeries whose periodicity can be set by the keyword argument period which defaults to setting the period along each dimension to 1.0. To define different periods for different dimensions, pass an SVector as the period.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#Python","page":"Interfaces","title":"Python","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Julia code, including AutoBZ.jl, can be called from Python using the package PyJulia","category":"page"},{"location":"pages/app/interfaces/#Setup","page":"Interfaces","title":"Setup","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"TL;DR","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"$ julia -e 'import Pkg; Pkg.add(\"PyCall\")'\n$ python3 -m pip install julia","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"If you want to, you can install PyJulia in a Python venv, but on the Julia side PyCall.jl must be installed in the default environment","category":"page"},{"location":"pages/app/interfaces/#Demo","page":"Interfaces","title":"Demo","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The Python snippet below shows how from the demos folder of the AutoBZ repository you can run one of the demo scripts:","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"from julia.api import Julia\njl = Julia(compiled_modules=False)\n\n# julia environment setup in working directory 'demos'\njl.eval(\"\"\"\nimport Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n\"\"\")\n\n# capture output of script\nout = jl.eval('include(\"DOS_test.jl\")')","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The first two lines are adapted for loading PyJulia on Debian systems.","category":"page"},{"location":"pages/app/integrands/#Integrands","page":"Integrands","title":"Integrands","text":"","category":"section"},{"location":"pages/app/integrands/#Functions","page":"Integrands","title":"Functions","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.greens_function\nAutoBZ.Applications.spectral_function\nAutoBZ.Applications.dos_integrand\nAutoBZ.Applications.gamma_integrand\nAutoBZ.Applications.oc_integrand\nAutoBZ.Applications.fermi\nAutoBZ.Applications.fermi′\nAutoBZ.Applications.fermi_window\nAutoBZ.Applications.cosh_ratio\nAutoBZ.Applications.EXP_P1_SMALL_X","category":"page"},{"location":"pages/app/integrands/#AutoBZ.Applications.fermi_window","page":"Integrands","title":"AutoBZ.Applications.fermi_window","text":"Evaluates a unitless window function determined by the Fermi distribution\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#Types","page":"Integrands","title":"Types","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.Applications.GreensFunction\nAutoBZ.Applications.SpectralFunction\nAutoBZ.Applications.DOSIntegrand\nAutoBZ.Applications.GammaIntegrand\nAutoBZ.Applications.OCIntegrand\nAutoBZ.Applications.EquispaceOCIntegrand\nAutoBZ.Applications.AutoEquispaceOCIntegrand","category":"page"},{"location":"pages/app/integrands/#AutoBZ.Applications.GreensFunction","page":"Integrands","title":"AutoBZ.Applications.GreensFunction","text":"GreensFunction(H,ω,Σ,μ)\nGreensFunction(H,ω,Σ)\nGreensFunction(H,M)\n\nA struct that calculates the lattice Green's function from a Hamiltonian.\n\nG(kHomegaSigmamu) = ((omega + mu) I - H(k) - Sigma(omega))^-1\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.SpectralFunction","page":"Integrands","title":"AutoBZ.Applications.SpectralFunction","text":"SpectralFunction(::GreensFunction)\n\nA struct that calculates the imaginary part of the Green's function.\n\nA(kHωημ) = pi^-1 ImG(kHωημ)\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.DOSIntegrand","page":"Integrands","title":"AutoBZ.Applications.DOSIntegrand","text":"DOSIntegrand(::SpectralFunction)\n\nA struct whose integral gives the density of states.\n\nD(kHωημ) = operatornameTrA(kHωημ)\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.GammaIntegrand","page":"Integrands","title":"AutoBZ.Applications.GammaIntegrand","text":"GammaIntegrand(H, Σ, ω, Ω, μ)\nGammaIntegrand(H, ν₁, ν₂, ν₃, Mω, MΩ)\n\nA function whose integral over the BZ gives the transport distribution.\n\nGamma_alphabeta(k) = operatornameTrnu^alpha(k) A(komega) nu^beta(k) A(k omega+Omega)\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#AutoBZ.Applications.OCIntegrand","page":"Integrands","title":"AutoBZ.Applications.OCIntegrand","text":"OCIntegrand(H, ν₁, ν₂, ν₃, Ω, β, η, μ)\n\nA function whose integral over the BZ and the frequency axis gives the optical conductivity\n\n\n\n\n\n","category":"type"},{"location":"pages/man/equispace_integration/#Equispace-integration","page":"Equispace integration","title":"Equispace integration","text":"","category":"section"},{"location":"pages/man/equispace_integration/#Routines","page":"Equispace integration","title":"Routines","text":"","category":"section"},{"location":"pages/man/equispace_integration/","page":"Equispace integration","title":"Equispace integration","text":"equispace_integration\nautomatic_equispace_integration","category":"page"},{"location":"pages/man/equispace_integration/#AutoBZ.equispace_integration","page":"Equispace integration","title":"AutoBZ.equispace_integration","text":"equispace_integration(f, l, npt; pre=nothing, pre_eval=generic_pre_eval, int_eval=generic_int_eval)\n\nEvaluate the integral of f over domain l using an equispace grid of npt points per dimension, optionally using precomputation pre\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.automatic_equispace_integration","page":"Equispace integration","title":"AutoBZ.automatic_equispace_integration","text":"automatic_equispace_integration(f, a, b; kwargs)\nautomatic_equispace_integration(f, l::IntegrationLimits; npt1=0, pre1=0, npt2=0, pre2=0, pre_eval=generic_pre_eval, int_eval=generic_int_eval, atol=0.0, rtol=1e-3, npt_update=generic_npt_update, maxevals=typemax(Int64))\n\nAutomatically evaluates the integral of f over domain l to within the requested error tolerances atol and rtol. Allows optional precomputed data at two levels of grid refinement npt1, pre1 and npt2, pre2 as well as  customizable precomputation with pre_eval and evaluation/summation int_eval. Moreover, a function defining an update strategy for npt can be passed as npt_update.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#Customization","page":"Equispace integration","title":"Customization","text":"","category":"section"},{"location":"pages/man/equispace_integration/","page":"Equispace integration","title":"Equispace integration","text":"AutoBZ.generic_npt_update\nAutoBZ.generic_pre_eval\nAutoBZ.generic_int_eval","category":"page"},{"location":"pages/man/equispace_integration/#AutoBZ.generic_npt_update","page":"Equispace integration","title":"AutoBZ.generic_npt_update","text":"generic_npt_update(npt::Integer, f, atol, rtol)\n\nReturns a new npt to try and get another digit of accuracy from PTR. This fallback option is a heuristic, since the scaling of the error is generally problem-dependent.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.generic_pre_eval","page":"Equispace integration","title":"AutoBZ.generic_pre_eval","text":"generic_pre_eval(f, l, npt)\n\nPrecomputes the grid points and weights to use for equispace quadrature of f on the domain l while applying the relevant symmetries to l to reduce the number of evaluation points.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/equispace_integration/#AutoBZ.generic_int_eval","page":"Equispace integration","title":"AutoBZ.generic_int_eval","text":"generic_int_eval(f, pre, dvol)\n\nSums the values of f on the precomputed grid points with corresponding integer weights and also multiplies by the mesh cell volume.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#Adaptive-integration","page":"Adaptive integration","title":"Adaptive integration","text":"","category":"section"},{"location":"pages/man/adaptive_integration/#Routines","page":"Adaptive integration","title":"Routines","text":"","category":"section"},{"location":"pages/man/adaptive_integration/","page":"Adaptive integration","title":"Adaptive integration","text":"tree_integration\niterated_integration","category":"page"},{"location":"pages/man/adaptive_integration/#AutoBZ.tree_integration","page":"Adaptive integration","title":"AutoBZ.tree_integration","text":"tree_integration(f, a, b)\ntree_integration(f, ::CubicLimits)\n\nCalls HCubature to perform multi-dimensional integration of f over a cube.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.iterated_integration","page":"Adaptive integration","title":"AutoBZ.iterated_integration","text":"iterated_integration(f, ::IntegrationLimits)\n\nCalls HCubature to perform iterated 1D integration of f over a domain parametrized by IntegrationLimits. Accepts a callback function whose arguments are f and the evaluation point, x, as a keyword argument. The callback can return a modified integrand to the next inner integral, but the default is thunk which delays the computation to the innermost integral.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#Customization","page":"Adaptive integration","title":"Customization","text":"","category":"section"},{"location":"pages/man/adaptive_integration/","page":"Adaptive integration","title":"Adaptive integration","text":"thunk\nAutoBZ.ThunkIntegrand\nAutoBZ.default_error_callback","category":"page"},{"location":"pages/man/adaptive_integration/#AutoBZ.thunk","page":"Adaptive integration","title":"AutoBZ.thunk","text":"thunk(f, x)\n\nDelay the computation of f(x). Needed to normally evaluate an integrand in nested integrals as employed by callbacks.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/adaptive_integration/#AutoBZ.ThunkIntegrand","page":"Adaptive integration","title":"AutoBZ.ThunkIntegrand","text":"ThunkIntegrand(f, x)\n\nStore f and x to evaluate f(x) at a later time. Can be employed in iterated integration\n\n\n\n\n\n","category":"type"},{"location":"pages/man/adaptive_integration/#AutoBZ.default_error_callback","page":"Adaptive integration","title":"AutoBZ.default_error_callback","text":"Choose a new set of error tolerances for the next inner integral.\n\n\n\n\n\n","category":"function"},{"location":"pages/demo/#Demos","page":"Demos","title":"Demos","text":"","category":"section"},{"location":"pages/demo/#DOS-of-the-integer-lattice-tight-binding-model","page":"Demos","title":"DOS of the integer lattice tight-binding model","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"To demonstrate setting up a DOS calculation with AutoBZ, we consider a tight-binding model on the n-dimensional integer lattice with lattice constant a and hopping strength t0:","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"H = -t sum_i in Z^n sum_j=1^n ketibrai+hatj + keti+hatjbrai","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Solving this model by employing Bloch's theorem yields the following band","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"H(k_1 ldots k_n) = -t(cos(k_1 a) + cdots + cos(k_n a))","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"We shall input this Hamiltonian by constructing the equivalent Fourier series","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"using StaticArrays\nusing OffsetArrays\n\nusing AutoBZ\nusing AutoBZ.Applications\n\nn = 3 # arbitrary positive integer\na = fill(1.0, SVector{n})\nax = repeat([-1:1], n)\nC = zeros(SMatrix{1,1,ComplexF64,1}, ntuple(_ -> 3, n))\nfor i in 1:n, j in (-1, 1)\n    C[CartesianIndex(ntuple(k -> k == i ? 2+j : 2, n))] = SMatrix{1,1,ComplexF64,1}(0.5)\nend\nH = FourierSeries(OffsetArray(C, ax...), a)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Then we can define the integration problem to compute DOS","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"ω = 1.0*n # frequency\nη = 0.1 # broadening\nμ = 0.0 # chemical potential\nΣ = EtaEnergy(η) # self energy\nD = DOSIntegrand(H, ω, Σ, μ) # integrand\n\n# construct IBZ integration limits\nc = CubicLimits(H.period)\nt = TetrahedralLimits(c)\n\n# set error tolerances\natol = 1e-3\nrtol = 0.0\n\niterated_integration(D, t; callback=contract, atol=atol, rtol=rtol)","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"You will find a working example of this model in the DOS_example.jl demo that computes DOS over a range of frequencies for this model","category":"page"},{"location":"pages/demo/#Custom-integrand","page":"Demos","title":"Custom integrand","text":"","category":"section"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"For integrands that can be evaluated by Wannier interpolation, the following data are necessary to define an integrand:","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"the integrand evaluator\na Fourier series\nadditional parameters","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"Consider implementing custom integrands using this generic template with a few associated methods","category":"page"},{"location":"pages/demo/","page":"Demos","title":"Demos","text":"struct WannierIntegrand{TF,TS<:AbstractFourierSeries,TP}\n    f::TF\n    s::TS\n    p::TP\nend\ncontract(w::WannierIntegrand, x) = WannierIntegrand(w.f, contract(w.s, x), p)\n(w::WannierIntegrand)(x::SVector{1}) = w(only(x))\n(w::WannierIntegrand)(x::Number) = w.f(x, w.s, w.p...)","category":"page"},{"location":"pages/man/integration_limits/#Integration-limits","page":"Integration limits","title":"Integration limits","text":"","category":"section"},{"location":"pages/man/integration_limits/#Interface","page":"Integration limits","title":"Interface","text":"","category":"section"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"lower\nupper\nbox\nsymmetries\nndims\nnsyms","category":"page"},{"location":"pages/man/integration_limits/#AutoBZ.lower","page":"Integration limits","title":"AutoBZ.lower","text":"lower(::IntegrationLimits)\n\nReturn the lower limit of the next variable of integration. If a vector is returned, then the integration routine may attempt to multidimensional integration.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.upper","page":"Integration limits","title":"AutoBZ.upper","text":"upper(::IntegrationLimits)\n\nReturn the upper limit of the next variable of integration. If a vector is returned, then the integration routine may attempt to multidimensional integration.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.box","page":"Integration limits","title":"AutoBZ.box","text":"box(::IntegrationLimits)\n\nReturn an iterator of tuples that for each dimension returns a tuple with the lower and upper limits of the integration domain without symmetries applied.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.symmetries","page":"Integration limits","title":"AutoBZ.symmetries","text":"symmetries(::IntegrationLimits)\n\nReturn an iterator over the symmetry transformations that the parametrization has used to reduce the volume of the integration domain.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#Base.ndims","page":"Integration limits","title":"Base.ndims","text":"ndims(::IntegrationLimits{d})\n\nReturns d. This is a type-based rule.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.nsyms","page":"Integration limits","title":"AutoBZ.nsyms","text":"nsyms(::IntegrationLimits)\n\nReturn the number of symmetries that the parametrization has used to reduce the volume of the integration domain.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#Types","page":"Integration limits","title":"Types","text":"","category":"section"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"IntegrationLimits\nCubicLimits\nCompositeLimits","category":"page"},{"location":"pages/man/integration_limits/#AutoBZ.IntegrationLimits","page":"Integration limits","title":"AutoBZ.IntegrationLimits","text":"IntegrationLimits{d}\n\nRepresents a set of integration limits over d variables. Realizations of this type should implement lower and upper, which return the lower and upper limits of integration along some dimension, rescale which represents the number of symmetries of the BZ which are used by the realization to reduce the BZ (the integrand over the limits gets multiplied by this factor), and a functor that accepts a single numeric argument and returns another realization of that type (in order to do nested integration). Thus the realization is also in control of the order of variables of integration and must coordinate this behavior with their integrand. Instances should also be static structs.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/integration_limits/#AutoBZ.CubicLimits","page":"Integration limits","title":"AutoBZ.CubicLimits","text":"CubicLimits(a, [b])\n\nStore integration limit information for a hypercube with vertices a and b. If b is not passed as an argument, then the lower limit defaults to zero(a).\n\n\n\n\n\n","category":"type"},{"location":"pages/man/integration_limits/#AutoBZ.CompositeLimits","page":"Integration limits","title":"AutoBZ.CompositeLimits","text":"CompositeLimits(::Tuple{Vararg{IntegrationLimits}})\n\nConstruct a collection of limits which yields the first limit followed by the second, and so on.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/integration_limits/#Routines","page":"Integration limits","title":"Routines","text":"","category":"section"},{"location":"pages/man/integration_limits/","page":"Integration limits","title":"Integration limits","text":"vol\nsymmetrize\nAutoBZ.discretize_equispace","category":"page"},{"location":"pages/man/integration_limits/#AutoBZ.vol","page":"Integration limits","title":"AutoBZ.vol","text":"vol(::IntegrationLimits)\n\nReturn the volume of the full domain without the symmetries applied\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.symmetrize","page":"Integration limits","title":"AutoBZ.symmetrize","text":"symmetrize(::IntegrationLimits, x)\nsymmetrize(::IntegrationLimits, xs...)\n\nTransform x by the symmetries of the parametrization used to reduce the domain, thus mapping the value of x on the parametrization to the full domain. When the integrand is a scalar, this is equal to nsyms(l)*x. When the integrand is a vector, this is sum(S*x for S in symmetries(l)). When the integrand is a matrix, this is sum(S*x*S' for S in symmetries(l)).\n\n\n\n\n\n","category":"function"},{"location":"pages/man/integration_limits/#AutoBZ.discretize_equispace","page":"Integration limits","title":"AutoBZ.discretize_equispace","text":"discretize_equispace(::IntegrationLimits, ::Integer)\n\nReturn an iterator of 2-tuples containing integration nodes and weights that correspond to an equispace integration grid with the symmetry transformations applied to it.\n\n\n\n\n\n","category":"function"},{"location":"#AutoBZ.jl-documentation","page":"Home","title":"AutoBZ.jl documentation","text":"","category":"section"}]
}
