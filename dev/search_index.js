var documenterSearchIndex = {"docs":
[{"location":"pages/demo/density/#Electron-density","page":"Electron density","title":"Electron density","text":"","category":"section"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"The electron density describes the number of electrons in a system. It can be calculated by integrating the DOS times a Fermi distribution over all frequencies. Often calculations of the density are needed to ensure charge self-consistency. After walking through these tutorials, continue with the demos/chem_pot_test.jl script that compares several algorithms for the calculation of the electron density of a Wannier90 Hamiltonian using the load_wannier90_data interface and a frequency-dependent self energy using the load_self_energy interface.","category":"page"},{"location":"pages/demo/density/#Model-calculation","page":"Electron density","title":"Model calculation","text":"","category":"section"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"For this tutorial and the optical conductivity tutorial we define a simple tight-binding model based on t_2g orbitals with a nearest neighbor intraband hopping and a next-nearest neighbor interband hopping.","category":"page"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"using StaticArrays\nusing OffsetArrays\nusing AutoBZ\nH = OffsetArray(zeros(SMatrix{3,3,Float64,9}, 3,3,3), -1:1, -1:1, -1:1)\n# intraband hoppings\nt = -0.25 # nearest-neighbor hopping\nH[ 1, 0, 0] = H[-1, 0, 0] =  [ 0; 0; 0;; 0; t; 0;; 0; 0; t]\nH[ 0, 1, 0] = H[ 0,-1, 0] =  [ t; 0; 0;; 0; 0; 0;; 0; 0; t]\nH[ 0, 0, 1] = H[ 0, 0,-1] =  [ t; 0; 0;; 0; t; 0;; 0; 0; 0]\n# interband hoppings\nt′ = 0.05 # next-nearest neighbor hopping\nH[ 0, 1, 1] = H[ 0,-1,-1] =  [ 0; 0; 0;; 0; 0;t′;; 0;t′; 0]\nH[ 0, 1,-1] = H[ 0,-1, 1] = -[ 0; 0; 0;; 0; 0;t′;; 0;t′; 0]\nH[ 1, 0, 1] = H[-1, 0,-1] =  [ 0; 0;t′;; 0; 0; 0;;t′; 0; 0]\nH[ 1, 0,-1] = H[-1, 0, 1] = -[ 0; 0;t′;; 0; 0; 0;;t′; 0; 0]\nH[ 1, 1, 0] = H[-1,-1, 0] =  [ 0;t′; 0;;t′; 0; 0;; 0; 0; 0]\nH[ 1,-1, 0] = H[-1, 1, 0] = -[ 0;t′; 0;;t′; 0; 0;; 0; 0; 0]\nH = HamiltonianInterp(AutoBZ.Freq2RadSeries(FourierSeries(H, period=2pi)))","category":"page"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"With this Hamiltonian we can define an ElectronDensitySolver that computes the electron density at a given temperature and scattering rate.","category":"page"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"using LinearAlgebra\nbz = load_bz(CubicSymIBZ(), Diagonal(collect(AutoBZ.period(H))))\nη = 0.1 # eV\nβ = 10.0 # 1/eV\nΣ = EtaSelfEnergy(η)\natol=1e-3\nrtol=0.0\nsolver = ElectronDensitySolver(H, bz, PTR(npt=50), Σ, QuadGKJL(); β, abstol=atol/nsyms(bz), reltol=rtol);\nnothing # hide","category":"page"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"Here, we have chosen to the order of integration to compute a frequency integral for each bmk point. We can compute the density over a range of chemical potentials and account for the normalization of the integral","category":"page"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing Plots\nfreqs = range(-2, 2, length=100)\nplot(freqs, μ -> (AutoBZ.update_density!(solver; β, μ); solve!(solver).value*2/det(bz.B)), title=\"Two hopping model\", xguide=\"μ\", yguide=\"Electron filling\", label=\"η=$η, β=$β\")\nsavefig(\"number_density.png\"); nothing # hide","category":"page"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"(Image: model electron density)","category":"page"},{"location":"pages/demo/density/#Chemical-potential-finder","page":"Electron density","title":"Chemical potential finder","text":"","category":"section"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"Using the electron density solver above, we can easily create a chemical potential finder from SimpleNonlinearSolve.jl root-finding algorithms.","category":"page"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"using SimpleNonlinearSolve\nnumber_density(μ, (solver, n_sp, ν, V, β)) = (AutoBZ.update_density!(solver; μ, β); ν - solve!(solver).value*n_sp/V)\ninterval = (-1.0, 1.0)\nprob = IntervalNonlinearProblem(number_density, interval, (solver, 2, 1.0, det(bz.B), β))\nsolve(prob, ITP())","category":"page"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"In this way, it is possible to study the temperature dependence of the chemical potential.","category":"page"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing Plots\ntemps = range(100, 300, length=10)\nf = T -> solve(remake(prob, u0=interval, p=(solver, 2, 1.0, det(bz.B), inv(8.617333262e-5*T))), ITP()).u\nplot(temps, f, title=\"Two hopping model\", xguide=\"T\", yguide=\"μ\", label=\"η=$η\")\nsavefig(\"chempot.png\"); nothing # hide","category":"page"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"(Image: model chemical potential)","category":"page"},{"location":"pages/demo/density/","page":"Electron density","title":"Electron density","text":"It is important to note that if you are using a frequency-dependent self energy that you should check the total number of electrons in the system is as expected. This can be done by integrating the DOS over all frequencies at a given chemical potential. For example, setting β=0 in the calculation above would compute half of the total number of electrons.","category":"page"},{"location":"pages/workflow/#Workflow","page":"Getting started","title":"Workflow","text":"","category":"section"},{"location":"pages/workflow/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"To install Julia, visit https://julialang.org/downloads and use the recommended method.","category":"page"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"AutoBZ.jl is an unregistered Julia package, so it can be added to a Julia environment using the repository URL and Julia's package manager as follows:","category":"page"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"using Pkg\nPkg.activate()\nPkg.add(url=\"https://github.com/lxvm/AutoBZ.jl.git\", rev=\"main\")","category":"page"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"The rev keyword can also be set to a tagged version, e.g. \"v0.5.3\". To download the repository with SSH use the git link: git@github.com:lxvm/AutoBZ.jl.git","category":"page"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"The motivation for keeping AutoBZ.jl an unregistered package is that its intended purpose of calculating specific response functions means that it can be a dependency of a project, which is reproducible with use of the package manager, but it is unlikely to become a dependency of another registered package. Users who would like to develop their own libraries based on this functionality may use AutoBZCore.jl or contact the developers with their request.","category":"page"},{"location":"pages/workflow/#Running-jobs","page":"Getting started","title":"Running jobs","text":"","category":"section"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"Potential users of AutoBZ will find scripts in the demos to use as templates for calculations and jobs. From the project environment configured above, the scripts from the demos folder can be copied with,","category":"page"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"julia --project -e 'using AutoBZ; files = [\"svo.wout\", \"svo_hr.dat\", \"svo_r.dat\", \"kc_benchmark.jl\"]; cp.(joinpath.(dirname(dirname(pathof(AutoBZ))), \"demos\", files), joinpath.(pwd(), files))'","category":"page"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"In the line above, the script kc_benchmark.jl was copied along with its default data files into the working directory. Note that any script dependencies other than AutoBZ will need to be added to the project environment, e.g. Pkg.add([\"HDF5\", \"SymmetryReduceBZ\"]).","category":"page"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"Finally, to run the script from the command line use the following:","category":"page"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"julia --project kc_benchmark.jl","category":"page"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"This process is similar to running jobs on a cluster, where it will be benefical to set the --threads flag.","category":"page"},{"location":"pages/workflow/#Contributing","page":"Getting started","title":"Contributing","text":"","category":"section"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"Read the contributing guidelines for guidance on PRs, issues, and discussions on matters relating to contributing to AutoBZ.jl.","category":"page"},{"location":"pages/workflow/#Development","page":"Getting started","title":"Development","text":"","category":"section"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"Anyone interested in developing AutoBZ.jl will likely benefit from a Revise.jl compatible workflow. The following workflow sets up an environment that makes it convenient to interactively edit the AutoBZ source code and use git to contribute changes","category":"page"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"mkdir dev\ngit clone https://github.com/lxvm/AutoBZ.jl.git dev/AutoBZ\njulia -e 'import Pkg; Pkg.activate(\".\"); Pkg.develop(path=\"dev/AutoBZ\")'","category":"page"},{"location":"pages/workflow/","page":"Getting started","title":"Getting started","text":"Updating the repository can now be done with cd dev/AutoBZ and git pull.","category":"page"},{"location":"pages/app/self_energy/#Self-energies","page":"Self energies","title":"Self energies","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"This section of the documentation explains how scalar and matrix-valued self energy data are formatted, loaded, and evaluated. Self energies are interpolated efficiently during the evaluation of the Green's function using a fast-to-evaluate polynomial or rational representation of input data.","category":"page"},{"location":"pages/app/self_energy/#IO","page":"Self energies","title":"IO","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"For self energy data stored on equispaced frequency grids, the following file formats and routines use the EquiBaryInterp.jl package to interpolate the data for continuous evaluation. Otherwise, a rational approximation of the self energy data is constructed with the AAA algorithm in BaryRational.jl and that is converted into a piecewise Chebyshev interpolant with HChebInterp.jl.","category":"page"},{"location":"pages/app/self_energy/#File-format","page":"Self energies","title":"File format","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"Depending on the amount of data necessary to represent the self-energy, there are different data file formats for scalar and matrix-valued self energies. Within matrix-valued self energies. There is also a special case for diagonal matrices.","category":"page"},{"location":"pages/app/self_energy/#Scalar","page":"Self energies","title":"Scalar","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"First line contains only nfpts, the number of frequency points in the data set. The following nfpts lines contain three columns with the frequency point, real part of the self energy, and imaginary part of the self energy. For example","category":"page"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"3001\n-15.00   7.9224534011421888  -0.0608455837453997\n-14.99   7.9107083143558103  -0.0627222170930403\n...","category":"page"},{"location":"pages/app/self_energy/#Diagonal","page":"Self energies","title":"Diagonal","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"First line contains only nfpts, the number of frequency points in the data set. Second line contains only num_wann, the number of bands used for Wannier interpolation (i.e. should be the same as the Hamiltonian). The following nfpts*num_wann lines contain four columns with the frequency point, one-base index of the self energy in the diagonal of the matrix, real part of the self energy, and imaginary part of the self energy. It is assumed that the frequency data is sorted wih the index as the faster index than the frequency. For example","category":"page"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"3001\n3\n-15.00   1   7.9224534011421888  -0.0608455837453997\n-15.00   2   7.9224534011422065  -0.0608455837453997\n...","category":"page"},{"location":"pages/app/self_energy/#Matrix","page":"Self energies","title":"Matrix","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"First line contains only nfpts, the number of frequency points in the data set. Second line contains only num_wann, the number of bands used for Wannier interpolation (i.e. should be the same as the Hamiltonian). The following nfpts*num_wann^2 lines contain five columns with the frequency point, one-base index of the self energy in the row of the matrix, one-base index of the self energy in the column of the matrix, real part of the self energy, and imaginary part of the self energy. It is assumed that the frequency data is sorted wih the index as the faster index than the frequency. For example","category":"page"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"3001\n3\n-15.00   1   1   7.9224534011421888  -0.0608455837453997\n-15.00   1   2   7.9224534011422065  -0.0608455837453997\n...","category":"page"},{"location":"pages/app/self_energy/#Routines","page":"Self energies","title":"Routines","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"AutoBZ.load_self_energy","category":"page"},{"location":"pages/app/self_energy/#AutoBZ.load_self_energy","page":"Self energies","title":"AutoBZ.load_self_energy","text":"load_self_energy(filename; [sigdigits=8, output=:interp, degree=:default])\n\nRead the self energy data in filename, which should be in either :scalar, :diagonal, or :matrix format, and return a self-energy evaluator. Note that the frequency data is assumed to be an equispace grid. The optional argument degree indicates the degree of barycentric Lagrange interpolation, and that sigdigits indicates the number of significant digits used to round the frequency data so as to avoid rounding errors.\n\nThe keyword output may take values of :interp (default) or :raw which will either return the self energy data wrapped with a high-order interpolating function (details below) or in the latter option, just the raw data.\n\nThe interpolating function will always be a piecewise high-order polynomial whose details depend on the distribution of frequency points:\n\nFor equispaced frequency points, a local barycentric Lagrange interpolant is used with a default polynomial degree of 8\nFor other frequency point distributions, first a global rational approximant is formed using the AAA algorithm, and then h-adaptive Chebyshev interpolation is performed on the global interpolant in order to obtain a fast-to-evaluate representation of default polynomial degree 16.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#Interface","page":"Self energies","title":"Interface","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"AutoBZ.AbstractSelfEnergy\nAutoBZ.lb\nAutoBZ.ub","category":"page"},{"location":"pages/app/self_energy/#AutoBZ.AbstractSelfEnergy","page":"Self energies","title":"AutoBZ.AbstractSelfEnergy","text":"AbstractSelfEnergy\n\nAn abstract type whose instances implement the following interface:\n\ninstances are callable and return a square matrix as a function of frequency\ninstances have methods lb and ub that return the lower and upper bounds of of the frequency domain for which the instance can be evaluated\n\n\n\n\n\n","category":"type"},{"location":"pages/app/self_energy/#AutoBZ.lb","page":"Self energies","title":"AutoBZ.lb","text":"lb(::AbstractSelfEnergy)\n\nReturn the greatest lower bound of the domain of the self energy evaluator\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#AutoBZ.ub","page":"Self energies","title":"AutoBZ.ub","text":"ub(::AbstractSelfEnergy)\n\nReturn the least upper bound of the domain of the self energy evaluator\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#Types","page":"Self energies","title":"Types","text":"","category":"section"},{"location":"pages/app/self_energy/","page":"Self energies","title":"Self energies","text":"AutoBZ.EtaSelfEnergy\nAutoBZ.ConstScalarSelfEnergy\nAutoBZ.ScalarSelfEnergy\nAutoBZ.DiagonalSelfEnergy\nAutoBZ.MatrixSelfEnergy","category":"page"},{"location":"pages/app/self_energy/#AutoBZ.EtaSelfEnergy","page":"Self energies","title":"AutoBZ.EtaSelfEnergy","text":"EtaSelfEnergy(η::Number)\n\nConstruct a ConstScalarSelfEnergy with value -im*η.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/self_energy/#AutoBZ.ConstScalarSelfEnergy","page":"Self energies","title":"AutoBZ.ConstScalarSelfEnergy","text":"ConstScalarSelfEnergy(v::Number)\n\nConstruct a self-energy evaluator which returns v I for any frequency.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/self_energy/#AutoBZ.ScalarSelfEnergy","page":"Self energies","title":"AutoBZ.ScalarSelfEnergy","text":"ScalarSelfEnergy(interpolant, lb, ub)\n\nConstruct a self-energy evaluator which for frequencies above lb and below ub returns the scalar interpolant at that frequency times an identity matrix.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/self_energy/#AutoBZ.DiagonalSelfEnergy","page":"Self energies","title":"AutoBZ.DiagonalSelfEnergy","text":"DiagonalSelfEnergy(interpolant, lb, ub)\n\nConstruct a self-energy evaluator which for frequencies above lb and below ub returns the vector interpolant at that frequency wrapped by a Diagonal.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/self_energy/#AutoBZ.MatrixSelfEnergy","page":"Self energies","title":"AutoBZ.MatrixSelfEnergy","text":"MatrixSelfEnergy(interpolant, lb, ub)\n\nConstruct a self-energy evaluator which for frequencies above lb and below ub returns the matrix-valued interpolant at that frequency.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/integrands/#Integrands","page":"Integrands","title":"Integrands","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.jl defines integrands to compute various physical observables, including the density of states, electronic density, and optical conductivity. To define new observables, visit AutoBZCore.jl for general-purpose interfaces to define integrals.","category":"page"},{"location":"pages/app/integrands/#Constructors","page":"Integrands","title":"Constructors","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.GlocSolver\nAutoBZ.TrGlocSolver\nAutoBZ.DOSSolver\nAutoBZ.TransportFunctionSolver\nAutoBZ.TransportDistributionSolver\nAutoBZ.KineticCoefficientSolver\nAutoBZ.OpticalConductivitySolver\nAutoBZ.ElectronDensitySolver\nAutoBZ.AuxTransportDistributionSolver\nAutoBZ.AuxKineticCoefficientSolver\nAutoBZ.AuxOpticalConductivitySolver","category":"page"},{"location":"pages/app/integrands/#AutoBZ.GlocSolver","page":"Integrands","title":"AutoBZ.GlocSolver","text":"GlocSolver(Σ, h, bz, bzalg, [linalg=JLInv()]; ω, μ=0, kws...)\n\nGreen's function integrands accepting a self energy Σ that can either be a matrix or a function of ω (see the self energy section of the documentation for examples) Additional keywords are passed directly to the solver. Use AutoBZ.update_gloc!(solver; ω, μ=0) to change the parameters. The linalg argument sets the linear system solver\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.TrGlocSolver","page":"Integrands","title":"AutoBZ.TrGlocSolver","text":"TrGlocSolver(Σ, h, bz, bzalg, [trinvalg=JLTrInv()]; ω, μ=0, kws...)\n\nGreen's function integrands accepting a self energy Σ that can either be a matrix or a function of ω (see the self energy section of the documentation for examples) Additional keywords are passed directly to the solver. Use AutoBZ.update_trgloc!(solver; ω, μ=0) to change the parameters.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.DOSSolver","page":"Integrands","title":"AutoBZ.DOSSolver","text":"DOSSolver(Σ, h, bz, bzalg, [trinvalg=JLTrInv()]; ω, μ=0, kws...)\n\nGreen's function integrands accepting a self energy Σ that can either be a matrix or a function of ω (see the self energy section of the documentation for examples) Additional keywords are passed directly to the solver. Use AutoBZ.update_dos!(solver; ω, μ=0) to change the parameters.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.TransportFunctionSolver","page":"Integrands","title":"AutoBZ.TransportFunctionSolver","text":"TransportFunctionSolver(hv::AbstractVelocityInterp, bz, bzalg; β, μ=0, kws...)\n\nA function whose integral over the BZ gives the transport function, proportional to the Drude weight,\n\nD_alphabeta = sum_nm int_textBZ dk f(epsilon_nk-mu) nu_nalpha(k) nu_mbeta(k)\n\nwhere f(omega) = (e^betaomega+1)^-1 is the Fermi distribution. Additional keywords are passed directly to the solver. Use AutoBZ.update_tf!(solver; β, μ=0) to update the parameters.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.TransportDistributionSolver","page":"Integrands","title":"AutoBZ.TransportDistributionSolver","text":"TransportDistributionSolver(Σ, hv::AbstractVelocityInterp, bz, bzalg; ω₁, ω₂, μ=0, kws...)\n\nA function whose integral over the BZ gives the transport distribution\n\nGamma_alphabeta(omega_1 omega_2) = int_textBZ dk operatornameTrnu_alpha(k) A(komega_1) nu_beta(k) A(k omega_2)\n\nBased on TRIQS. Additional keywords are passed directly to the solver. Use AutoBZ.update_td!(solver; ω₁, ω₂, μ=0) to update the parameters.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.KineticCoefficientSolver","page":"Integrands","title":"AutoBZ.KineticCoefficientSolver","text":"KineticCoefficientSolver(hv, bz, bzalg, Σ, [fdom,] falg, [linalg=JLInv()]; n, β, Ω, μ=0, scale_inner=inv(abs(det(bz.B))*nsyms(bz)), kws...)\nKineticCoefficientSolver(Σ, [fdom,] falg, hv, bz, bzalg, [linalg=JLInv()]; n, β, Ω, μ=0, scale_inner=1, kws...)\n\nA solver for kinetic coefficients. The two orderings of arguments correspond to orders of integration. (The outer integral appears first in the argument list.) Use AutoBZ.update_kc!(solver; β, Ω, μ, n) to change parameters. linalg selects the algorithm to compute the resolvent.\n\nMathematically, this computes\n\nA_nalphabeta(Omega) = int_-infty^infty d omega (betaomega)^n fracf(omega) - f(omega+Omega)Omega Gamma_alphabeta(omega omega+Omega)\n\nwhere f(omega) = (e^betaomega+1)^-1 is the Fermi distriubtion. Based on TRIQS.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.OpticalConductivitySolver","page":"Integrands","title":"AutoBZ.OpticalConductivitySolver","text":"OpticalConductivitySolver(hv, bz, bzalg, Σ, [fdom,] falg, [linalg=JLInv()]; β, Ω, μ=0, scale_inner=inv(abs(det(bz.B))*nsyms(bz)), kws...)\nOpticalConductivitySolver(Σ, [fdom,] falg, hv, bz, bzalg, [linalg=JLInv()]; β, Ω, μ=0, scale_inner=1, kws...)\n\nA solver for the optical conductivity. For details see KineticCoefficientSolver and note that by default the parameter n=0. Use AutoBZ.update_oc!(solver; β, Ω, μ) to change parameters.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.ElectronDensitySolver","page":"Integrands","title":"AutoBZ.ElectronDensitySolver","text":"ElectronDensitySolver(h, bz, bzalg, Σ, [fdom,] falg, [trinvalg=JLTrInv()]; β, μ=0, scale_inner=inv(abs(det(bz.B))*nsyms(bz)), kws...)\nElectronDensitySolver(Σ, [fdom,] falg, h, bz, bzalg, [trinvalg=JLTrInv()]; β, μ=0, scale_inner=inv(oneunit(μ)), kws...)\n\nA solver for the electron density. The two orderings of arguments correspond to orders of integration. (The outer integral appears first in the argument list.) Use AutoBZ.update_density!(solver; β, μ=0). If fdom is not specified the default is (AutoBZ.lb(Σ), AutoBZ.ub(Σ)). The scale_inner keyword is used to rescale inner integration tolerances and can be estimated to reduce computational effort, although the default will be robust. trinvalg may be specified as an algorithm for the inverse trace calculation.\n\nMathematically, this computes the electron density:\n\nn(mu) = int_-infty^infty d omega f(omega) operatornameDOS(omega+mu)\n\nwhere f(omega) = (e^betaomega+1)^-1 is the Fermi distriubtion. To get the density/number of electrons, multiply the result of this integral by n_sp/det(bz.B)\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.AuxTransportDistributionSolver","page":"Integrands","title":"AutoBZ.AuxTransportDistributionSolver","text":"AuxTransportDistributionSolver([auxfun], Σ, hv::AbstractVelocityInterp, bz, bzalg; ω₁, ω₂, μ=0, kws...)\n\nA function whose integral over the BZ gives the transport distribution\n\nGamma_alphabeta(omega_1 omega_2) = int_textBZ dk operatornameTrnu_alpha(k) A(komega_1) nu_beta(k) A(k omega_2)\n\nBased on TRIQS. Additional keywords are passed directly to the solver. Use AutoBZ.update_auxtd!(solver; ω₁, ω₂, μ) to update the parameters.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.AuxKineticCoefficientSolver","page":"Integrands","title":"AutoBZ.AuxKineticCoefficientSolver","text":"AuxKineticCoefficientSolver([auxfun], hv, bz, bzalg, Σ, [fdom,] falg, [linalg=JLInv()]; n, β, Ω, μ=0, scale_inner=inv(abs(det(bz.B))*nsyms(bz)), kws...)\nAuxKineticCoefficientSolver([auxfun], Σ, [fdom,] falg, hv, bz, bzalg, [linalg=JLInv()]; n, β, Ω, μ=0, scale_inner=1, kws...)\n\nA solver for kinetic coefficients using an auxiliary integrand. The two orderings of arguments correspond to orders of integration. (The outer integral appears first in the argument list.) The default auxfun is the sum of the Green's functions. Use AutoBZ.update_auxkc!(solver; β, Ω, μ, n) to change parameters. If fdom is not specified the default is (AutoBZ.lb(Σ), AutoBZ.ub(Σ)).\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.AuxOpticalConductivitySolver","page":"Integrands","title":"AutoBZ.AuxOpticalConductivitySolver","text":"AuxOpticalConductivitySolver([auxfun], hv, bz, bzalg, Σ, [fdom,] falg, [linalg=JLInv()]; β, Ω, μ=0, scale_inner=inv(abs(det(bz.B))*nsyms(bz)), kws...)\nAuxOpticalConductivitySolver([auxfun], Σ, [fdom,] falg, hv, bz, bzalg, [linalg=JLInv()]; β, Ω, μ=0, scale_inner=1, kws...)\n\nA solver for the optical conductivity. For details see AuxKineticCoefficientSolver and note that by default the parameter n=0. Use AutoBZ.update_auxoc!(solver; β, Ω, μ) to change parameters.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#Functions","page":"Integrands","title":"Functions","text":"","category":"section"},{"location":"pages/app/integrands/","page":"Integrands","title":"Integrands","text":"AutoBZ.fermi\nAutoBZ.fermi′\nAutoBZ.fermi_window\nAutoBZ.fermi_window_limits","category":"page"},{"location":"pages/app/integrands/#AutoBZ.fermi","page":"Integrands","title":"AutoBZ.fermi","text":"fermi(β, ω)\nfermi(x)\n\nEvaluates a Fermi distribution with unitless input\n\nf(x) = frac1e^x+1\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.fermi′","page":"Integrands","title":"AutoBZ.fermi′","text":"fermi′(x)\n\nEvaluates a first derivative of the Fermi distribution with unitless input\n\npartial_x f(x) = -frac12(cosh(x)+1)\n\nNote that the analytic expression above can be rewritten many ways using hypertrigonometric identities.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.fermi_window","page":"Integrands","title":"AutoBZ.fermi_window","text":"fermi_window(β, ω, Ω)\nfermi_window(x, y)\n\nEvaluates a unitless window function with unitless inputs determined by the Fermi distribution f and defined by\n\nchi(x y) = fracf(x) - f(x+y)y\n\nIn the case y==0 then this simplifies to the derivative of the Fermi distribution.\n\nSee also fermi and fermi′.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/integrands/#AutoBZ.fermi_window_limits","page":"Integrands","title":"AutoBZ.fermi_window_limits","text":"fermi_window_limits(Ω, β [; atol=0.0, rtol=1e-20])\n\nReturns limits (a,b) over ω restricted to the interval where the Fermi window is larger than max(atol,rtol*fermi_window(0,β*Ω)). Choosing atol and rtol wisely is important to integrating the entire region of interest, since this is a truncation of an infinite interval, and should be tested for convergence.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/fourier/#Fourier-series","page":"Fourier series","title":"Fourier series","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Fourier series represent functions as linear combinations of sinusoids whose frequencies are integer multiples of a fundamental mode. In Wannier interpolation, the periodicity of an operator, hatO, in a crystal admits a Fourier series expansion of the Bloch operator hatO(bmk) = e^-ibmkcdothatbmr hatO e^ibmkcdothatbmr as linear combinations of sinusoids at integer multiples of the real-space lattice vectors, forming a Bravais lattice. When exponentially localized Wannier functions exist, it suffices to use a modest number of lattice vectors in this expansion. The goal of this page of documentation is to describe the features, interface, and conventions of Fourier series evaluation as implemented by this library.","category":"page"},{"location":"pages/man/fourier/#Lattice-vectors","page":"Fourier series","title":"Lattice vectors","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"It is conventional to construct a basis for a reciprocal lattice bmb_j from a basis for a real-space lattice bma_i such that ","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"bmb_j cdot bma_i = 2pidelta_ij","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Then we write the momentum space variable in the reciprocal lattice vector basis","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"bmk = sum_j=1^d k_j bmb_j","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Without loss of generality, the k_j can be taken in the domain 01. Additionally, any real space lattice vector can be written as an integer linear combination of the bma_i. We lastly mention that when computing Brillouin zone integrals, we keep track of this change of basis with the Jacobian determinant of the transformation,","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"int_textBZ d bmk = detB int_01^3 d^3 k","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Here, B is a matrix whose columns are the bmb_j.","category":"page"},{"location":"pages/man/fourier/#Series-coefficients","page":"Fourier series","title":"Series coefficients","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Wannier-interpolated Hamiltonians are small matrices obtained by projecting the ab-initio Hamiltonian onto a subspace of bands with energies near the Fermi level, a process called downfolding. These Hamiltonians can be expressed by a Fourier series as in the sum below","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"H(bmk) = sum_bmR e^ibmkcdotbmR H_bmR","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"where the coefficients H_bmR are the matrix-valued Fourier coefficients. Truncating the sum over bmR at a modest number of modes can be done for Wannier Hamiltonians in the maximally-localized orbital basis, for which H(bmk) is a smooth and periodic function and thus the truncation error of its Fourier series converges super-algebraically with respect to the number of modes.","category":"page"},{"location":"pages/man/fourier/#Hamiltonian-recipe","page":"Fourier series","title":"Hamiltonian recipe","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"In model systems, a Bloch Hamiltonian can often be written down analytically. The recipe to write it as a Fourier series has two-steps","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"Identify the real and reciprocal Bravais lattices, bma_i and bmb_j, and rewrite all of the phase dependences of the Hamiltonian as bmkcdotbmR with bmk written in the basis of bmb_j and the lattice vector bmR written as an integer linear combination of bma_i.\nFactor the Hamiltonian into a linear combination of normal modes indexed by the distinct bmR vectors. If the Hamiltonian is matrix-valued, this can be done one matrix element at a time.","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"For a non-trivial example, see the DOS interpolation for Graphene.","category":"page"},{"location":"pages/man/fourier/#Interface","page":"Fourier series","title":"Interface","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"See FourierSeriesEvaluators.jl for the AbstractFourierSeries interface, which allows evaluation of the series with a function-like f(x) syntax. The Wannier90 interface will automatically construct these objects from the necessary output files.","category":"page"},{"location":"pages/man/fourier/#Types","page":"Fourier series","title":"Types","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"The concrete types listed below all implement the AbstractFourierSeries interface and should cover most use cases. They are organized by several abstract types to provide indicate physical properties of the Wannier-interpolated operator, such as a coordinate system or a gauge.","category":"page"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.AbstractWannierInterp\nAutoBZ.AbstractGaugeInterp\nAutoBZ.AbstractHamiltonianInterp\nAutoBZ.HamiltonianInterp\nAutoBZ.SOCHamiltonianInterp\nAutoBZ.AbstractCoordInterp\nAutoBZ.BerryConnectionInterp\nAutoBZ.AbstractVelocityInterp\nAutoBZ.GradientVelocityInterp\nAutoBZ.CovariantVelocityInterp\nAutoBZ.MassVelocityInterp","category":"page"},{"location":"pages/man/fourier/#AutoBZ.AbstractWannierInterp","page":"Fourier series","title":"AutoBZ.AbstractWannierInterp","text":"AbstractWannierInterp{N,T,iip} <: AbstractFourierSeries{N,T,iip}\n\nAbstract supertype for all Wannier-interpolated quantities in AutoBZ\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.AbstractGaugeInterp","page":"Fourier series","title":"AutoBZ.AbstractGaugeInterp","text":"AbstractGaugeInterp{G,N,T,iip} <: AbstractWannierInterp{N,T,iip}\n\nAn abstract subtype of AbstractFourierSeries representing Fourier series evaluators for Wannier-interpolated quantities with a choice of gauge, G, which is typically Hamiltonian or Wannier. A gauge is a choice of basis for the function space of the operator. For details, see to_gauge!.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.AbstractHamiltonianInterp","page":"Fourier series","title":"AutoBZ.AbstractHamiltonianInterp","text":"AbstractHamiltonianInterp{G,N,T,iip,isherm} <: AbstractGaugeInterp{G,N,T,iip}\n\nAbstract type representing Hamiltonians, which are matrix-valued Hermitian Fourier series. They should also have period 1, but produce derivatives with wavenumber 1 (not 2pi), in order to be consistent with definitions of the velocity operator.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.HamiltonianInterp","page":"Fourier series","title":"AutoBZ.HamiltonianInterp","text":"HamiltonianInterp(f::AbstractFourierSeries; gauge=:Wannier)\n\nA wrapper for FourierSeries with an additional gauge that allows for convenient diagonalization of the result. For details see to_gauge!.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.SOCHamiltonianInterp","page":"Fourier series","title":"AutoBZ.SOCHamiltonianInterp","text":"SOCHamiltonianInterp(f::Freq2RadSeries, λ; gauge=Wannier())\n\nA wrapper for a Fourier series in a given gauge that has spin-orbit coupling represented by the matrix λ. In particular, this interpolates [f(k) 0; 0 f(k)] + λ.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.AbstractCoordInterp","page":"Fourier series","title":"AutoBZ.AbstractCoordInterp","text":"AbstractCoordInterp{B,G,N,T,iip} <:AbstractGaugeInterp{G,N,T,iip}\n\nAn abstract subtype of AbstractGaugeInterp also containing information about the coordinate basis B, which is either Lattice or Cartesian. For details see to_coord and CoordDefault.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.BerryConnectionInterp","page":"Fourier series","title":"AutoBZ.BerryConnectionInterp","text":"BerryConnectionInterp{P}(a::ManyFourierSeries, B; coord)\n\nInterpolate the Berry connection in basis coord. a must evaluate the components of the connection in coordinate basis P, and B is the coordinate transformation from P to coord.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.AbstractVelocityInterp","page":"Fourier series","title":"AutoBZ.AbstractVelocityInterp","text":"AbstractVelocityInterp{C,B,G,N,T,iip} <:AbstractCoordInterp{B,G,N,T,iip}\n\nAn abstract subtype of AbstractCoordInterp also containing information the velocity component, C, which is typically Whole, Inter, or Intra. These choices refer to the diagonal (intra) or off-diagonal (inter) matrix elements of the velocity operator in the eigebasis of H(k). For details see to_vcomp_gauge!. Since the velocity depends on the Hamiltonian, subtypes should evaluate (H(k), (v_1(k), v_2(k), ...)).\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.GradientVelocityInterp","page":"Fourier series","title":"AutoBZ.GradientVelocityInterp","text":"GradientVelocityInterp(h::AbstractHamiltonianInterp, A; gauge, coord, vcomp)\n\nEvaluate the Hamiltonian and its gradient, which doesn't produce gauge-covariant velocities. The Hamiltonian h must be in the Wannier gauge, but this will give the result in the requested gauge. A must be the coordinate transformation from the lattice basis to the desired coord system. vcomp selects the contribution to the velocities.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.CovariantVelocityInterp","page":"Fourier series","title":"AutoBZ.CovariantVelocityInterp","text":"CovariantVelocityInterp(hv::GradientVelocityInterp, a::BerryConnectionInterp)\n\nUses the Berry connection to return fully gauge-covariant velocities. Returns a tuple of the Hamiltonian and the three velocity matrices.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.MassVelocityInterp","page":"Fourier series","title":"AutoBZ.MassVelocityInterp","text":"MassVelocityInterp(h::AbstractHamiltonianInterp, A; gauge, coord, vcomp)\n\nCompute the Hamiltonian, its gradient and Hessian, which are not gauge-covariant. See GradientVelocityInterp for explanation of the arguments\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#Gauges","page":"Fourier series","title":"Gauges","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.AbstractGauge\nAutoBZ.Wannier\nAutoBZ.Hamiltonian","category":"page"},{"location":"pages/man/fourier/#AutoBZ.AbstractGauge","page":"Fourier series","title":"AutoBZ.AbstractGauge","text":"AbstractGauge\n\nAbstract supertype of gauges (or bases) for orbital/band indices\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Wannier","page":"Fourier series","title":"AutoBZ.Wannier","text":"Wannier <: AbstractGauge\n\nSingleton type representing the Wannier gauge. In this gauge, the Fourier series representation of the operator is evaluated as-is, usually resulting in a dense matrix at each bmk point. When evaluating a Green's function, choosing this gauge requires inverting a dense matrix, which scales as mathcalO(N^3) where N is the number of orbitals.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Hamiltonian","page":"Fourier series","title":"AutoBZ.Hamiltonian","text":"Hamiltonian() <: AbstractGauge\n\nSingleton type representing the Hamiltonian gauge. This gauge is the eigenbasis of H, and all operators will be rotated to this basis. The Hamiltonian will also be returned as an Eigen factorization. In this basis, H is a diagonal matrix, so calculating a Green's function is an mathcalO(N) operation where N is the number of bands.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#Coordinate-systems","page":"Fourier series","title":"Coordinate systems","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.AbstractCoordinate\nAutoBZ.Cartesian\nAutoBZ.Lattice","category":"page"},{"location":"pages/man/fourier/#AutoBZ.AbstractCoordinate","page":"Fourier series","title":"AutoBZ.AbstractCoordinate","text":"AbstractCoordinate\n\nAbstract supertype of bases for coordinate/spatial indices\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Cartesian","page":"Fourier series","title":"AutoBZ.Cartesian","text":"Cartesian <: AbstractCoordinate\n\nSingleton type representing Cartesian coordinates.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Lattice","page":"Fourier series","title":"AutoBZ.Lattice","text":"Lattice <: AbstractCoordinate\n\nSingleton type representing lattice coordinates. The matrix B whose columns are reciprocal lattice vectors converts this basis to the Cartesian basis.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#Velocity-components","page":"Fourier series","title":"Velocity components","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.AbstractVelocityComponent\nWhole\nIntra\nInter","category":"page"},{"location":"pages/man/fourier/#AutoBZ.AbstractVelocityComponent","page":"Fourier series","title":"AutoBZ.AbstractVelocityComponent","text":"AbstractVelocityComponent\n\nAbstract supertype representing velocity components.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Whole","page":"Fourier series","title":"AutoBZ.Whole","text":"Whole <: AbstractVelocityComponent\n\nSingleton type representing whole velocities, i.e. the total velocity operator.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Intra","page":"Fourier series","title":"AutoBZ.Intra","text":"Intra <: AbstractVelocityComponent\n\nSingleton type representing intraband velocities, which are the off-diagonal terms of the velocity operator in the Hamiltonian gauge\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.Inter","page":"Fourier series","title":"AutoBZ.Inter","text":"Inter <: AbstractVelocityComponent\n\nSingleton type representing interband velocities, which are the diagonal terms of the velocity operator in the Hamiltonian gauge\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#Special-matrix-types","page":"Fourier series","title":"Special matrix types","text":"","category":"section"},{"location":"pages/man/fourier/","page":"Fourier series","title":"Fourier series","text":"AutoBZ.SOCMatrix\nAutoBZ.SSymmetricCompact","category":"page"},{"location":"pages/man/fourier/#AutoBZ.SOCMatrix","page":"Fourier series","title":"AutoBZ.SOCMatrix","text":"SOCMatrix(A)\n\nWrapper for a matrix A that should be used as a block-diagonal matrix     [A 0      0 A] as when dealing with spin-orbit coupling\n\n\n\n\n\n","category":"type"},{"location":"pages/man/fourier/#AutoBZ.SSymmetricCompact","page":"Fourier series","title":"AutoBZ.SSymmetricCompact","text":"SSymmetricCompact{N, T, L} <: StaticMatrix{N, N, T}\n\nA StaticArray subtype that represents a Symmetric matrix. Unlike LinearAlgebra.Symmetric, SSymmetricCompact stores only the lower triangle of the matrix (as an SVector). The lower triangle is stored in column-major order. For example, for an SSymmetricCompact{3}, the indices of the stored elements can be visualized as follows:\n\n┌ 1 ⋅ ⋅ ┐\n| 2 4 ⋅ |\n└ 3 5 6 ┘\n\nType parameters:\n\nN: matrix dimension;\nT: element type for lower triangle;\nL: length of the SVector storing the lower triangular elements.\n\nNote that L is always the Nth triangular number.\n\nAn SSymmetricCompact may be constructed either:\n\nfrom an AbstractVector containing the lower triangular elements; or\nfrom a Tuple containing both upper and lower triangular elements in column major order; or\nfrom another StaticMatrix.\n\nFor the latter two cases, only the lower triangular elements are used; the upper triangular elements are ignored.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/internal/#Internal","page":"Internal","title":"Internal","text":"","category":"section"},{"location":"pages/man/internal/","page":"Internal","title":"Internal","text":"The following symbols used by AutoBZ may change in future versions","category":"page"},{"location":"pages/man/internal/","page":"Internal","title":"Internal","text":"AutoBZ.hinv\nAutoBZ.tr_kron\nAutoBZ.diag_inv\nAutoBZ.tr_mul\nAutoBZ.to_gauge!\nAutoBZ.fermi_window_halfwidth\nAutoBZ.CoordDefault\nAutoBZ.CartesianRep\nAutoBZ.to_coord\nAutoBZ.shift!\nAutoBZ.tr_inv\nAutoBZ.to_vcomp_gauge!\nAutoBZ.get_safe_fermi_window_limits\nAutoBZ.parentseries\nAutoBZ.commutator\nAutoBZ.covariant_velocity\nAutoBZ.coord\nAutoBZ.LatticeRep\nAutoBZ.GaugeDefault\nAutoBZ.VcompDefault\nAutoBZ.herm\nAutoBZ.EigenProblem\nAutoBZ.hasvecs\nAutoBZ.LinearSystemProblem\nAutoBZ.LUFactorization\nAutoBZ.JLInv","category":"page"},{"location":"pages/man/internal/#AutoBZ.hinv","page":"Internal","title":"AutoBZ.hinv","text":"hinv(A::SHermitianCompact{3})\n\nCalculate the inverse of a SHermitianCompact matrix using its lower triangle. Note that if the elements on the diagonal are complex, the inverse is not Hermitian.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.tr_kron","page":"Internal","title":"AutoBZ.tr_kron","text":"tr_kron(A::T, B::T) where {T<:SVector{AbstractMatrix}}\n\nReturns a matrix whose [i,j]th entry is tr(A[i]*B[j]).\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.diag_inv","page":"Internal","title":"AutoBZ.diag_inv","text":"diag_inv(A)\n\nCalculate the diagonal entries of the inverse of A.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.tr_mul","page":"Internal","title":"AutoBZ.tr_mul","text":"tr_mul(A, B)\n\nCalculate tr(A*B) without storing the intermediate result.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.to_gauge!","page":"Internal","title":"AutoBZ.to_gauge!","text":"to_gauge!(cache, ::AbstractGauge, h) where gauge\n\nTransform the Hamiltonian according to the following values of gauge\n\nWannier: keeps h, vs in the original, orbital basis\nHamiltonian: diagonalizes h and rotates h into the energy, band basis\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.fermi_window_halfwidth","page":"Internal","title":"AutoBZ.fermi_window_halfwidth","text":"fermi_window_halfwidth(Ω, β, atol)\nfermi_window_halfwidth(β, atol)\n\nOne can show that βΩfermiwindow(ω, β, Ω) = -tanh(βΩ/2)/(cosh(β(ω+Ω/2))/cosh(βΩ/2)+1) > -tanh(βΩ/2)/(exp(abs(β(ω+Ω/2)))/2cosh(βΩ/2)+1) as well as when Ω==0, β*fermiwindow(ω, β, 0.0) = and these can be inverted to give a good bound on the width of the frequency window for which the Fermi window function is greater than atol. Returns half the width of this window.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.CoordDefault","page":"Internal","title":"AutoBZ.CoordDefault","text":"CoordDefault(::Type{T})::AbstractCoordinate where T\n\nAbstractCoordInterps should define this trait to declare the coordinate basis where they assume their data is in.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.CartesianRep","page":"Internal","title":"AutoBZ.CartesianRep","text":"CartesianRep()\n\nSymmetry representation of objects that transform under the group action in the same way as the lattice and in Cartesian coordinates.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/internal/#AutoBZ.to_coord","page":"Internal","title":"AutoBZ.to_coord","text":"to_coord(B::AbstractCoordinate, D::AbstractCoordinate, A, vs)\n\nIf B and D are the same type return vs, however and if they differ return A*vs.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.shift!","page":"Internal","title":"AutoBZ.shift!","text":"shift!(h::AbstractHamiltonianInterp, λ::Number)\n\nModifies and returns h such that it returns h - λ*I. Will throw a BoundsError if this operation cannot be done on the existing data.\n\n\n\n\n\nshift!(::AbstractVelocityInterp, λ)\n\nOffset the zero-point energy in a Hamiltonian system by a constant\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.tr_inv","page":"Internal","title":"AutoBZ.tr_inv","text":"tr_inv(A)\n\nCalculate the trace of the inverse of A.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.to_vcomp_gauge!","page":"Internal","title":"AutoBZ.to_vcomp_gauge!","text":"to_vcomp_gauge!(cache, ::Val{C}, ::Val{G}, h, vs...) where {C,G}\n\nTake the velocity components of vs in any gauge according to the value of C\n\nWhole: return the whole velocity (sum of interband and intraband components)\nIntra: return the intraband velocity (diagonal in Hamiltonian gauge)\nInter: return the interband velocity (off-diagonal terms in Hamiltonian gauge)\n\nTransform the velocities into a gauge according to the following values of G\n\nWannier: keeps H, vs in the original, orbital basis\nHamiltonian: diagonalizes H and rotates H, vs into the energy, band basis\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.get_safe_fermi_window_limits","page":"Internal","title":"AutoBZ.get_safe_fermi_window_limits","text":"get_safe_fermi_window_limits(Ω, β, lb, ub)\n\nGiven a frequency, Ω, inverse temperature, β,  returns an interval (l,u) with possibly truncated limits of integration for the frequency integral at each (Ω, β) point that are determined by the fermi_window_limits routine set to the default tolerances for the decay of the Fermi window function. The arguments lb and ub are lower and upper limits on the frequency to which the default result gets truncated if the default result would recommend a wider interval. If there is any truncation, a warning is emitted to the user, but the program will continue with the truncated limits.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.parentseries","page":"Internal","title":"AutoBZ.parentseries","text":"parentseries(::AbstractHamiltonianInterp)::FourierSeries\n\nReturn the Fourier series that the Hamiltonian wraps\n\n\n\n\n\nparentseries(::AbstractVelocityInterp)::AbstractHamiltonianInterp\n\nReturn the Hamiltonian object used for Wannier interpolation\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.commutator","page":"Internal","title":"AutoBZ.commutator","text":"commutator(A, B)\n\nReturn the commutator [A, B] = A*B - B*A.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.covariant_velocity","page":"Internal","title":"AutoBZ.covariant_velocity","text":"covariant_velocity(H, Hα, Aα)\n\nEvaluates the velocity operator hatv_alpha = -fracihbar hatr_alpha hatH with the following expression, equivalent to eqn. 18 in Yates et al.\n\nhatv_alpha = frac1hbar hatH_alpha + fracihbar hatH hatA_alpha\n\nwhere the alpha index implies differentiation by k_alpha. Note that the terms that correct the derivative of the band velocity Also, this function takes hbar = 1.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.coord","page":"Internal","title":"AutoBZ.coord","text":"coord(::AbstractCoordInterp{B})::AbstractCoordinate where B = B\n\nReturn the AbstractCoordinate basis in which an AbstractCoordInterp will be evaluated.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.LatticeRep","page":"Internal","title":"AutoBZ.LatticeRep","text":"LatticeRep()\n\nSymmetry representation of objects that transform under the group action in the same way as the lattice.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/internal/#AutoBZ.GaugeDefault","page":"Internal","title":"AutoBZ.GaugeDefault","text":"GaugeDefault(::Type{T})::AbstractCoordinate where T\n\nAbstractGaugeInterps should define this trait to declare the gauge that they assume their data is in.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.VcompDefault","page":"Internal","title":"AutoBZ.VcompDefault","text":"VcompDefault(::Type{T})::AbstractVelocityComponent where T\n\nAbstractVelocityInterps should define this trait to declare the velocity component that they assume their data is in.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.herm","page":"Internal","title":"AutoBZ.herm","text":"herm(A::AbstractMatrix)\n\nReturn the Hermitian part of the matrix A, i.e. (A+A')/2.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.EigenProblem","page":"Internal","title":"AutoBZ.EigenProblem","text":"EigenProblem(A::AbstractMatrix, [vecs::Bool=true, sortby]; kws...)\n\nDefine an eigenproblem for the matrix A with the option vecs to return the spectrum with the eigenvectors (true by default) or only the spectrum (false). A comparison function sortby(λ) can be provided to sort the eigenvalues, which by default are sorted lexicographically. sortby=nothing will leave the eigenvalues in an arbitrary order. Additonal keywords are forwarded to the solver.\n\nAims to provide a non-allocating interface to LinearAlgebra.eigen.\n\nWhen vecs is true, the value of the solution will be a LinearAlgebra.Eigen factorization object. When vecs is false, the solution will be a vector containing the eigenvalues. The function hasvecs will return vecs.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/internal/#AutoBZ.hasvecs","page":"Internal","title":"AutoBZ.hasvecs","text":"hasvecs(::EigenProblem{vecs}) where {vecs} = vecs\n\nTest whether the eigenproblem also needs the eigenvectors\n\n\n\n\n\nhasvecs(::EigenSolver{vecs}) where {vecs} = vecs\n\nTest whether the eigensolver also calculates the eigenvectors\n\n\n\n\n\nhasvecs(sol::EigenSolution{vecs}) where {vecs} = vecs\n\nTest whether the eigensolution contains the eigenvectors. If true, sol.value will be a LinearAlgebra.Eigen and otherwise a vector containing the spectrum.\n\n\n\n\n\n","category":"function"},{"location":"pages/man/internal/#AutoBZ.LinearSystemProblem","page":"Internal","title":"AutoBZ.LinearSystemProblem","text":"LinearSystemProblem(A, [Pl=identity, Pr=identity]; abstol, reltol)\n\nConstructor for a linear system of equations, represented by the matrix operator A, whose solution is the matrix inverse. The solution does not need to be the inverse, but instead a representation that can be used to solve Ax=b. The solution, sol.value, should implement x = sol.value\\b, ldiv!(x, sol.value, b), and inv.\n\n\n\n\n\n","category":"type"},{"location":"pages/man/internal/#AutoBZ.LUFactorization","page":"Internal","title":"AutoBZ.LUFactorization","text":"LUFactorization()\n\nConstruct the LU factorization of the matrix so that the inverse can be efficiently calculated for a small number of right-hand sides. Intended for mutable matrices\n\n\n\n\n\n","category":"type"},{"location":"pages/man/internal/#AutoBZ.JLInv","page":"Internal","title":"AutoBZ.JLInv","text":"JLInv()\n\nSolve a linear system by explicitly constructing the inverse. This should only be used for very small matrices, such as 3x3, or when the full matrix is desired. Intended for immutable matrices.\n\n\n\n\n\n","category":"type"},{"location":"pages/app/interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"pages/app/interfaces/#Wannier90","page":"Interfaces","title":"Wannier90","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"AutoBZ.load_wannier90_data\nAutoBZ.load_interp\nAutoBZ.load_autobz","category":"page"},{"location":"pages/app/interfaces/#AutoBZ.load_wannier90_data","page":"Interfaces","title":"AutoBZ.load_wannier90_data","text":"load_wannier90_data(seedname::String; bz::AbstractBZ=FBZ(), interp::AbstractWannierInterp=HamiltonianInterp, kwargs...)\n\nReturn a tuple (interp, bz) containing the requested Wannier interpolant, interp and the Brillouin zone bz to integrate over. The seedname should point to Wannier90 data to read in. Additional keywords are passed to the interpolant constructor, load_interp, while load_autobz can be referenced for Brillouin zone details. For a list of possible keywords, see subtypes(AbstractBZ) and using TypeTree; tt(AbstractWannierInterp).\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.load_interp","page":"Interfaces","title":"AutoBZ.load_interp","text":"load_interp(::Type{<:HamiltonianInterp}, seed;\n    gauge=Wannier(), soc=nothing,\n    compact=:N, precision=Float64, droptol=eps(precision))\n\nLoad Hamiltonian coefficients from Wannier90 output \"seed_hr.dat\" into an AbstractHamiltonianInterp that interpolates h with unit period. The gauge keyword can be Wannier or Hamiltonian to set whether the coefficients are interpolated in the orbital basis, i.e. as is, or rotated into the band basis, i.e. the Hamiltonian eigenbasis. Additionally, the soc keyword can specify a SMatrix (from StaticArrays.jl) of twice the size of the coefficients in the seed file that is added to the Hamiltonian in orbital basis. For more details see SOCMatrix.\n\nThere are also several keywords to control the memory usage of the array: compact which may indicate the coefficient matrices are Hermitian, precision which sets the floating-point precision of the array, and droptol which skips coefficients under the given relative tolerance. Possible values of compact are:\n\n:N: do not store the coefficients in compact form\n:L: store the lower triangle of the coefficients\n:U: store the upper triangle of the coefficients\n:S: store the lower triangle of the symmetrized coefficients, (c+c')/2\n\n\n\n\n\nload_interp(::Type{<:BerryConnectionInterp}, seed;\n    coord=Lattice(), soc=nothing,\n    precision=Float64, compact=:N, droptol=eps(precision))\n\nLoad position operator coefficients from Wannier90 output \"seed_r.dat\" into a BerryConnectionInterp that interpolates (A1, A2, A3). Specify coord as Lattice or Cartesian to have the position operator interpolated in those coordinates.\n\n\n\n\n\nload_interp(::Type{<:GradientVelocityInterp}, seed, A;\n    gauge=Wannier(), vcomp=Whole(), coord=Lattice(), soc=nothing,\n    precision=Float64, compact=:N, droptol=eps(precision))\n\nLoad coefficients for a Hamiltonian and its derivatives from Wannier90 output \"seed_hr.dat\" into a GradientVelocityInterp that interpolates (h, v). Specify vcomp as Whole, Intra, or Inter to use certain transitions. Note these velocities are not gauge-covariant.\n\n\n\n\n\nload_interp(::Type{<:CovariantVelocityInterp}, seed, A;\n    gauge=Wannier(), vcomp=whole(), coord=Lattice(), soc=nothing,\n    precision=Float64, compact=:N, droptol=eps(precision))\n\nLoad coefficients for a Hamiltonian and its derivatives from Wannier90 output \"seed_hr.dat\" and \"seed_r.dat\" into a CovariantVelocityInterp that interpolates (h, v). Specify vcomp as Whole, Intra, or Inter to use certain transitions. These velocities are gauge-covariant.\n\n\n\n\n\nload_interp(::Type{<:MassVelocityInterp}, seed, A;\n    gauge=Wannier(), vcomp=Whole(), coord=Lattice(), soc=nothing,\n    precision=Float64, compact=:N, droptol=eps(precision))\n\nLoad coefficients for a Hamiltonian and its derivatives from Wannier90 output \"seed_hr.dat\" into a MassVelocityInterp that interpolates (h, v, μ). Specify vcomp as Whole, Intra, or Inter to use certain transitions. Note these operators are not gauge-covariant.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#AutoBZ.load_autobz","page":"Interfaces","title":"AutoBZ.load_autobz","text":"load_autobz(::AbstractBZ, seedname; kws...)\n\nAutomatically load a BZ using data from a \"seedname.wout\" file with the AutoBZCore.load_bz interface\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#PythTB","page":"Interfaces","title":"PythTB","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"AutoBZ.load_pythtb_data","category":"page"},{"location":"pages/app/interfaces/#AutoBZ.load_pythtb_data","page":"Interfaces","title":"AutoBZ.load_pythtb_data","text":"load_pythtb_data(m, [species]; bz=FBZ(), interp=HamiltonianInterp, kws...)\n\nReturns (interp, bz) from a PythTB model m for use with AutoBZ.jl solvers. Only supports spinless, fully-periodic systems. Supplying a list of atomic species is helpful when chosing a bz of AutoBZCore.IBZ, since PythTB loses some information by combining the atomic and orbital indices into a multi-index. By default, species assigns a different element to orbitals at different positions. To call PythTB from Julia see e.g. PyCall.jl.\n\n\n\n\n\n","category":"function"},{"location":"pages/app/interfaces/#Python","page":"Interfaces","title":"Python","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Julia code, including AutoBZ.jl, can be called from Python using the package PyJulia","category":"page"},{"location":"pages/app/interfaces/#Setup","page":"Interfaces","title":"Setup","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"TL;DR","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"$ julia -e 'import Pkg; Pkg.add(\"PyCall\")'\n$ python3 -m pip install julia","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"If you want to, you can install PyJulia in a Python venv, but on the Julia side PyCall.jl must be installed in the default environment","category":"page"},{"location":"pages/app/interfaces/#Demo","page":"Interfaces","title":"Demo","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The Python snippet below shows how from the demos folder of the AutoBZ repository you can run one of the demo scripts:","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"from julia.api import Julia\njl = Julia(compiled_modules=False)\n\n# julia environment setup in working directory 'demos'\njl.eval(\"\"\"\nimport Pkg\nPkg.activate(\".\")\nPkg.instantiate()\n\"\"\")\n\n# capture output of script\nout = jl.eval('include(\"dos_test.jl\")')","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The first two lines are adapted for loading PyJulia on Debian systems.","category":"page"},{"location":"pages/app/interfaces/#MATLAB","page":"Interfaces","title":"MATLAB","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Julia code, including AutoBZ.jl, can be called from MATLAB using the package MATDaemon.jl.","category":"page"},{"location":"pages/app/interfaces/#Setup-2","page":"Interfaces","title":"Setup","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Download the","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"jlcall.m script, which will install the Julia server when first called.","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Install Julia and give MATLAB the path the Julia binary by running setenv('PATH',['path-to-julia/bin:',getenv('PATH')]);\nTest that jlcall works by running jlcall('sort', {rand(2,5)}, struct('dims', int64(2)))\nCreate setup.jl with the lines import Pkg; Pkg.activate(\".\"); Pkg.develop(path=expanduser(\"path-to-AutoBZ.jl\"));\nStart a julia server within MATLAB with the appropriate modules: jlcall('', 'project', 'path-to-myproject', 'setup', 'path-to-setup.jl', 'modules', {'LinearAlgebra','AutoBZ'}, 'threads', 'auto', 'restart', true);\nNow AutoBZ can be used via jlcall","category":"page"},{"location":"pages/app/interfaces/#Demo-2","page":"Interfaces","title":"Demo","text":"","category":"section"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"Suppose we would like to run the function get_dos defined in this script.jl","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"import Pkg; Pkg.activate(\".\"); Pkg.develop(path=expanduser(\"path-to-AutoBZ.jl\"))\nusing AutoBZ\n\nfunction get_dos(seedname, self_energy_path, ωs, rtol, atol)\n    H, FBZ = load_wannier90_data(seedname)\n    Σ = load_self_energy(self_energy_path)\n    integrand = DOSSolver(Σ, H, FBZ, IAI(); ω=first(ωs))\n    solver = IntegralSolver(integrand, FBZ, abstol=atol, reltol=rtol)\n    return map(ωs) do ω\n        update_gloc!(solver; ω)\n        solve!(solver).value\n    end\nend","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"The MATLAB snippet below shows how to setup the Julia server to run a demo script.","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"jlcall('', ...\n    'project', '/path/to/MyProject', % use Julia environment with AutoBZ\n    'setup', '/path/to/setup.jl', % path to script shown above\n    'modules', {'AutoBZ'}, % import AutoBZ and other modules\n    'threads', 'auto', % use the default number of Julia threads\n    'restart', true % start a fresh Julia server environment\n)","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"and the snippet below shows how to call get_dos from MATLAB","category":"page"},{"location":"pages/app/interfaces/","page":"Interfaces","title":"Interfaces","text":"jlcall('get_dos', '.../svo', '.../svo_self_energy.txt', {0.5})","category":"page"},{"location":"pages/viz/bz/#BZ-visualization","page":"BZ visualization","title":"BZ visualization","text":"","category":"section"},{"location":"pages/viz/bz/","page":"BZ visualization","title":"BZ visualization","text":"In addition to visualizing band diagrams, which focus on high-symmetry paths of the BZ, it can be useful to identify contributions from a full 3d view of the BZ. The examples below show how to do so using AutoBZ","category":"page"},{"location":"pages/viz/bz/#Spectral-function","page":"BZ visualization","title":"Spectral function","text":"","category":"section"},{"location":"pages/viz/bz/","page":"BZ visualization","title":"BZ visualization","text":"using StaticArrays\nusing OffsetArrays\nusing AutoBZ\nH = OffsetArray(zeros(SMatrix{3,3,Float64,9}, 3,3,3), -1:1, -1:1, -1:1)\n# intraband hoppings\nt = -0.25 # nearest-neighbor hopping\nH[ 1, 0, 0] = H[-1, 0, 0] =  [ 0; 0; 0;; 0; t; 0;; 0; 0; t]\nH[ 0, 1, 0] = H[ 0,-1, 0] =  [ t; 0; 0;; 0; 0; 0;; 0; 0; t]\nH[ 0, 0, 1] = H[ 0, 0,-1] =  [ t; 0; 0;; 0; t; 0;; 0; 0; 0]\n# interband hoppings\nt′ = 0.05 # next-nearest neighbor hopping\nH[ 0, 1, 1] = H[ 0,-1,-1] =  [ 0; 0; 0;; 0; 0;t′;; 0;t′; 0]\nH[ 0, 1,-1] = H[ 0,-1, 1] = -[ 0; 0; 0;; 0; 0;t′;; 0;t′; 0]\nH[ 1, 0, 1] = H[-1, 0,-1] =  [ 0; 0;t′;; 0; 0; 0;;t′; 0; 0]\nH[ 1, 0,-1] = H[-1, 0, 1] = -[ 0; 0;t′;; 0; 0; 0;;t′; 0; 0]\nH[ 1, 1, 0] = H[-1,-1, 0] =  [ 0;t′; 0;;t′; 0; 0;; 0; 0; 0]\nH[ 1,-1, 0] = H[-1, 1, 0] = -[ 0;t′; 0;;t′; 0; 0;; 0; 0; 0]\nH = HamiltonianInterp(AutoBZ.Freq2RadSeries(FourierSeries(H, period=2pi)))\n\nusing LinearAlgebra\nω = 0.0\nμ = -0.6\nη = 0.05 # broadening\nΣ = EtaSelfEnergy(η)\nbz = load_bz(FBZ(3), Diagonal(collect(AutoBZ.period(H))))\nsolver = DOSSolver(Σ, H, bz, PTR(npt=50); ω, μ)\nf = solver.f\nksolver = init(f.prob, f.alg; f.kwargs...)\nkpts = range(-0.5, 0.5; length=50)\nkvals = map(Iterators.product(kpts, kpts, kpts[1:26])) do k\n    h_k = f.s(k)\n    f.update!(ksolver, k, h_k, solver.p)\n    sol = solve!(ksolver)\n    f.postsolve(sol, k, h_k, solver.p)\nend\nkvals_density = kvals ./ maximum(kvals)\n\nusing GLMakie\nv = volume(kvals_density; algorithm=:iso, isovalue=1.0, isorange=0.9, \ncolormap=cgrad([:teal, :teal],10))\nsave(\"dos_k.png\", v); nothing # hide","category":"page"},{"location":"pages/viz/bz/","page":"BZ visualization","title":"BZ visualization","text":"(Image: DOS BZ visualization)","category":"page"},{"location":"pages/viz/bz/#Transport-function","page":"BZ visualization","title":"Transport function","text":"","category":"section"},{"location":"pages/viz/bz/","page":"BZ visualization","title":"BZ visualization","text":"β = 10.0\nμ = -0.6\nbz = load_bz(FBZ(3), Diagonal(collect(AutoBZ.period(H))))\nhv = GradientVelocityInterp(H, bz.A; gauge=Hamiltonian())\nsolver = TransportFunctionSolver(hv, bz, PTR(npt=50); β, μ)\nf = solver.f\nkpts = range(-0.5, 0.5; length=50)\nkvals = map(Iterators.product(kpts, kpts, kpts[1:26])) do k\n    h_k = f.s(k)\n    f.f(k, h_k, solver.p)\nend\nkvals_density = -1 .* real.(tr.(kvals)) ./ maximum(norm, kvals)\n\nv = volume(kvals_density; algorithm=:iso, isovalue=0.5, isorange=0.05, colormap=cgrad([:teal, :teal],10))\nsave(\"tf_k.png\", v); nothing # hide","category":"page"},{"location":"pages/viz/bz/","page":"BZ visualization","title":"BZ visualization","text":"(Image: transport function BZ visualization)","category":"page"},{"location":"pages/viz/bz/#Conductivity","page":"BZ visualization","title":"Conductivity","text":"","category":"section"},{"location":"pages/viz/bz/","page":"BZ visualization","title":"BZ visualization","text":"To plot the conductivity contributions at each k-point, a frequency integral needs to be evaluated and AutoBZ.jl does not currently provide an API to evaluate that. Since this would require internals, we do not provide an example and instead request that you open a Github issue if you would like this feature.","category":"page"},{"location":"pages/viz/band/#Band-diagrams","page":"Band diagrams","title":"Band diagrams","text":"","category":"section"},{"location":"pages/viz/band/","page":"Band diagrams","title":"Band diagrams","text":"Plotting band diagrams on k-paths is a common visualization tool and we show some examples of how to do so within AutoBZ. We use the Brillouin.jl package to select and visualize k-paths.","category":"page"},{"location":"pages/viz/band/#Energy-bands","page":"Band diagrams","title":"Energy bands","text":"","category":"section"},{"location":"pages/viz/band/","page":"Band diagrams","title":"Band diagrams","text":"note: In progress\nThis will be added soon","category":"page"},{"location":"pages/viz/band/#Band-velocities","page":"Band diagrams","title":"Band velocities","text":"","category":"section"},{"location":"pages/viz/band/","page":"Band diagrams","title":"Band diagrams","text":"To overlay band velocities on the k-ath ","category":"page"},{"location":"pages/demo/oc/#Optical-conductivity","page":"Optical conductivity","title":"Optical conductivity","text":"","category":"section"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"The optical conductivity is a response function that describes the electrical current response of a material to an incident electromagnetic field. AutoBZ.jl currently implements the longitudinal conductivity, which is the symmetric part of the conductivity tensor. After walking through these tutorials, continue with the demos/oc_test.jl script that compares several algorithms for the calculation of the conductivity of a Wannier90 Hamiltonian using the load_wannier90_data interface.","category":"page"},{"location":"pages/demo/oc/#Model-conductivity","page":"Optical conductivity","title":"Model conductivity","text":"","category":"section"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"For this tutorial and the electron density tutorial we define a simple tight-binding model based on t_2g orbitals with a nearest neighbor intraband hopping and a next-nearest neighbor interband hopping.","category":"page"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"using StaticArrays\nusing OffsetArrays\nusing AutoBZ\nusing LinearAlgebra\nbz = load_bz(CubicSymIBZ(), Diagonal(ones(3)))\nH = OffsetArray(zeros(SMatrix{3,3,Float64,9}, 3,3,3), -1:1, -1:1, -1:1)\n# intraband hoppings\nt = -0.25 # nearest-neighbor hopping\nH[ 1, 0, 0] = H[-1, 0, 0] =  [ 0; 0; 0;; 0; t; 0;; 0; 0; t]\nH[ 0, 1, 0] = H[ 0,-1, 0] =  [ t; 0; 0;; 0; 0; 0;; 0; 0; t]\nH[ 0, 0, 1] = H[ 0, 0,-1] =  [ t; 0; 0;; 0; t; 0;; 0; 0; 0]\n# interband hoppings\nt′ = 0.05 # next-nearest neighbor hopping\nH[ 0, 1, 1] = H[ 0,-1,-1] =  [ 0; 0; 0;; 0; 0;t′;; 0;t′; 0]\nH[ 0, 1,-1] = H[ 0,-1, 1] = -[ 0; 0; 0;; 0; 0;t′;; 0;t′; 0]\nH[ 1, 0, 1] = H[-1, 0,-1] =  [ 0; 0;t′;; 0; 0; 0;;t′; 0; 0]\nH[ 1, 0,-1] = H[-1, 0, 1] = -[ 0; 0;t′;; 0; 0; 0;;t′; 0; 0]\nH[ 1, 1, 0] = H[-1,-1, 0] =  [ 0;t′; 0;;t′; 0; 0;; 0; 0; 0]\nH[ 1,-1, 0] = H[-1, 1, 0] = -[ 0;t′; 0;;t′; 0; 0;; 0; 0; 0]\nhv = GradientVelocityInterp(HamiltonianInterp(AutoBZ.Freq2RadSeries(FourierSeries(H, period=2pi))), bz.A)","category":"page"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"The optical conductivity requires the velocity operators in addition to the Hamiltonian in order to compute the current-current correlations. For integrating the optical conductivity, we construct an OpticalConductivitySolver that computes the optical conductivity at a given chemical potential μ, inverse temperature β, and excitation frequency Ω","category":"page"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"η = 0.1 # eV\nμ = -0.669607319787773 # eV\nβ = 10.0 # 1/eV\nΣ = EtaSelfEnergy(η)\natol=1e-3\nrtol=0.0\nsolver = OpticalConductivitySolver(hv, bz, PTR(npt=50), Σ, QuadGKJL(); β, Ω=0.0, μ, abstol=atol/nsyms(bz), reltol=rtol);\nnothing # hide","category":"page"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"Then we can evaluate the frequency dependence of the conductivity and plot particular matrix elements.","category":"page"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing Plots\nfreqs = range(0, 1, length=100)\nplot(freqs, Ω -> (AutoBZ.update_oc!(solver; β, Ω, μ); real(solve!(solver).value[1,1])), title=\"Two hopping model\", xguide=\"Ω\", yguide=\"σₓₓ (a.u.)\", label=\"η=$η, β=$β\")\nsavefig(\"conductivity.png\"); nothing # hide","category":"page"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"(Image: model conductivity)","category":"page"},{"location":"pages/demo/oc/#Kinetic-coefficients","page":"Optical conductivity","title":"Kinetic coefficients","text":"","category":"section"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"A generalization of the optical conductivity is the KineticCoefficientSolver, which enables the calculation of additional transport properties. In fact, an OpticalConductivitySolver is implemented as a KineticCoefficientSolver and so we can use them interchangeably. For example, we can compute the Seebeck coefficient as a function of temperature","category":"page"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"temps = range(100, 300, length=10)\nf = T -> begin\n    AutoBZ.update_kc!(solver; β=inv(8.617333262e-5*T), Ω=0.0, μ, n=0)\n    kc_0 = solve!(solver).value\n    AutoBZ.update_kc!(solver; β=inv(8.617333262e-5*T), Ω=0.0, μ, n=1)\n    kc_1 = solve!(solver).value\n    -real(kc_1[1,1]) / real(kc_0[1,1])\nend\nplot(temps, f, title=\"Two hopping model\", xguide=\"T\", yguide=\"κₓₓ (a.u.)\", label=\"η=$η\")\nsavefig(\"seebeck.png\"); nothing # hide","category":"page"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"(Image: model Seebeck)","category":"page"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"The kinetic coefficients calculate the higher moments of the TransportDistributionSolver and are especially useful for thermal properties of solids.","category":"page"},{"location":"pages/demo/oc/#Auxiliary-integration","page":"Optical conductivity","title":"Auxiliary integration","text":"","category":"section"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"For very small scattering rates, i.e. eta  10 meV, adaptive integration algorithms are more efficient than uniform integration. However, they may suffer from a peak missing problem that we address with a technique called auxiliary integration using a AuxOpticalConductivitySolver.","category":"page"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"using IteratedIntegration: AuxValue\nη = 0.01 # eV\naux_atol = 1e-2\ntrG_auxfun(vs, G1, G2) = tr(G1) + tr(G2)\naux_solver = AuxOpticalConductivitySolver(trG_auxfun, hv, bz, IAI(AuxQuadGKJL()), Σ, AuxQuadGKJL(); Ω=0.0, μ, β, abstol=AuxValue(atol/η,aux_atol), reltol=rtol)\nsolve!(aux_solver).value.val","category":"page"},{"location":"pages/demo/oc/","page":"Optical conductivity","title":"Optical conductivity","text":"To summarize this method, we define a helper function, trG_auxfun that takes the velocities and Green's functions as its arguments, and should evaluate a quantity that is peaked in the same place as the conductivity integrand. Since the Green's function is less singular than the conductivity integrand at optical transitions, it is nicer to integrate adaptively and it helps the algorithm locate all highly-localized peaks with minimal additional effort.","category":"page"},{"location":"#AutoBZ.jl","page":"Home","title":"AutoBZ.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AutoBZ","category":"page"},{"location":"#AutoBZ","page":"Home","title":"AutoBZ","text":"This Julia package defines integrands for multi-dimensional Brillouin zone (BZ) using Wannier interpolation for the calculation of density of states, chemical potential, and optical conductivity accounting for electronic interactions through frequency-dependent self energies. It uses algorithms which automatically compute BZ integrals to a specified error tolerance by resolving smooth yet highly localized integrands.\n\nIn many-body Green's function methods, BZ integrands are localized at a scale determined by a non-zero, but possibly small, system- and temperature-dependent scattering rate. For example, the single-particle retarded Green's function of an electronic system for frequency omega and reciprocal space vector bmk with chemical potential mu, Hermitian Hamiltonian matrix H(bmk), and self-energy matrix Sigma(omega), which is given by\n\nG(omega) = int_textBZ dbmk operatornameTr left (hbaromega - H(bmk) - Sigma(omega))^-1 right\n\nis localized about the manifold defined by det(hbaromega - H(bmk))=0 (i.e. the Fermi surface when hbaromega=mu) by a scattering rate depending on operatornameIm Sigma(omega).\n\nAutoBZ.jl is built using a lower-level interface defined in AutoBZCore.jl intended for general-purpose integration and Wannier interpolation. If you are interested in defining your own integrals, please visit the AutoBZCore.jl documentation.\n\nPackage features\n\nAutomatic and adaptive algorithms\nEquispace integration (PTR) as described by Kaye et al. [1]\nAutomatic p-adaptive algorithm that refines k-grid to meet requested error\nIterated adaptive integration (IAI) with nested calls to QuadGK.jl\nH-adaptive algorithm with logarithmic complexity for increasingly localized integrands\nIrreducible Brillouin zone (IBZ) integration for the cubic lattice\nAuxiliary integration for nearly-singular integrands as described in Ref.[2]\nSupport for Wannier-interpolated integrands\nUser-defined integrands based on Bloch Hamiltonians\nDensity of states (DOS) calculations\nTransport calculations based on   TRIQS DFTTools\nCalculation of transport function and kinetic coefficients\nOption to separate intra-band and inter-band contributions\nWannier90-based parsers Hamiltonians (*_hr.dat files) and position operators (*_r.dat files)\nPythTB interface for using tight-binding models\nAutomated interpolation for frequency-dependent self-energy data in text files, using EquiBaryInterp.jl and HChebInterp.jl.\nIBZ integration for arbitrary symmetry groups (via an interface to SymmetryReduceBZ.jl)\n\n[1]: Kaye et al. \"Automatic, high-order, and adaptive algorithms for Brillouin zone integration\"\n\n[2]: Van Muñoz et al. \"High-order and adaptive optical conductivity calculations using Wannier interpolation\"\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"To start using the package, see the Getting Started and Tutorial sections.","category":"page"},{"location":"#Notes","page":"Home","title":"Notes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you are an interested Python user, see the Python section","category":"page"},{"location":"","page":"Home","title":"Home","text":"To see a poster showcasing calculations with the library, click this link","category":"page"},{"location":"#Contact-the-developer","page":"Home","title":"Contact the developer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Lorenzo Van Muñoz","category":"page"},{"location":"pages/demo/dos/#Density-of-states","page":"Density of states","title":"Density of states","text":"","category":"section"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"The density of states (DOS) is a standard electronic structure calculation. Here we show how to calculate it using a finite scattering rate, i.e. at finite temperature, using AutoBZ.jl by working through a few examples. After walking through these tutorials, continue with the demos/dos_test.jl script that compares several algorithms for the calculation of the DOS of a Wannier90 Hamiltonian using the load_wannier90_data interface.","category":"page"},{"location":"pages/demo/dos/#DOS-of-the-integer-lattice-tight-binding-model","page":"Density of states","title":"DOS of the integer lattice tight-binding model","text":"","category":"section"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"In this tutorial, we consider a tight-binding model on the n-dimensional integer lattice with lattice constant a and hopping strength t0 given by the following Hamiltonian:","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"H = -t sum_i in Z^n sum_j=1^n ketibrai+hatj + keti+hatjbrai","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"where keti represents the state at lattice site iin Z^n and hatj represents a vector of zeros except for a one at position j. We will compute the density of states (DOS) of this system, which as a function of n shows the dimension-dependent behavior of Van-Hove singularities.","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"Employing Bloch's theorem, which for this problem implies keti+hatj = e^ibmkcdothatjketi, yields the following band structure","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"H(k_1 ldots k_n) = -t(cos(k_1 a) + cdots + cos(k_n a))","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"We shall input this Hamiltonian to AutoBZ by constructing an equivalent Fourier series, which boils down to writing this Hamiltonian in the form H(bmk) = sum_bmR e^ibmkcdotbmR H_bmR, where bmR is an integer multi-index. To do this, we follow the Hamiltonian recipe. In the first step, we identify the real and reciprocal lattice basis vectors as the Cartesian coordinate basis and then observe that the bmR vectors with non-zero coefficients are exactly the nearest neighbor vectors pmhatj_j=1^n. In step two, we identify the coefficients to be -t2 for all the terms by simply writing the cosines as complex exponentials. Finally we fill the array of coefficients by taking each bmR to be the array index of the corresponding coefficient H_bmR.","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"using OffsetArrays\nusing AutoBZ\nn = 3 # arbitrary positive integer representing the number of k-space dimensions\na = 1.0 # lattice spacing\nt = 1.0 # hopping amplitude\n#=\nconstruct the array of scalar coefficients and use an OffsetArray so that the\narray indices correspond to the R integer multi-index of the Fourier series\n=#\nC = OffsetArray(zeros(3, 3, 3), -1:1, -1:1, -1:1)\nC[1,0,0] = C[0,1,0] = C[0,0,1] = C[-1,0,0] = C[0,-1,0] = C[0,0,-1] = -0.5t\nH = FourierSeries(C, period = 2pi/a)","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"Then we can define the integration problem to compute DOS, defined by the integral","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"operatornameDOS(omega) = -frac1pi int_textBZ dbmk operatornameIm left (hbaromega+mu-H(bmk)+ieta)^-1 right","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"where omega is a frequency variable, bmk is the reciprocal space vector, mu is the chemical potential and eta is a constant scattering rate. We assemble this problem using the built-in DOSSolver","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"using LinearAlgebra\nω = t*n # frequency at the band edge/Van-Hove singularity\nħ = 1.0 # reduced Planck's constant\nη = 0.1 # broadening\nΣ = EtaSelfEnergy(η)\nbz = load_bz(FBZ(3), Diagonal(collect(AutoBZ.period(H))))\nsolver = DOSSolver(Σ, HamiltonianInterp(AutoBZ.Freq2RadSeries(H)), bz, PTR(npt=50); ω);\nnothing # hide","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"To compute the integral, we defined a Brillouin zone as a domain of integration using AutoBZCore.load_bz with the integrand and domain, and chose and algorithm, in this case AutoBZCore.PTR. (Other automatic algorithms, such as AutoBZCore.AutoPTR and AutoBZCore.IAI also allow passing keywords abstol and reltol to the solver, which should provide convergence to the requested tolerance.) We can now calculate and plot the DOS as a function of frequency","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing Plots\nfreqs = range(-ω, ω, length=100) * 1.1\nplot(freqs, ω -> (AutoBZ.update_dos!(solver; ω); solve!(solver).value), title=\"Cubic lattice\", xguide=\"ħω\", yguide=\"DOS\", label=\"η=$η\")\nsavefig(\"dos_z.png\"); nothing # hide","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"(Image: dos integer lattice)","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"Here we used a built-in helper function, AutoBZ.update_dos!, to update the parameters of the solver, and CommonSolve.solve! to perform the calculation. Each observable defined in AutoBZ.jl comes with an associated solver and parameter updating function intended to be used this way.","category":"page"},{"location":"pages/demo/dos/#DOS-interpolation-for-Graphene","page":"Density of states","title":"DOS interpolation for Graphene","text":"","category":"section"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"In this tutorial, we will build the Fourier series corresponding to a tight-binding model of graphene. This example is more complex in that the lattice vectors are not orthogonal and that there are multiple bands.","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"The tight-binding model on the hexagonal lattice with lattice constant a and hopping amplitude t. Applying Bloch's theorem to each triangular sublattice brings the Hamiltonian into block-diagonal form, where each block is of the form","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"-t\nbeginpmatrix\n0  f(bmk)\n f^*(bmk)  0\nendpmatrix","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"where f(k) = sum_j=1^3 e^ibmkcdotbmdelta_j depends on the nearest-neighbor vectors","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"bmdelta_1 = ahatx\nqquad\nbmdelta_2 = a(-12hatx+sqrt32haty)\nqquad\nbmdelta_3 = a(-12hatx-sqrt32haty)","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"To exactly construct this Fourier series, we begin with step one of the Hamiltonian recipe identifying a basis of lattice vectors that forms a Bravais lattice. We can choose these as the following triangular lattice vectors","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"bma_1 = (bmdelta_1 - bmdelta_3)3\nqquad\nbma_2 = (bmdelta_1 - bmdelta_2)3","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"such that in this basis we write","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"bmdelta_1 = bma_1 + bma_2\nqquad\nbmdelta_2 = bma_1 - 2bma_2\nqquad\nbmdelta_3 = -2bma_1 + bma_2","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"Now taking step two, we factor the Hamiltonian into different normal modes and observe the bmR vectors are just the pairs of integer coefficients in the linear combination of Bravais lattice vectors for each exponential.","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"(e^ibmkcdot(bma_1 + bma_2) + e^ibmkcdot(bma_1 - 2bma_2) + e^ibmkcdot(-2bma_1 + bma_2))\nbeginpmatrix\n0  0\n -t  0\nendpmatrix\n+ (e^ibmkcdot(-bma_1 - bma_2) + e^ibmkcdot(-bma_1 + 2bma_2) + e^ibmkcdot(2bma_1 - bma_2))\nbeginpmatrix\n0  -t\n 0  0\nendpmatrix","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"This corresponds to the following Fourier series in AutoBZ","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"using StaticArrays\nusing OffsetArrays\nusing AutoBZ\na = 1.0 # length of Bravais lattice vectors\nt = 1.0 # hopping amplitude\nC = OffsetArray(zeros(SMatrix{2,2,ComplexF64,4}, (5,5)), -2:2, -2:2)\nC[1,1]   = C[1,-2] = C[-2,1] = [0 -t; 0 0] # Define C[R] = H_R\nC[-1,-1] = C[-1,2] = C[2,-1] = [0 0; -t 0]\nH = FourierSeries(C, period = 2*pi/a)","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"The DOS integrand can be formulated as before using a DOSSolver.","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"using LinearAlgebra\nω = 4.0 # eV\nη = 0.1 # eV\nΣ = EtaSelfEnergy(η)\nbz = load_bz(FBZ(2), Diagonal(collect(AutoBZ.period(H))))\nsolver = DOSSolver(Σ, HamiltonianInterp(AutoBZ.Freq2RadSeries(H)), bz, PTR(npt=100); ω);\nnothing # hide","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"Using this integral solver, we can compute a fast-to-evaluate, adaptive interpolant for the DOS using HChebInterp.jl.","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"ENV[\"GKSwstype\"] = \"100\" # hide\nusing HChebInterp\nusing Plots\nDOS = hchebinterp(ω -> (AutoBZ.update_dos!(solver; ω); solve!(solver).value), -ω, ω; atol=1e-3)\nplot(range(-ω, ω, length=1000), DOS, title=\"Graphene\", xguide=\"ħω\", yguide=\"DOS\", label=\"η=$η\")\nsavefig(\"dos_g.png\"); nothing # hide","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"(Image: dos graphene)","category":"page"},{"location":"pages/demo/dos/","page":"Density of states","title":"Density of states","text":"The advantage of interpolating the DOS is that the adaptive algorithm will automatically select frequencies to resolve narrow features to within the requested tolerance.","category":"page"}]
}
